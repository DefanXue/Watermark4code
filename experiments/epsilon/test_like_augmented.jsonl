{"anchor": "private SecurityIdentity authenticate(final String username, final char[] credential) throws IOException {\n        final ServerAuthenticationContext context = this.securityDomain.createNewAuthenticationContext();\n        final PasswordGuessEvidence evidence = new PasswordGuessEvidence(credential != null ? credential : null);\n        try {\n            context.setAuthenticationName(username);\n            if (context.verifyEvidence(evidence)) {\n                if (context.authorize()) {\n                    context.succeed();\n                    return context.getAuthorizedIdentity();\n                } else {\n                    context.fail();\n                    throw new SecurityException(\"Authorization failed\");\n                }\n            } else {\n                context.fail();\n                throw new SecurityException(\"Authentication failed\");\n            }\n        } catch (IllegalArgumentException | IllegalStateException | RealmUnavailableException e) {\n            context.fail();\n            throw e;\n        } finally {\n            if (!context.isDone()) {\n                context.fail();\n            }\n            evidence.destroy();\n        }\n    }", "negative": "public Long toLong(final Object value, final Long defaultValue) {\n\t\tfinal Long result = toLong(value);\n\t\tif (result == null) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn result;\n\t}", "type": "random_negative"}
{"anchor": "protected Map<String, Object> getCached(String keySpace, String columnFamily, String key) throws StorageClientException {\n        Map<String, Object> m = null;\n        String cacheKey = getCacheKey(keySpace, columnFamily, key);\n\n        CacheHolder cacheHolder = getFromCacheInternal(cacheKey);\n        if (cacheHolder != null) {\n            m = cacheHolder.get();\n            if (m != null) {\n                LOGGER.debug(\"Cache Hit {} {} {} \", new Object[] { cacheKey, cacheHolder, m });\n            }\n        }\n        if (m == null) {\n            m = client.get(keySpace, columnFamily, key);\n            if (m != null) {\n                LOGGER.debug(\"Cache Miss, Found Map {} {}\", cacheKey, m);\n            }\n            putToCacheInternal(cacheKey, new CacheHolder(m), true);\n        }\n        return m;\n    }", "negative": "public void forEachTargetAndOut(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) {\n\t\tfor (final Target target : targets) {\n\t\t\tfinal ScopeData scopeData = target.scopeData();\n\n\t\t\tif (scopeData.out() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (final InjectionPoint out : scopeData.out()) {\n\t\t\t\tif (out.scope() != scope) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbiConsumer.accept(target, out);\n\t\t\t}\n\t\t}\n\t}", "type": "random_negative"}
{"anchor": "public void onClose() {\n        Iterator<Entry<Integer, InvokeFuture>> iter = invokeFutureMap.entrySet().iterator();\n        while (iter.hasNext()) {\n            Entry<Integer, InvokeFuture> entry = iter.next();\n            iter.remove();\n            InvokeFuture future = entry.getValue();\n            if (future != null) {\n                future.putResponse(future.createConnectionClosedResponse(this.getRemoteAddress()));\n                future.cancelTimeout();\n                future.tryAsyncExecuteInvokeCallbackAbnormally();\n            }\n        }\n    }", "negative": "NcStreamProto.ArrayStructureRow.Builder encodeStructureData(String structName, Array data) {\n    assert data instanceof ArrayStructure;\n    ArrayStructure as = (ArrayStructure) data;\n    int nelems = (int) as.getSize();\n\n    List<MemberData> memberData = new ArrayList<>();\n    StructureMembers sm = as.getStructureMembers();\n    for (StructureMembers.Member m : sm.getMembers()) {\n      memberData.add( new MemberData(m, nelems));\n    }\n\n    // use most efficient form of data extraction\n    for (int recno=0; recno<nelems; recno++) {\n      for (MemberData md : memberData) {\n        if (md.member.isVariableLength()) {\n          md.vlenList.add(as.getArray(recno, md.member));\n        } else {\n          extractData(as, recno, md);\n        }\n      }\n    }\n\n    NcStreamProto.ArrayStructureRow.Builder builder = NcStreamProto.ArrayStructureRow.newBuilder();\n    for (MemberData md : memberData) {\n      NcStreamProto.Member.Builder member = NcStreamProto.Member.newBuilder();\n      member.setShortName(md.member.getName());\n      member.setDataType(NcStream.convertDataType(md.member.getDataType()));\n      /* LOOK\n      member.setNelems(md.nelems);\n      if (md.member.isVariableLength()) {\n        md.completeVlens();\n        nested.addAllVlens (md.vlens);\n        nested.setPrimdata(ByteString.copyFrom(md.bb));\n\n      } else if (md.member.getDataType() == DataType.STRING)\n        nested.addAllStringdata(md.stringList);\n      else if (md.member.getDataType() == DataType.OPAQUE)\n        nested.addAllOpaquedata(md.opaqueList);\n      else\n        nested.setPrimdata(ByteString.copyFrom(md.bb)); */\n\n      builder.addMembers(member);\n    }\n\n    return builder;\n  }", "type": "random_negative"}
{"anchor": "public DataFactory.Result openFeatureDataset(Access access, ucar.nc2.util.CancelTask task) throws IOException {\n    Dataset ds = access.getDataset();\n    DataFactory.Result result = new Result();\n    if (ds.getFeatureType() == null) {\n      result.errLog.format(\"InvDatasert must specify a FeatureType%n\");\n      result.fatalError = true;\n      return result;\n    }\n\n    return openFeatureDataset(ds.getFeatureType(), access, task, result);\n  }", "negative": "NcStreamProto.ArrayStructureRow.Builder encodeStructureData(String structName, Array data) {\n    assert data instanceof ArrayStructure;\n    ArrayStructure as = (ArrayStructure) data;\n    int nelems = (int) as.getSize();\n\n    List<MemberData> memberData = new ArrayList<>();\n    StructureMembers sm = as.getStructureMembers();\n    for (StructureMembers.Member m : sm.getMembers()) {\n      memberData.add( new MemberData(m, nelems));\n    }\n\n    // use most efficient form of data extraction\n    for (int recno=0; recno<nelems; recno++) {\n      for (MemberData md : memberData) {\n        if (md.member.isVariableLength()) {\n          md.vlenList.add(as.getArray(recno, md.member));\n        } else {\n          extractData(as, recno, md);\n        }\n      }\n    }\n\n    NcStreamProto.ArrayStructureRow.Builder builder = NcStreamProto.ArrayStructureRow.newBuilder();\n    for (MemberData md : memberData) {\n      NcStreamProto.Member.Builder member = NcStreamProto.Member.newBuilder();\n      member.setShortName(md.member.getName());\n      member.setDataType(NcStream.convertDataType(md.member.getDataType()));\n      /* LOOK\n      member.setNelems(md.nelems);\n      if (md.member.isVariableLength()) {\n        md.completeVlens();\n        nested.addAllVlens (md.vlens);\n        nested.setPrimdata(ByteString.copyFrom(md.bb));\n\n      } else if (md.member.getDataType() == DataType.STRING)\n        nested.addAllStringdata(md.stringList);\n      else if (md.member.getDataType() == DataType.OPAQUE)\n        nested.addAllOpaquedata(md.opaqueList);\n      else\n        nested.setPrimdata(ByteString.copyFrom(md.bb)); */\n\n      builder.addMembers(member);\n    }\n\n    return builder;\n  }", "type": "random_negative"}
{"anchor": "public final Boolean isUnsavedStatus() {\r\n\t\tMap<String, Object> viewMap = FacesContext.getCurrentInstance().getViewRoot().getViewMap();\r\n\t\tBoolean flag = (Boolean) viewMap.get(TieConstants.UNSAVEDSTATE);\r\n\t\tif (flag == null) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn flag;\r\n\t}", "negative": "public OGraphMLReader inputGraph(final Graph inputGraph, final String filename, int bufferSize, String vertexIdKey,\n      String edgeIdKey, String edgeLabelKey) throws IOException {\n    FileInputStream fis = new FileInputStream(filename);\n    try {\n      return inputGraph(inputGraph, fis, bufferSize, vertexIdKey, edgeIdKey, edgeLabelKey);\n    } finally {\n      fis.close();\n    }\n  }", "type": "random_negative"}
{"anchor": "public static int indexOf(char[] cArray, char c, int fromIndex) {\n        int cArrayLength = cArray.length;\n        for (int index = Math.max(fromIndex, 0); index < cArrayLength; index++) {\n            if (cArray[index] == c) \n                return index;\n        }\n        return -1;\n    }", "negative": "public static String getNextProductVersion(String version) throws PluginExecutionException {\n        String result = null;\n        int versionSplittingIndex = version.lastIndexOf(\".\") + 1;\n        if (versionSplittingIndex == 0) {\n            throw new PluginExecutionException(\"Product version \" + version\n                    + \" is not in the expected format. It must have period separated version segments.\");\n        }\n        String quarterVersion = version.substring(versionSplittingIndex);\n        int nextQuarterSpecifier;\n        try {\n            nextQuarterSpecifier = Integer.parseInt(quarterVersion) + 1;\n        } catch (NumberFormatException e) {\n            throw new PluginExecutionException(\"Product version \" + version\n                    + \" is not in the expected format. Its last segment is expected to be an integer.\", e);\n        }\n        result = version.substring(0, versionSplittingIndex) + nextQuarterSpecifier;\n        return result;\n    }", "type": "random_negative"}
{"anchor": "@RequestMapping(value=\"\", method={RequestMethod.GET, RequestMethod.HEAD})\n\tpublic Resources<StateDefinitionResource> getStateDefinitions() throws StateDefinitionNotFoundException, ProviderNotFoundException, AttributeDefinitionNotFoundException {\n\t\tif (LOG.isTraceEnabled()) {\n\t\t\tLOG.entry();\n\t\t}\n\t\t\n\t\tfinal Resources<StateDefinitionResource> resources = getStateDefinitions(stateDefinitionService.getStateDefinitions());\n\t\t\n\t\t\n\t\tif (LOG.isTraceEnabled()) {\n\t\t\tLOG.exit(resources);\t\n\t\t}\n\t\treturn resources;\n\t}", "negative": "@SuppressWarnings(\"unchecked\")\n\tprivate void setKey(final P pojo, final IncompleteKey key, final LoadContext ctx, final Path containerPath) {\n\t\tif (!clazz.isAssignableFrom(pojo.getClass()))\n\t\t\tthrow new IllegalArgumentException(\"Trying to use metadata for \" + clazz.getName() + \" to set key of \" + pojo.getClass().getName());\n\n\t\t// If no key, don't need to do anything\n\t\tif (key == null)\n\t\t\treturn;\n\n\t\tidMeta.setValue(pojo, Keys.getIdValue(key), ctx, containerPath);\n\n\t\tfinal com.google.cloud.datastore.Key parentKey = key.getParent();\n\t\tif (parentKey != null) {\n\t\t\tif (this.parentMeta == null)\n\t\t\t\tthrow new IllegalStateException(\"Loaded Entity has parent but \" + clazz.getName() + \" has no @Parent\");\n\n\t\t\tparentMeta.setValue(pojo, (Value)KeyValue.of(parentKey), ctx, containerPath);\n\t\t}\n\t}", "type": "random_negative"}
{"anchor": "static public void registerIOProvider(Class iospClass, boolean last)\n          throws IllegalAccessException, InstantiationException {\n    IOServiceProvider spi;\n    spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n    if (userLoads && !last)\n      registeredProviders.add(0, spi);  // put user stuff first\n    else registeredProviders.add(spi);\n  }", "negative": "ImmutableList<SingleMemberInjector> getInjectors(\n      Set<InjectionPoint> injectionPoints, Errors errors) {\n    List<SingleMemberInjector> injectors = Lists.newArrayList();\n    for (InjectionPoint injectionPoint : injectionPoints) {\n      try {\n        Errors errorsForMember =\n            injectionPoint.isOptional()\n                ? new Errors(injectionPoint)\n                : errors.withSource(injectionPoint);\n        SingleMemberInjector injector =\n            injectionPoint.getMember() instanceof Field\n                ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember)\n                : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember);\n        injectors.add(injector);\n      } catch (ErrorsException ignoredForNow) {\n        // ignored for now\n      }\n    }\n    return ImmutableList.copyOf(injectors);\n  }", "type": "random_negative"}
{"anchor": "public void renderTable()\n    {\n        for (int i = 0; i < tableModel.getRowCount(); i++)\n        {\n            int colOffset = 0;\n\n            for (int j = 0; j < tableModel.getColumnCount(); j++)\n            {\n                // Print the contents of the table cell.\n                String valueToPrint = tableModel.get(j, i);\n                valueToPrint = (valueToPrint == null) ? \"\" : valueToPrint;\n                gridModel.insert(valueToPrint, colOffset, i);\n\n                // Pad spaces up to the column width if the contents are shorted.\n                Integer maxColumnSize = tableModel.getMaxColumnSize(j);\n                int spaces = maxColumnSize - valueToPrint.length();\n\n                while (spaces > 0)\n                {\n                    gridModel.insert(\" \", colOffset + valueToPrint.length() + spaces-- - 1, i);\n                }\n\n                // Shift to the next column.\n                colOffset += maxColumnSize;\n            }\n        }\n    }", "negative": "private void initListEvents() {\n\t\tthis.listChangeListener = new ListChangeListener<SourceType>() {\n\t\t\t@Override\n\t\t\tpublic void onChanged(\n\t\t\t\t\tChange<? extends SourceType> listEvent) {\n\t\t\t\t\n\t\t\t\t// We have to stage delete events, because if we process them\n\t\t\t\t// separately, there will be unwanted ChangeEvents on the\n\t\t\t\t// targetList\n\t\t\t\tList<TargetType> deleteStaging = new ArrayList<>();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\twhile (listEvent.next()) {\n\t\t\t\t\tif (listEvent.wasUpdated()) {\n\t\t\t\t\t\tprocessUpdateEvent(listEvent);\n\t\t\t\t\t} else if (listEvent.wasReplaced()) {\n\t\t\t\t\t\tprocessReplaceEvent(listEvent, deleteStaging);\n\t\t\t\t\t} else if (listEvent.wasAdded()) {\n\t\t\t\t\t\tprocessAddEvent(listEvent);\n\t\t\t\t\t} else if (listEvent.wasRemoved()) {\n\t\t\t\t\t\tprocessRemoveEvent(listEvent, deleteStaging);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Process the staged elements\n\t\t\t\tprocessStagingLists(deleteStaging);\n\t\t\t}\n\t\t};\n\t\tmodelListProperty().addListener(\n\t\t\t\tnew WeakListChangeListener<>(listChangeListener));\n\t\t\n\t}", "type": "random_negative"}
{"anchor": "public static String getFirstText(Element parent) {\n        Assert.isNotNull(parent);\n        Node child = parent.getFirstChild();\n        while (child != null && !isText(child))\n            child = child.getNextSibling();\n        if (child == null)\n            return \"\"; //$NON-NLS-1$\n        return ((Text) child).getData();\n    }", "negative": "<T> Initializable<T> requestInjection(\n      InjectorImpl injector,\n      T instance,\n      Binding<T> binding,\n      Object source,\n      Set<InjectionPoint> injectionPoints) {\n    checkNotNull(source);\n    Preconditions.checkState(\n        !validationStarted, \"Member injection could not be requested after validation is started\");\n    ProvisionListenerStackCallback<T> provisionCallback =\n        binding == null ? null : injector.provisionListenerStore.get(binding);\n\n    // short circuit if the object has no injections or listeners.\n    if (instance == null\n        || (injectionPoints.isEmpty()\n            && !injector.membersInjectorStore.hasTypeListeners()\n            && provisionCallback == null)) {\n      return Initializables.of(instance);\n    }\n\n    if (initializablesCache.containsKey(instance)) {\n      @SuppressWarnings(\"unchecked\") // Map from T to InjectableReference<T>\n      Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance);\n      return cached;\n    }\n\n    InjectableReference<T> injectableReference =\n        new InjectableReference<T>(\n            injector,\n            instance,\n            binding == null ? null : binding.getKey(),\n            provisionCallback,\n            source,\n            cycleDetectingLockFactory.create(instance.getClass()));\n    initializablesCache.put(instance, injectableReference);\n    pendingInjections.add(injectableReference);\n    return injectableReference;\n  }", "type": "random_negative"}
{"anchor": "public static Throwable getOnlyCause(Collection<Message> messages) {\n    Throwable onlyCause = null;\n    for (Message message : messages) {\n      Throwable messageCause = message.getCause();\n      if (messageCause == null) {\n        continue;\n      }\n\n      if (onlyCause != null && !ThrowableEquivalence.INSTANCE.equivalent(onlyCause, messageCause)) {\n        return null;\n      }\n\n      onlyCause = messageCause;\n    }\n\n    return onlyCause;\n  }", "negative": "public static int getPropertyInt( final Object root, final String... properties ) {\n\n\n        final String lastProperty = properties[ properties.length - 1 ];\n\n\n\n\n        if ( isDigits( lastProperty ) ) {\n\n            return Conversions.toInt(getPropertyValue(root, properties));\n\n        }\n\n\n        Object object = baseForGetProperty( root, properties );\n\n        Map<String, FieldAccess> fields = getFieldsFromObject( object );\n\n        FieldAccess field = fields.get( lastProperty );\n\n\n        if ( field.type() == Typ.intgr ) {\n            return field.getInt( object );\n        } else {\n            return Conversions.toInt( field.getValue( object ) );\n        }\n\n    }", "type": "random_negative"}
{"anchor": "public StructureData readStructure(int index) throws IOException, ucar.ma2.InvalidRangeException {\n    Section section = null; // works for scalars i think\n\n    if (getRank() == 1) {\n      section = new Section().appendRange(index,index);\n\n    } else if (getRank() > 1) {\n      Index ii = Index.factory(shape); // convert to nD index\n      ii.setCurrentCounter(index);\n      int[] origin = ii.getCurrentCounter();\n      section = new Section();\n      for (int anOrigin : origin)\n        section.appendRange(anOrigin, anOrigin);\n    }\n\n    Array dataArray = read(section);\n    ArrayStructure data = (ArrayStructure) dataArray;\n    return data.getStructureData(0);\n  }", "negative": "private boolean isDiamondHierarchy(OClass clazz) {\n    Set<OClass> traversed = new HashSet<>();\n    List<OClass> stack = new ArrayList<>();\n    stack.add(clazz);\n    while (!stack.isEmpty()) {\n      OClass current = stack.remove(0);\n      traversed.add(current);\n      for (OClass sub : current.getSubclasses()) {\n        if (traversed.contains(sub)) {\n          return true;\n        }\n        stack.add(sub);\n        traversed.add(sub);\n      }\n    }\n    return false;\n  }", "type": "random_negative"}
{"anchor": "public static ContentValues quoteWrap(ContentValues values) {\n        ContentValues quoteValues = null;\n        if (values != null) {\n\n            Map<String, Object> quoteMap = new HashMap<>();\n            for (Map.Entry<String, Object> value : values.valueSet()) {\n                quoteMap.put(CoreSQLUtils.quoteWrap(value.getKey()), value.getValue());\n            }\n\n            Parcel parcel = Parcel.obtain();\n            parcel.writeMap(quoteMap);\n            parcel.setDataPosition(0);\n            quoteValues = ContentValues.CREATOR.createFromParcel(parcel);\n            parcel.recycle();\n        }\n\n        return quoteValues;\n    }", "negative": "public static boolean hasDifferentValue(XsdDoubleRestrictions o1, XsdDoubleRestrictions o2) {\n        if (o1 == null && o2 == null) {\n            return false;\n        }\n\n        double o1Value = Double.MAX_VALUE;\n        double o2Value;\n\n        if (o1 != null) {\n            o1Value = o1.getValue();\n        }\n\n        if (o2 != null) {\n            o2Value = o2.getValue();\n            return o2Value == o1Value;\n        }\n\n        return false;\n    }", "type": "random_negative"}
{"anchor": "public static SizeableList<WAMInstruction> disassemble(int start, int length, ByteBuffer codeBuf,\n        VariableAndFunctorInterner interner, WAMCodeView codeView)\n    {\n        SizeableList<WAMInstruction> result = new SizeableLinkedList<WAMInstruction>();\n        int ip = start;\n\n        while (ip < (start + length))\n        {\n            // Decode the instruction and its arguments.\n            byte iCode = codeBuf.get(ip);\n\n            WAMInstruction instruction = new WAMInstruction(iCode);\n            instruction.mnemonic.disassembleArguments(instruction, ip, codeBuf, interner);\n\n            // Restore any label on the instruction.\n            Integer label = codeView.getNameForAddress(ip);\n\n            if (label != null)\n            {\n                FunctorName name = interner.getDeinternedFunctorName(label);\n\n                if (name instanceof WAMLabel)\n                {\n                    instruction.label = (WAMLabel) name;\n                }\n            }\n\n            result.add(instruction);\n\n            ip += instruction.mnemonic.length();\n        }\n\n        return result;\n    }", "positive": "public static arg_6<param_19> executeDisassemble(int param_47, int tmp_73, tmp_82 arg_53,\n          obj_91 arg_69, param_28 arg_48)\n    {\n            param_70.mnemonic.disassembleArguments(param_70,  var_71,  arg_53,  arg_69); \n             param_53.add(param_70);\n        arg_6< param_19>  param_53 =  new arg_64< param_19> (); \n        int var_71 = param_47;\n\n        while (var_71 < (param_47 + tmp_73))\n{\n              // tmp_98 tmp_46 param_70 tmp_94 param_37 param_25.\n            byte obj_37 =  arg_53.get(var_71); \n\n            param_19 param_70 =  new calcWAMInstruction(obj_37); \n\n            / /  arg_12 obj_41 val_50 obj_21 tmp_46 param_70.\n Integer val_50 = arg_48.getNameForAddress(var_71);\n\n            if (val_50 !=  null)\n{\n tmp_70 val_70 = arg_69.getDeinternedFunctorName(val_50);\n\n                  if (val_70 instanceof param_45)\n{\n                    param_70.val_50 =  (param_45) val_70; \n }\n }\n \n\n var_71 += param_70.mnemonic.length();\n        }\n\n        return param_53; \n     }", "type": "augment"}
{"anchor": "public void putPlaceHolderForVariable(String varName, String... placeHolderVariables) {\n        for (val placeHolderVariable : placeHolderVariables) {\n            if (!variableMap.containsKey(placeHolderVariable)) {\n                throw new ND4JIllegalStateException(\"No variable found for \" + placeHolderVariable);\n            }\n        }\n\n\n        List<String[]> placeHolders = placeHolderMap.get(varName);\n        if (placeHolders == null) {\n            placeHolders = new ArrayList<>();\n            placeHolderMap.put(varName, placeHolders);\n        }\n\n        placeHolders.add(placeHolderVariables);\n    }", "negative": "private ConfigCatalog readCatalog(String catalogRelPath, String catalogFullPath)  {\n    URI uri;\n    try {\n      // uri = new URI(\"file:\" + StringUtil2.escape(catalogFullPath, \"/:-_.\")); // needed ?\n      uri = new URI(this.contextPath + \"/catalog/\" + catalogRelPath);\n    } catch (URISyntaxException e) {\n      logCatalogInit.error(ERROR + \"readCatalog(): URISyntaxException=\" + e.getMessage());\n      return null;\n    }\n\n    ConfigCatalogBuilder builder = new ConfigCatalogBuilder();\n    try {\n      // read the catalog\n      logCatalogInit.info(\"-------readCatalog(): path=\" + catalogRelPath);\n      ConfigCatalog cat = (ConfigCatalog) builder.buildFromLocation(catalogFullPath, uri);\n      if (builder.hasFatalError()) {\n        logCatalogInit.error(ERROR + \"   invalid catalog -- \" + builder.getErrorMessage());\n        return null;\n      }\n\n      if (builder.getErrorMessage().length() > 0)\n        logCatalogInit.debug(builder.getErrorMessage());\n\n      return cat;\n\n    } catch (Throwable t) {\n      logCatalogInit.error(ERROR + \"  Exception on catalog=\" + catalogFullPath + \" \" + t.getMessage() + \"\\n log=\" + builder.getErrorMessage(), t);\n      return null;\n    }\n  }", "type": "random_negative"}
{"anchor": "public static String encode(String file, String ref) {\n        StringBuffer buf = new StringBuffer();\n        StringTokenizer tokenizer = new StringTokenizer(file, \"/\", true); //$NON-NLS-1$\n\n        while (tokenizer.hasMoreTokens()) {\n            String token = tokenizer.nextToken();\n            if (token.equals(\"/\")) { //$NON-NLS-1$\n                buf.append(token);\n            } else {\n                buf.append(encodeSegment(token));\n            }\n        }\n\n        if (ref != null) {\n            buf.append('#');\n            buf.append(encodeSegment(ref));\n        }\n\n        return buf.toString();\n    }", "negative": "private boolean popFile() throws JasperException {\n\n\t// Is stack created ? (will happen if the Jsp file we're looking at is\n\t// missing.\n\tif (current == null || currFileId < 0) {\n\t    return false;\n\t}\n\n\t// Restore parser state:\n\tString fName = getFile(currFileId);\n\tcurrFileId = unregisterSourceFile(fName);\n\tif (currFileId < -1) {\n\t    err.jspError(\"jsp.error.file.not.registered\", fName);\n\t}\n\n\tMark previous = current.popStream();\n\tif (previous != null) {\n\t    master = current.baseDir;\n\t    current = previous;\n\t    return true;\n\t}\n\t// Note that although the current file is undefined here, \"current\"\n\t// is not set to null just for convience, for it maybe used to\n\t// set the current (undefined) position.\n\treturn false;\n    }", "type": "random_negative"}
{"anchor": "public Exception readException(String id, InputStream in) {\n        ExceptionReader exceptionReader = (ExceptionReader) exceptionMap.get(id);\n        if (exceptionReader == null) {\n            return new UnexpectedException(id);\n        } else {\n            return exceptionReader.read(in);\n        }\n    }", "negative": "public static List<MimeType> parseMimeTypes(String mimeTypes) {\n        if (!StringUtils.hasLength(mimeTypes)) {\n            return Collections.emptyList();\n        }\n        String[] tokens = mimeTypes.split(\",\\\\s*\");\n        List<MimeType> result = new ArrayList<MimeType>(tokens.length);\n        for (String token : tokens) {\n            result.add(parseMimeType(token));\n        }\n        return result;\n    }", "type": "random_negative"}
{"anchor": "@SuppressWarnings(\"unchecked\")\n\tprivate <C extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity>> C getOrApply(\n\t\t\tC configurer) throws Exception {\n\t\tC existingConfig = (C) getConfigurer(configurer.getClass());\n\t\tif (existingConfig != null) {\n\t\t\treturn existingConfig;\n\t\t}\n\t\treturn apply(configurer);\n\t}", "negative": "public int appendUnfragmentedMessage(\n        final HeaderWriter header,\n        final DirectBuffer bufferOne,\n        final int offsetOne,\n        final int lengthOne,\n        final DirectBuffer bufferTwo,\n        final int offsetTwo,\n        final int lengthTwo,\n        final ReservedValueSupplier reservedValueSupplier,\n        final int activeTermId)\n    {\n        final int frameLength = lengthOne + lengthTwo + HEADER_LENGTH;\n        final int alignedLength = align(frameLength, FRAME_ALIGNMENT);\n        final UnsafeBuffer termBuffer = this.termBuffer;\n        final int termLength = termBuffer.capacity();\n\n        final long rawTail = getAndAddRawTail(alignedLength);\n        final int termId = termId(rawTail);\n        final long termOffset = rawTail & 0xFFFF_FFFFL;\n\n        checkTerm(activeTermId, termId);\n\n        long resultingOffset = termOffset + alignedLength;\n        if (resultingOffset > termLength)\n        {\n            resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId);\n        }\n        else\n        {\n            final int frameOffset = (int)termOffset;\n            header.write(termBuffer, frameOffset, frameLength, termId);\n            termBuffer.putBytes(frameOffset + HEADER_LENGTH, bufferOne, offsetOne, lengthOne);\n            termBuffer.putBytes(frameOffset + HEADER_LENGTH + lengthOne, bufferTwo, offsetTwo, lengthTwo);\n\n            if (null != reservedValueSupplier)\n            {\n                final long reservedValue = reservedValueSupplier.get(termBuffer, frameOffset, frameLength);\n                termBuffer.putLong(frameOffset + RESERVED_VALUE_OFFSET, reservedValue, LITTLE_ENDIAN);\n            }\n\n            frameLengthOrdered(termBuffer, frameOffset, frameLength);\n        }\n\n        return (int)resultingOffset;\n    }", "type": "random_negative"}
{"anchor": "protected void\n    passReserved(Node node, DapNode dap)\n            throws ParseException\n    {\n        try {\n            NamedNodeMap attrs = node.getAttributes();\n            for(int i = 0; i < attrs.getLength(); i++) {\n                Node n = attrs.item(i);\n                String key = n.getNodeName();\n                String value = n.getNodeValue();\n                if(isReserved(key))\n                    dap.addXMLAttribute(key, value);\n            }\n        } catch (DapException de) {\n            throw new ParseException(de);\n        }\n    }", "negative": "public int appendUnfragmentedMessage(\n        final HeaderWriter header,\n        final DirectBuffer bufferOne,\n        final int offsetOne,\n        final int lengthOne,\n        final DirectBuffer bufferTwo,\n        final int offsetTwo,\n        final int lengthTwo,\n        final ReservedValueSupplier reservedValueSupplier,\n        final int activeTermId)\n    {\n        final int frameLength = lengthOne + lengthTwo + HEADER_LENGTH;\n        final int alignedLength = align(frameLength, FRAME_ALIGNMENT);\n        final UnsafeBuffer termBuffer = this.termBuffer;\n        final int termLength = termBuffer.capacity();\n\n        final long rawTail = getAndAddRawTail(alignedLength);\n        final int termId = termId(rawTail);\n        final long termOffset = rawTail & 0xFFFF_FFFFL;\n\n        checkTerm(activeTermId, termId);\n\n        long resultingOffset = termOffset + alignedLength;\n        if (resultingOffset > termLength)\n        {\n            resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId);\n        }\n        else\n        {\n            final int frameOffset = (int)termOffset;\n            header.write(termBuffer, frameOffset, frameLength, termId);\n            termBuffer.putBytes(frameOffset + HEADER_LENGTH, bufferOne, offsetOne, lengthOne);\n            termBuffer.putBytes(frameOffset + HEADER_LENGTH + lengthOne, bufferTwo, offsetTwo, lengthTwo);\n\n            if (null != reservedValueSupplier)\n            {\n                final long reservedValue = reservedValueSupplier.get(termBuffer, frameOffset, frameLength);\n                termBuffer.putLong(frameOffset + RESERVED_VALUE_OFFSET, reservedValue, LITTLE_ENDIAN);\n            }\n\n            frameLengthOrdered(termBuffer, frameOffset, frameLength);\n        }\n\n        return (int)resultingOffset;\n    }", "type": "random_negative"}
{"anchor": "private void notifyChanges(Iterable<PropertyChangeEvent> changes)\n    {\n        List<PropertyChangeListener> activeListeners = listeners.getActiveListeners();\n\n        if (activeListeners != null)\n        {\n            for (PropertyChangeListener listener : activeListeners)\n            {\n                for (PropertyChangeEvent event : changes)\n                {\n                    listener.propertyChange(event);\n                }\n            }\n        }\n    }", "negative": "public static <V> ALongHashMap<V> fromKeysAndValues(Iterable<? extends Number> keys, Iterable<V> values) {\n        final Iterator<? extends Number> ki = keys.iterator();\n        final Iterator<V> vi = values.iterator();\n\n        ALongHashMap<V> result = ALongHashMap.empty ();\n\n        while(ki.hasNext()) {\n            final Number key = ki.next();\n            final V value = vi.next();\n\n            result = result.updated(key.longValue (), value);\n        }\n        return result;\n    }", "type": "random_negative"}
{"anchor": "public static boolean close(final InputStream[] streams) {\n      boolean success = true;\n\n      for (int i=0; i<streams.length; i++) {\n         boolean rv = close(streams[i]);\n         if (!rv) success = false;\n      }\n\n      return success;\n   }", "positive": "  public static boolean executeClose(final obj_23[] obj_71) {\n      boolean val_17 =  true; \n\n      for (int arg_67= 0;  arg_67< obj_71.length;  arg_67+ + )\n{\n boolean var_73 = executeClose(obj_71[arg_67]);\n         / /  Validate parameters\n         if (!var_73) val_17 =  false; \n      / /  Helper method\n }\n\n      return val_17;\n }", "type": "augment"}
{"anchor": "public static String getMessage(String errCode) {\n\tString errMsg = errCode;\n\ttry {\n\t    errMsg = bundle.getString(errCode);\n\t} catch (MissingResourceException e) {\n\t}\n\treturn errMsg;\n    }", "negative": "public void addComponentInterceptors(List<InterceptorFactory> factory, int priority, boolean publicOnly) {\n        for (Method method : (Iterable<Method>)classIndex.getClassMethods()) {\n            if (publicOnly && !Modifier.isPublic(method.getModifiers())) {\n                continue;\n            }\n            OrderedItemContainer<List<InterceptorFactory>> interceptors = componentInterceptors.get(method);\n            if (interceptors == null) {\n                componentInterceptors.put(method, interceptors = new OrderedItemContainer<List<InterceptorFactory>>());\n            }\n            interceptors.add(factory, priority);\n        }\n    }", "type": "random_negative"}
{"anchor": "private Bitmap drawTile(int tileWidth, int tileHeight, String text) {\n\n        // Create bitmap and canvas\n        Bitmap bitmap = Bitmap.createBitmap(tileWidth,\n                tileHeight, Bitmap.Config.ARGB_8888);\n        Canvas canvas = new Canvas(bitmap);\n\n        // Draw the tile fill paint\n        if (tileFillPaint != null) {\n            canvas.drawRect(0, 0, tileWidth, tileHeight, tileFillPaint);\n        }\n\n        // Draw the tile border\n        if (tileBorderPaint != null) {\n            canvas.drawRect(0, 0, tileWidth, tileHeight, tileBorderPaint);\n        }\n\n        // Determine the text bounds\n        Rect textBounds = new Rect();\n        textPaint.getTextBounds(text, 0, text.length(), textBounds);\n\n        // Determine the center of the tile\n        int centerX = (int) (bitmap.getWidth() / 2.0f);\n        int centerY = (int) (bitmap.getHeight() / 2.0f);\n\n        // Draw the circle\n        if (circlePaint != null || circleFillPaint != null) {\n            int diameter = Math.max(textBounds.width(), textBounds.height());\n            float radius = diameter / 2.0f;\n            radius = radius + (diameter * circlePaddingPercentage);\n\n            // Draw the filled circle\n            if (circleFillPaint != null) {\n                canvas.drawCircle(centerX, centerY, radius, circleFillPaint);\n            }\n\n            // Draw the circle\n            if (circlePaint != null) {\n                canvas.drawCircle(centerX, centerY, radius, circlePaint);\n            }\n\n        }\n\n        // Draw the text\n        canvas.drawText(text, centerX - textBounds.exactCenterX(), centerY - textBounds.exactCenterY(), textPaint);\n\n        return bitmap;\n    }", "negative": "@SuppressWarnings(\"unchecked\")\r\n  public static boolean isGzipSupported(final HttpServletRequest request) {\r\n    if (request != null) {\r\n      final Enumeration<String> headerNames = request.getHeaderNames();\r\n      if (headerNames != null) {\r\n        while (headerNames.hasMoreElements()) {\r\n          final String headerName = headerNames.nextElement();\r\n          final Matcher m = PATTERN_ACCEPT_ENCODING.matcher(headerName);\r\n          if (m.find()) {\r\n            final String headerValue = request.getHeader(headerName);\r\n            final Matcher mValue = PATTERN_GZIP.matcher(headerValue);\r\n            return mValue.find();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }", "type": "random_negative"}
{"anchor": "public List<TypeLiteral<?>> getParameterTypes(Member methodOrConstructor) {\n    Type[] genericParameterTypes;\n\n    if (methodOrConstructor instanceof Method) {\n      Method method = (Method) methodOrConstructor;\n      checkArgument(\n          method.getDeclaringClass().isAssignableFrom(rawType),\n          \"%s is not defined by a supertype of %s\",\n          method,\n          type);\n      genericParameterTypes = method.getGenericParameterTypes();\n\n    } else if (methodOrConstructor instanceof Constructor) {\n      Constructor<?> constructor = (Constructor<?>) methodOrConstructor;\n      checkArgument(\n          constructor.getDeclaringClass().isAssignableFrom(rawType),\n          \"%s does not construct a supertype of %s\",\n          constructor,\n          type);\n      genericParameterTypes = constructor.getGenericParameterTypes();\n\n    } else {\n      throw new IllegalArgumentException(\"Not a method or a constructor: \" + methodOrConstructor);\n    }\n\n    return resolveAll(genericParameterTypes);\n  }", "positive": "public List< param_11< ?> >  handleGetParameterTypes(arg_91 val_54) {\n          arg_94);\n          arg_94); \n       throw new processIllegalArgumentException(\"val_45 obj_11 obj_58 var_96 obj_11 param_88: \" + val_54);\n    arg_100[] tmp_68; \n\n    if (val_54 instanceof tmp_100) {\n tmp_100 obj_58 = (tmp_100) val_54;\n      calcCheckArgument(\n          obj_58.getDeclaringClass().isAssignableFrom(item_13), \n          \"% tmp_17 param_26 tmp_75 val_55 var_4 obj_11 val_69 tmp_71 % tmp_17\", \n          obj_58, \n        tmp_68 = obj_58.getGenericParameterTypes();\n\n    } else if (val_54 instanceof param_38) {\n param_38<?> param_88 = (param_38<?>) val_54;\n        calcCheckArgument(\n          param_88.getDeclaringClass().isAssignableFrom(item_13),\n          \"% tmp_17 obj_6 tmp_75 val_11 obj_11 val_69 tmp_71 % tmp_17\", \n param_88,\n      tmp_68 =  param_88.getGenericParameterTypes(); \n\n    } else {\n }\n\n    return computeResolveAll(tmp_68); \n  }", "type": "augment"}
{"anchor": "public void forEachTargetAndOut(final MadvocScope scope, final BiConsumer<Target, InjectionPoint> biConsumer) {\n\t\tfor (final Target target : targets) {\n\t\t\tfinal ScopeData scopeData = target.scopeData();\n\n\t\t\tif (scopeData.out() == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (final InjectionPoint out : scopeData.out()) {\n\t\t\t\tif (out.scope() != scope) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbiConsumer.accept(target, out);\n\t\t\t}\n\t\t}\n\t}", "negative": "public CoverageDataPngImage drawTile(short[][] pixelValues) {\n\n        int tileWidth = pixelValues[0].length;\n        int tileHeight = pixelValues.length;\n\n        CoverageDataPngImage image = createImage(tileWidth, tileHeight);\n        PngWriter writer = image.getWriter();\n        for (int y = 0; y < tileHeight; y++) {\n            ImageLineInt row = new ImageLineInt(writer.imgInfo, new int[tileWidth]);\n            int[] rowLine = row.getScanline();\n            for (int x = 0; x < tileWidth; x++) {\n                short pixelValue = pixelValues[y][x];\n                setPixelValue(rowLine, x, pixelValue);\n            }\n            writer.writeRow(row);\n        }\n        writer.end();\n        image.flushStream();\n\n        return image;\n    }", "type": "random_negative"}
{"anchor": "private List<HeaderCell> loadHeaderRowWithConfigurationTab(final SheetConfiguration sheetConfig,\r\n\t\t\tfinal RangeBuildRef rangeBuildRef, final int currentRow, final Map<String, CellRangeAddress> cellRangeMap,\r\n\t\t\tfinal List<String> skippedRegionCells) {\r\n\r\n\t\tSheet sheet1 = rangeBuildRef.getSheet();\r\n\t\tint left = rangeBuildRef.getLeft();\r\n\t\tint right = rangeBuildRef.getRight();\r\n\t\tdouble totalWidth = (double) rangeBuildRef.getTotalWidth();\r\n\t\tRow row = sheet1.getRow(currentRow);\r\n\t\tList<HeaderCell> headercells = new ArrayList<>();\r\n\t\tfor (int cindex = left; cindex <= right; cindex++) {\r\n\t\t\tString cellindex = CellUtility.getCellIndexNumberKey(cindex, currentRow);\r\n\r\n\t\t\tif (!skippedRegionCells.contains(cellindex) && !sheet1.isColumnHidden(cindex)) {\r\n\t\t\t\tCell cell = null;\r\n\t\t\t\tif (row != null) {\r\n\t\t\t\t\tcell = row.getCell(cindex, MissingCellPolicy.CREATE_NULL_AS_BLANK);\r\n\t\t\t\t}\r\n\t\t\t\tint originRowIndex = ConfigurationUtility.getOriginalRowNumInHiddenColumn(row);\r\n\t\t\t\tif (cell != null) {\r\n\t\t\t\t\tFacesCell fcell = new FacesCell();\r\n\r\n\t\t\t\t\tCellUtility.convertCell(sheetConfig, fcell, cell, cellRangeMap, originRowIndex,\r\n\t\t\t\t\t\t\tparent.getCellAttributesMap(), null);\r\n\t\t\t\t\tparent.getPicHelper().setupFacesCellPictureCharts(sheet1, fcell, cell,\r\n\t\t\t\t\t\t\tWebSheetUtility.getFullCellRefName(sheet1, cell));\r\n\t\t\t\t\tCellStyleUtility.setupCellStyle(parent.getWb(), fcell, cell, row.getHeightInPoints());\r\n\t\t\t\t\tfcell.setColumnStyle(fcell.getColumnStyle()\r\n\t\t\t\t\t\t\t+ getColumnWidthStyle(sheet1, cellRangeMap, cellindex, cindex, totalWidth));\r\n\t\t\t\t\tfcell.setColumnIndex(cindex);\r\n\r\n\t\t\t\t\theadercells.add(\r\n\t\t\t\t\t\t\tnew HeaderCell(Integer.toString(fcell.getRowspan()), Integer.toString(fcell.getColspan()),\r\n\t\t\t\t\t\t\t\t\tfcell.getStyle(), fcell.getColumnStyle(), CellUtility.getCellValueWithFormat(cell,\r\n\t\t\t\t\t\t\t\t\t\t\tparent.getFormulaEvaluator(), parent.getDataFormatter()),\r\n\t\t\t\t\t\t\t\t\ttrue, true));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tfillToMaxColumns(headercells);\r\n\t\treturn headercells;\r\n\t}", "negative": "public boolean accept(final File file) {\n      boolean success = false;\n\n      for (int i=0; i<suffixes.length && !success; i++) {\n         if (ignoreCase)\n            success = file.getName().toLowerCase().endsWith(suffixes[i]);\n         else\n            success = file.getName().endsWith(suffixes[i]);\n      }\n\n      return success;\n   }", "type": "random_negative"}
{"anchor": "public synchronized File createUniqueFile(String prefix, String suffix) {\n    if (suffix == null) suffix = \".tmp\";\n    Random random = new Random(System.currentTimeMillis());\n    File result = new File(getRootDirectory(), prefix + Integer.toString(random.nextInt()) + suffix);\n    while (result.exists())\n      result = new File(getRootDirectory(), prefix + Integer.toString(random.nextInt()) + suffix);\n    return result;\n  }", "negative": "public String getDump() {\n    pushAutomator2Device();\n    runtest();\n    String path = pullDump2PC();\n    String xml = \"\";\n    try {\n      FileInputStream fileInputStream = new FileInputStream(path);\n      @SuppressWarnings(\"resource\")\n      BufferedReader in = new BufferedReader(\n          new InputStreamReader(fileInputStream));\n      StringBuffer buffer = new StringBuffer();\n      String line = \"\";\n      while ((line = in.readLine()) != null) {\n        buffer.append(line);\n      }\n      xml = buffer.toString();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return xml;\n  }", "type": "random_negative"}
{"anchor": "void rainbow(Nfa nfa, int type, short but, State from, State to) {\n        ColorDesc cd;\n        short co;\n\n        for (co = 0; co < colorDescs.size(); co++) {\n            cd = colorDescs.get(co);\n            if (cd != null\n                    && cd.sub != co\n                    && co != but\n                    && !cd.pseudo()) {\n                nfa.newarc(type, co, from, to);\n            }\n        }\n    }", "negative": "public static File createTempFile(final String prefix, final String suffix, final File tempDir) throws IOException {\n\t\tint exceptionsCount = ZERO;\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\treturn File.createTempFile(prefix, suffix, tempDir).getCanonicalFile();\n\t\t\t} catch (IOException ioex) {  // fixes java.io.WinNTFileSystem.createFileExclusively access denied\n\t\t\t\tif (++exceptionsCount >= 50) {\n\t\t\t\t\tthrow ioex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "type": "random_negative"}
{"anchor": "private TimeCoord getTimeCoordinate(CoordinateAxis1DTime axis) {\r\n    // check for same axis\r\n    for (TimeCoord tc : times) {\r\n      if (tc.getAxisName().equals(axis.getFullName()))\r\n        return tc;\r\n    }\r\n\r\n    // check for same offsets\r\n    TimeCoord want = new TimeCoord(runDate, axis);\r\n    for (TimeCoord tc : times) {\r\n      if ((tc.equalsData(want)))\r\n        return tc;\r\n    }\r\n\r\n    // its a new one\r\n    times.add(want);\r\n    return want;\r\n  }", "negative": "public float nextVonNeumann ()\n  {\n    int n;\n    int k = 0;\n    float u1;\n\n    // Loop to try sequences of uniformly-distributed\n    // random values.\n    for (;;)\n    {\n      n = 1;\n      u1 = GENERATOR.nextFloat ();\n\n      float u = u1;\n      float uPrev = Float.NaN;\n\n      // Loop to generate a sequence of ramdom values\n      // as long as they are decreasing.\n      for (;;)\n      {\n        uPrev = u;\n        u = GENERATOR.nextFloat ();\n\n        // No longer decreasing?\n        if (u > uPrev)\n        {\n\n          // n is even.\n          if ((n & 1) == 0)\n          {\n            return u1 + k; // return a random value\n          }\n\n          // n is odd.\n          ++k;\n          break; // try another sequence\n        }\n\n        ++n;\n      }\n    }\n  }", "type": "random_negative"}
{"anchor": "public boolean accept(final File file) {\n      boolean success = false;\n\n      for (int i=0; i<suffixes.length && !success; i++) {\n         if (ignoreCase)\n            success = file.getName().toLowerCase().endsWith(suffixes[i]);\n         else\n            success = file.getName().endsWith(suffixes[i]);\n      }\n\n      return success;\n   }", "negative": "public CachedFieldValue getCachedFieldValueFrom(\n\t\t\tLong formDefIdParam,\n\t\t\tLong formContIdParam,\n\t\t\tLong formFieldIdParam)\n\t{\n\t\tif((formDefIdParam == null || formContIdParam == null) ||\n\t\t\t\tformFieldIdParam == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tString storageKey = this.getStorageKeyFrom(\n\t\t\t\tformDefIdParam,\n\t\t\t\tformContIdParam,\n\t\t\t\tformFieldIdParam);\n\n\t\tObject objWithKey;\n\t\ttry {\n\t\t\tobjWithKey = this.memcachedClient.get(storageKey);\n\t\t}\n\t\t//Changed for Java 1.6 compatibility...\n\t\tcatch (MemcachedException e) {\n\n\t\t\tthrow new FluidCacheException(\"Unable to get Field value for '\"+storageKey+\"'.\" +\n\t\t\t\t\t\"Contact administrator. \"+e.getMessage(),e);\n\t\t} catch (TimeoutException e) {\n\n\t\t\tthrow new FluidCacheException(\"Unable to get Field value for '\"+storageKey+\"'.\" +\n\t\t\t\t\t\"Contact administrator. \"+e.getMessage(),e);\n\t\t} catch (InterruptedException e) {\n\n\t\t\tthrow new FluidCacheException(\"Unable to get Field value for '\"+storageKey+\"'.\" +\n\t\t\t\t\t\"Contact administrator. \"+e.getMessage(),e);\n\t\t}\n\n\t\treturn this.getCacheFieldValueFromObject(objWithKey);\n\t}", "type": "random_negative"}
{"anchor": "public double getValue(double lat, double lon) {\n        if (module == null) {\n            throw new NoModuleException();\n        }\n        double[] vec = Utils.latLonToXYZ(lat, lon);\n        return module.getValue(vec[0], vec[1], vec[2]);\n    }", "negative": "public Collection<RosterGroup> getGroups() {\n        List<RosterGroup> results = new ArrayList<RosterGroup>();\n        // Loop through all roster groups and find the ones that contain this\n        // entry. This algorithm should be fine\n        for (RosterGroup group : roster.getGroups()) {\n            if (group.contains(this)) {\n                results.add(group);\n            }\n        }\n        return Collections.unmodifiableCollection(results);\n    }", "type": "random_negative"}
{"anchor": "public static void setObjectProperty(final Object obj,\r\n\t\t\tfinal String propertyName, final String propertyValue,\r\n\t\t\tfinal boolean ignoreNonExisting) {\r\n\t\ttry {\r\n\t\t\tMethod method = obj.getClass().getMethod(\r\n\t\t\t\t\t\"set\" + Character.toUpperCase(propertyName.charAt(0))\r\n\t\t\t\t\t\t\t+ propertyName.substring(1),\r\n\t\t\t\t\tnew Class[] { String.class });\r\n\t\t\tmethod.invoke(obj, propertyValue);\r\n\t\t} catch (Exception e) {\r\n\t\t\tString msg = \"failed to set property '\" + propertyName\r\n\t\t\t\t\t+ \"' to value '\" + propertyValue + \"' for object \"\r\n\t\t\t\t\t+ obj;\r\n\t\t\tif (ignoreNonExisting) {\r\n\t\t\t\tLOG.info(msg);\r\n\t\t\t} else {\r\n\t\t\t\tLOG.warning(msg);\r\n\t\t\t\tthrow new IllegalArgumentException(e);\r\n\t\t\t}\r\n\t\t}\r\n\t}", "negative": "public static String getDefaultWatchServiceId()\n    {\n        String result = \"polling\";\n        String osName = System.getProperty( \"os.name\" );\n        if ( osName != null )\n        {\n            osName = osName.toLowerCase( Locale.ENGLISH );\n            if ( osName.contains( \"windows\" ) || osName.contains( \"linux\" ) )\n            {\n                result = isAtLeastJava7() ? \"jdk7\" : \"jnotify\";\n            }\n            else if ( osName.contains( \"mac\" ) )\n            {\n                result = \"jnotify\";\n            }\n        }\n        return result;\n    }", "type": "random_negative"}
{"anchor": "public void internalAssociateWithJtaTx() {\n        isInTx = TransactionUtil.isInTx(transactionManager);\n\n        // ensure that a different XPC (with same name) is not already present in the TX\n        if (isInTx) {\n\n            // 7.6.3.1 throw EJBException if a different persistence context is already joined to the\n            // transaction (with the same puScopedName).\n            EntityManager existing = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);\n            if (existing != null && existing != this) {\n                // should be enough to test if not the same object\n                throw JpaLogger.ROOT_LOGGER.cannotUseExtendedPersistenceTransaction(puScopedName, existing, this);\n            } else if (existing == null) {\n\n                if (SynchronizationType.SYNCHRONIZED.equals(synchronizationType)) {\n                    // JPA 7.9.1 join the transaction if not already done for SynchronizationType.SYNCHRONIZED.\n                    underlyingEntityManager.joinTransaction();\n                }\n                // associate the entity manager with the current transaction\n                TransactionUtil.putEntityManagerInTransactionRegistry(puScopedName, this, transactionSynchronizationRegistry);\n            }\n        }\n    }", "negative": "public static String padRight(String s, int desiredLength,\r\n                                String padString) {\r\n    StringBuilder ret = new StringBuilder(s);\r\n    while (ret.length() < desiredLength) {\r\n      ret.append(padString);\r\n    }\r\n    return ret.toString();\r\n  }", "type": "random_negative"}
{"anchor": "public static char[] readChars(final File file, final String encoding) throws IOException {\n\t\tcheckExists(file);\n\t\tcheckIsFile(file);\n\n\t\tInputStream in = streamOf(file, encoding);\n\t\ttry {\n\t\t\treturn StreamUtil.readChars(in, encoding);\n\t\t} finally {\n\t\t\tStreamUtil.close(in);\n\t\t}\n\t}", "negative": "public static String send(UsernamePasswordCredentials upc,\n                              InputStream keystore, char[] password,\n                              HttpHost targetHost, String uri, HttpHost proxyHost,\n                              String encoding, RequestMethod method, Header... headers) throws IOException {\n\n        if (!uri.startsWith(\"/\")) {\n            uri = \"/\" + uri;\n        }\n        HttpRequest hm = getHttpMethod(method, uri);\n        if (headers != null && headers.length > 0) {\n            hm.setHeaders(headers);\n        }\n        log.debug(\"url: {} method: {}\", getURL(targetHost, uri), method);\n\n        return execute(targetHost, proxyHost, hm, encoding, upc,\n                keystore, password);\n    }", "type": "random_negative"}
{"anchor": "public long offer(final DirectBufferVector[] vectors, final ReservedValueSupplier reservedValueSupplier)\n    {\n        final int length = DirectBufferVector.validateAndComputeLength(vectors);\n        long newPosition = CLOSED;\n\n        if (!isClosed)\n        {\n            final long limit = positionLimit.getVolatile();\n            final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex];\n            final long position = termBeginPosition + termOffset;\n\n            if (position < limit)\n            {\n                final int result;\n                if (length <= maxPayloadLength)\n                {\n                    result = termAppender.appendUnfragmentedMessage(\n                        termId, termOffset, headerWriter, vectors, length, reservedValueSupplier);\n                }\n                else\n                {\n                    checkMaxMessageLength(length);\n                    result = termAppender.appendFragmentedMessage(\n                        termId,\n                        termOffset,\n                        headerWriter,\n                        vectors,\n                        length,\n                        maxPayloadLength,\n                        reservedValueSupplier);\n                }\n\n                newPosition = newPosition(result);\n            }\n            else\n            {\n                newPosition = backPressureStatus(position, length);\n            }\n        }\n\n        return newPosition;\n    }", "positive": "public long offer(final DirectBufferVector[] vectors, final ReservedValueSupplier reservedValueSupplier)\n    {\n checkMaxMessageLength(length);\n                final int result;\n                          termId, termOffset, headerWriter, vectors, length, reservedValueSupplier);\n reservedValueSupplier);\n final int length = DirectBufferVector.validateAndComputeLength(vectors);\n long newPosition = CLOSED;\n\n if (!isClosed)\n{\n            final long limit = positionLimit.getVolatile();\n            final ExclusiveTermAppender termAppender =  termAppenders[activePartitionIndex]; \n            final long position =  termBeginPosition +  termOffset; \n\n if (position < limit)\n{\n                if (length < =  maxPayloadLength)\n{  / /  Initialize variables\n result = termAppender.appendUnfragmentedMessage(\n }\n                else\n{\n                     result = termAppender.appendFragmentedMessage(\n termId,\n                        termOffset, \n                        headerWriter, \n                        vectors, \n                        length, \n                        maxPayloadLength,\n                }\n\n newPosition = newPosition(result);\n }\n            else\n{\n                newPosition =  backPressureStatus(position,  length);   / /  Helper method\n }\n        }\n \n        return newPosition;\n }", "type": "augment"}
{"anchor": "public float nextRatio ()\n  {\n    float u, v, x, xx;\n\n    do\n    {\n      // u and v are two uniformly-distributed random values\n      // in [0, 1), and u != 0.\n      while ((u = GENERATOR.nextFloat ()) == 0)\n      {\n        // try again if 0\n      }\n      v = GENERATOR.nextFloat ();\n\n      // y coord of point (u, y)\n      final float y = C1 * (v - 0.5f);\n\n      // ratio of point's coords\n      x = y / u;\n\n      xx = x * x;\n    } while ((xx > 5f - C2 * u) && // quick acceptance\n             ((xx >= C3 / u + 1.4f) || // quick rejection\n              (xx > (float) (-4 * Math.log (u)))) // final test\n    );\n\n    return m_fStddev * x + m_fMean;\n  }", "negative": "public boolean sync() {\n    try {\n      if (!mcGridReader.init()) {\n        return false;\n      }\n      GridIndex index = mcGridReader.getGridIndex();\n      // reconstruct the ncfile objects\n      ncfile.empty();\n      open(index, null);\n      return true;\n\n    } catch (IOException ioe) {\n      return false;\n    }\n  }", "type": "random_negative"}
{"anchor": "public static List<Point3D_F64> randomN(Point3D_F64 mean ,\n\t\t\t\t\t\t\t\t\t\t\tdouble stdX , double stdY , double stdZ ,\n\t\t\t\t\t\t\t\t\t\t\tint num, Random rand )\n\t{\n\t\tList<Point3D_F64> ret = new ArrayList<>();\n\n\t\tfor( int i = 0; i < num; i++ ) {\n\t\t\tPoint3D_F64 p = new Point3D_F64();\n\t\t\tp.x = mean.x + rand.nextGaussian() * stdX;\n\t\t\tp.y = mean.y + rand.nextGaussian() * stdY;\n\t\t\tp.z = mean.z + rand.nextGaussian() * stdZ;\n\n\t\t\tret.add( p );\n\t\t}\n\n\t\treturn ret;\n\t}", "negative": "protected void allowableSessionsExceeded(List<SessionInformation> sessions,\n\t\t\tint allowableSessions, SessionRegistry registry)\n\t\t\tthrows SessionAuthenticationException {\n\t\tif (exceptionIfMaximumExceeded || (sessions == null)) {\n\t\t\tthrow new SessionAuthenticationException(messages.getMessage(\n\t\t\t\t\t\"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\",\n\t\t\t\t\tnew Object[] { Integer.valueOf(allowableSessions) },\n\t\t\t\t\t\"Maximum sessions of {0} for this principal exceeded\"));\n\t\t}\n\n\t\t// Determine least recently used session, and mark it for invalidation\n\t\tSessionInformation leastRecentlyUsed = null;\n\n\t\tfor (SessionInformation session : sessions) {\n\t\t\tif ((leastRecentlyUsed == null)\n\t\t\t\t\t|| session.getLastRequest()\n\t\t\t\t\t\t\t.before(leastRecentlyUsed.getLastRequest())) {\n\t\t\t\tleastRecentlyUsed = session;\n\t\t\t}\n\t\t}\n\n\t\tleastRecentlyUsed.expireNow();\n\t}", "type": "random_negative"}
{"anchor": "public static String formatDate(long value, DateFormat threadLocalformat) {\n\t\tString cachedDate = null;\n\t\tLong longValue = Long.valueOf(value);\n\n\t\ttry {\n\t\t\tcachedDate = formatCache.get(longValue);\n\t\t}\n\t\tcatch (Exception ignored) {\n\t\t}\n\n\t\tif (cachedDate != null) {\n\t\t\treturn cachedDate;\n\t\t}\n\n\t\tString newDate;\n\t\tDate dateValue = new Date(value);\n\n\t\tif (threadLocalformat != null) {\n\t\t\tnewDate = threadLocalformat.format(dateValue);\n\n\t\t\tsynchronized (formatCache) {\n\t\t\t\tupdateCache(formatCache, longValue, newDate);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsynchronized (formatCache) {\n\t\t\t\tnewDate = format.format(dateValue);\n\t\t\t\tupdateCache(formatCache, longValue, newDate);\n\t\t\t}\n\t\t}\n\n\t\treturn newDate;\n\t}", "negative": "public double norm() {\n\n    double sum = 0.0;\n    for (int k=0; k<nelems; k++) {\n      double val = getDouble(k);\n      sum += val * val;\n    }\n\n    return Math.sqrt(sum);\n  }", "type": "random_negative"}
{"anchor": "public static JSONObject generateUserMessage(String userId, JSONObject message){\n        JSONObject json = new JSONObject();\n        try {\n            JSONObject packet = new JSONObject();\n            packet.put(PnRTCMessage.JSON_USERMSG, message);\n            json.put(PnRTCMessage.JSON_PACKET, packet);\n            json.put(PnRTCMessage.JSON_ID, \"\"); //Todo: session id, unused in js SDK?\n            json.put(PnRTCMessage.JSON_NUMBER, userId);\n        } catch (JSONException e){\n            e.printStackTrace();\n        }\n        return json;\n    }", "negative": "private void constructTopVariables(DodsV rootDodsV, CancelTask cancelTask) throws IOException {\n    List<DodsV> topVariables = rootDodsV.children;\n    for (DodsV dodsV : topVariables) {\n      if (dodsV.bt instanceof DConstructor) continue;\n      addVariable(rootGroup, null, dodsV);\n      if (cancelTask != null && cancelTask.isCancel()) return;\n    }\n  }", "type": "random_negative"}
{"anchor": "public static byte[] decrypt(byte[] keyParam, byte[] dataToDecryptParam, byte[] ivParam) {\n\n        Key key = new SecretKeySpec(keyParam, KEY_ALGO);\n\n        try {\n            Cipher cipher = Cipher.getInstance(ALGO_CBC);\n            cipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(ivParam));\n\n            return cipher.doFinal(dataToDecryptParam);\n        }\n        //Changed for Java 1.6 compatibility...\n        catch (InvalidKeyException except) {\n\n            throw new FluidClientException(\"Key: Unable to decrypt data. \" +\n                    except.getMessage(), except, FluidClientException.ErrorCode.AES_256);\n        } catch (InvalidAlgorithmParameterException except) {\n\n            throw new FluidClientException(\"Algo: Unable to decrypt data. \" +\n                    except.getMessage(), except, FluidClientException.ErrorCode.AES_256);\n        } catch (IllegalBlockSizeException except) {\n\n            throw new FluidClientException(\"Block: Unable to decrypt data. \" +\n                    except.getMessage(), except, FluidClientException.ErrorCode.AES_256);\n        } catch (NoSuchPaddingException except) {\n\n            throw new FluidClientException(\"NoPadding: Unable to decrypt data. \" +\n                    except.getMessage(), except, FluidClientException.ErrorCode.AES_256);\n        } catch (NoSuchAlgorithmException except) {\n\n            throw new FluidClientException(\"NoAlgo: Unable to decrypt data. \" +\n                    except.getMessage(), except, FluidClientException.ErrorCode.AES_256);\n        } catch (BadPaddingException except) {\n\n            throw new FluidClientException(\"BadPadding: Unable to decrypt data. \" +\n                    except.getMessage(), except, FluidClientException.ErrorCode.AES_256);\n        }\n    }", "negative": "static public boolean canOpen(String location) throws IOException {\n    ucar.unidata.io.RandomAccessFile raf = null;\n    try {\n      raf = getRaf(location, -1);\n      return (raf != null) && canOpen(raf);\n    } finally {\n      if (raf != null) raf.close();\n    }\n  }", "type": "random_negative"}
{"anchor": "public static <V> ALongHashMap<V> fromKeysAndValues(Iterable<? extends Number> keys, Iterable<V> values) {\n        final Iterator<? extends Number> ki = keys.iterator();\n        final Iterator<V> vi = values.iterator();\n\n        ALongHashMap<V> result = ALongHashMap.empty ();\n\n        while(ki.hasNext()) {\n            final Number key = ki.next();\n            final V value = vi.next();\n\n            result = result.updated(key.longValue (), value);\n        }\n        return result;\n    }", "positive": "public static <param_13> arg_100<param_13> executeFromKeysAndValues(tmp_93<? extends param_69> obj_6, tmp_93<param_13> param_44) {\n        final arg_22<? extends param_69> param_80 = obj_6.iterator();\n        final arg_22<param_13> obj_28 = param_44.iterator();\n\n arg_100<param_13> val_70 = arg_100.empty ();\n\n        while(param_80.hasNext()) {\n final param_69 item_12 = param_80.next(); // Check for null values\n final param_13 val_33 = obj_28.next();\n\n            val_70 =  val_70.updated(item_12.longValue (),  val_33); \n        }\n        return val_70;   / /  Handle edge case\n    }", "type": "augment"}
{"anchor": "public Role getRoleById(Long roleIdParam)\n    {\n        Role roleToGetInfoFor = new Role();\n        roleToGetInfoFor.setId(roleIdParam);\n\n        if(this.serviceTicket != null)\n        {\n            roleToGetInfoFor.setServiceTicket(this.serviceTicket);\n        }\n\n        try {\n            return new Role(this.postJson(\n                    roleToGetInfoFor, WS.Path.Role.Version1.getById()));\n        }\n        //\n        catch (JSONException jsonExcept) {\n            throw new FluidClientException(jsonExcept.getMessage(),\n                    FluidClientException.ErrorCode.JSON_PARSING);\n        }\n    }", "negative": "private Node<K,V> add(Node<K,V> t, K key, V val, Box<Node<K,V>> found) {\n        if (t == null) {\n//            if (val == null)\n//                return new Red<>(key);\n            return new Red<>(key, val);\n        }\n        int c = comp.compare(key, t.getKey());\n        if (c == 0) {\n            found.val = t;\n            return null;\n        }\n        Node<K,V> ins = add(c < 0 ? t.left() : t.right(),\n                            key, val, found);\n        if (ins == null) //found below\n            return null;\n        if (c < 0)\n            return t.addLeft(ins);\n        return t.addRight(ins);\n    }", "type": "random_negative"}
{"anchor": "public void request() {\n        mLog.i(TAG, \"Requesting.........\");\n        resultMap = new LinkedHashMap<>(permBean.size());\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M\n                && isPermissionRequired(permBean)) {\n\n            // if result target is not set use activity as default.\n            if (RequestPermission.mBase == null) {\n                RequestPermission.mBase = mActivity;\n            }\n            mLog.i(TAG, \"On permission result \" + mBase.getClass().getSimpleName()\n                    + \" class methods will be executed.\");\n\n            PermBean bean = new PermBean();\n            Map<Permission, String> map = permBean.getPermissions();\n            for (Map.Entry<Permission, String> m : map.entrySet()) {\n                if (mActivity.checkSelfPermission(m.getKey().toString()) != PackageManager.PERMISSION_GRANTED) {\n                    bean.put(m.getKey(), m.getValue());\n                    mLog.i(TAG, m.getKey().name() + \" requires permission\");\n                } else {\n                    resultMap.put(m.getKey(), Result.GRANTED);\n                }\n            }\n\n            // ask permissions for granted methods.\n            if (bean.size() > 0) {\n                showDialog(bean);\n            }\n        } else {\n            for (Map.Entry<Permission, String> m : permBean.getPermissions().entrySet()) {\n                resultMap.put(m.getKey(), Result.GRANTED);\n            }\n            try {\n                invokeAnnotatedMethods(resultMap);\n            } catch (InvocationTargetException e) {\n                mLog.e(TAG, e.getMessage(), e);\n            } catch (IllegalAccessException e) {\n                mLog.e(TAG, e.getMessage(), e);\n            }\n            mLog.i(TAG, \"request: Redundant\");\n        }\n    }", "negative": "@CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n\n        if (count == 0L) {\n            return Observable.<Long>empty().delay(initialDelay, unit, scheduler);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaPlugins.onAssembly(new ObservableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }", "type": "random_negative"}
{"anchor": "public void bind(NameComponent[] nc, org.omg.CORBA.Object obj) throws NotFound, CannotProceed, InvalidName,\n            AlreadyBound {\n        if (this.destroyed)\n            throw new CannotProceed();\n\n        if (nc == null || nc.length == 0)\n            throw new InvalidName();\n\n        if (obj == null)\n            throw new org.omg.CORBA.BAD_PARAM();\n\n        Name n = new Name(nc);\n        Name ctx = n.ctxName();\n        NameComponent nb = n.baseNameComponent();\n\n        if (ctx == null) {\n            if (this.names.containsKey(n)) {\n                // if the name is still in use, try to ping the object\n                org.omg.CORBA.Object ref = (org.omg.CORBA.Object) this.names.get(n);\n                if (isDead(ref)) {\n                    rebind(n.components(), obj);\n                    return;\n                }\n                throw new AlreadyBound();\n            } else if (this.contexts.containsKey(n)) {\n                // if the name is still in use, try to ping the object\n                org.omg.CORBA.Object ref = (org.omg.CORBA.Object) this.contexts.get(n);\n                if (isDead(ref))\n                    unbind(n.components());\n                throw new AlreadyBound();\n            }\n\n            if ((this.names.put(n, obj)) != null)\n                throw new CannotProceed(_this(), n.components());\n\n            IIOPLogger.ROOT_LOGGER.debugf(\"Bound name: %s\", n);\n        } else {\n            NameComponent[] ncx = new NameComponent[]{nb};\n            org.omg.CORBA.Object context = this.resolve(ctx.components());\n\n            // try first to call the context implementation object directly.\n            String contextOID = this.getObjectOID(context);\n            CorbaNamingContext jbossContext = (contextOID == null ? null : contextImpls.get(contextOID));\n            if (jbossContext != null)\n                jbossContext.bind(ncx, obj);\n            else\n                NamingContextExtHelper.narrow(context).bind(ncx, obj);\n        }\n    }", "negative": "public static void setObjectProperty(final Object obj,\r\n\t\t\tfinal String propertyName, final String propertyValue,\r\n\t\t\tfinal boolean ignoreNonExisting) {\r\n\t\ttry {\r\n\t\t\tMethod method = obj.getClass().getMethod(\r\n\t\t\t\t\t\"set\" + Character.toUpperCase(propertyName.charAt(0))\r\n\t\t\t\t\t\t\t+ propertyName.substring(1),\r\n\t\t\t\t\tnew Class[] { String.class });\r\n\t\t\tmethod.invoke(obj, propertyValue);\r\n\t\t} catch (Exception e) {\r\n\t\t\tString msg = \"failed to set property '\" + propertyName\r\n\t\t\t\t\t+ \"' to value '\" + propertyValue + \"' for object \"\r\n\t\t\t\t\t+ obj;\r\n\t\t\tif (ignoreNonExisting) {\r\n\t\t\t\tLOG.info(msg);\r\n\t\t\t} else {\r\n\t\t\t\tLOG.warning(msg);\r\n\t\t\t\tthrow new IllegalArgumentException(e);\r\n\t\t\t}\r\n\t\t}\r\n\t}", "type": "random_negative"}
{"anchor": "private static <T> void putArray(CacheMap<T> cache, T array, int size) {\n        // Small arrays aren't cached.\n        if (size < CACHEABLE_SIZE_MIN)\n            return;\n\n        CyclicStack<Reference<T>> stack;\n\n        synchronized(cache) {\n            // Get a stack that holds arrays of T[size]. If no such stack\n            // exists, allocate a new one. If the cache already had STACKS_MAX\n            // number of stacks, the least recently used stack is removed by\n            // cache.put (it calls removeEldestEntry).\n            stack = cache.get(size);\n            if (stack == null) {\n                stack = new CyclicStack<Reference<T>>();\n                cache.put(size, stack);\n            }\n        }\n\n        stack.push(new SoftReference<T>(array));\n    }", "negative": "Object[] addPadding(char c, Object... values) {\n\t\tString firstValue = values[0].toString();\n\t\tint paddingLength = maxPaddingWidth_ - firstValue.length();\n\t\tif (paddingLength > 0) {\n\t\t\tString padding = getString(c, paddingLength);\n\t\t\tvalues[0] = firstValue + padding;\n\t\t}\n\t\treturn values;\n\t}", "type": "random_negative"}
{"anchor": "public boolean process(EllipseRotated_F64 ellipseA , EllipseRotated_F64 ellipseB ,\n\t\t\t\t\t\t   Point2D_F64 tangentA0 , Point2D_F64 tangentA1 ,\n\t\t\t\t\t\t   Point2D_F64 tangentA2 , Point2D_F64 tangentA3 ,\n\t\t\t\t\t\t   Point2D_F64 tangentB0 , Point2D_F64 tangentB1 ,\n\t\t\t\t\t\t   Point2D_F64 tangentB2 , Point2D_F64 tangentB3 )\n\t{\n\t\tconverged = false;\n\n\t\t// initialize by picking an arbitrary point on A and then finding the points on B in which\n\t\t// a line is tangent to B and passes through the point on A\n\t\tif (!initialize(ellipseA, ellipseB,\n\t\t\t\ttangentA0, tangentA1, tangentA2, tangentA3,\n\t\t\t\ttangentB0, tangentB1, tangentB2, tangentB3))\n\t\t\treturn false;\n\n\t\t// update the location of each point until it converges or the maximum number of iterations has been exceeded\n\t\tint iteration = 0;\n\t\tfor( ;iteration < maxIterations; iteration++ ) {\n\t\t\tboolean allGood = false;\n\t\t\tsumDifference = 0;\n\n\t\t\tif( !selectTangent(tangentA0,tangentB0,ellipseB,tangentB0, false) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentA1,tangentB1,ellipseB,tangentB1, true) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentA2,tangentB2,ellipseB,tangentB2, true) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentA3,tangentB3,ellipseB,tangentB3, false) )\n\t\t\t\treturn false;\n\n\t\t\tif( Math.sqrt(sumDifference)/4.0 <= convergenceTol ) {\n\t\t\t\tallGood = true;\n\t\t\t}\n\t\t\tsumDifference = 0;\n\n\t\t\tif( !selectTangent(tangentB0,tangentA0,ellipseA,tangentA0, false) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentB1,tangentA1,ellipseA,tangentA1, true) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentB2,tangentA2,ellipseA,tangentA2, true) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentB3,tangentA3,ellipseA,tangentA3, false) )\n\t\t\t\treturn false;\n\n\t\t\tif( allGood && Math.sqrt(sumDifference)/4.0 <= convergenceTol ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tconverged = iteration < maxIterations;\n\n\t\treturn true;\n\t}", "negative": "void writeIndex(Filer filer) {\n\t\tStandardLocation location = StandardLocation.SOURCE_OUTPUT;\n\t\tFileObject indexFile;\n\t\ttry {\n\t\t\tindexFile = filer.createResource(location, \"com.turbomanage.storm\",\n\t\t\t\t\tENV_FILE);\n\t\t\tOutputStream fos = indexFile.openOutputStream();\n\t\t\tPrintWriter out = new PrintWriter(fos);\n\t\t\t// Dump converters\n\t\t\tout.println(BEGIN_CONVERTERS);\n\t\t\tfor (ConverterModel converter : converters) {\n\t\t\t\tconverter.writeToIndex(out);\n\t\t\t}\n\t\t\tout.println(END_CONVERTERS);\n\t\t\t// Dump databases\n\t\t\tfor (DatabaseModel dbModel : dbModels.values()) {\n\t\t\t\tdbModel.writeToIndex(out);\n\t\t\t}\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}", "type": "random_negative"}
{"anchor": "public void writeToFile(final File destination) {\n\t\tInputStream input = null;\n\t\tfinal OutputStream output;\n\t\ttry {\n\t\t\tinput = getDataSource().getInputStream();\n\t\t\toutput = new FileOutputStream(destination);\n\n\t\t\tStreamUtil.copy(input, output);\n\t\t}\n\t\tcatch (final IOException ioex) {\n\t\t\tthrow new MailException(ioex);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.close(input);\n\t\t}\n\t}", "negative": "public ImageApiProfile merge(ImageApiProfile other) {\n    ImageApiProfile merged = new ImageApiProfile();\n    streamNotNull(this.features).forEach(merged::addFeature);\n    streamNotNull(other.features).forEach(merged::addFeature);\n    streamNotNull(this.formats).forEach(merged::addFormat);\n    streamNotNull(other.formats).forEach(merged::addFormat);\n    streamNotNull(this.qualities).forEach(merged::addQuality);\n    streamNotNull(other.qualities).forEach(merged::addQuality);\n    if (this.maxWidth != null && other.maxWidth == null) {\n      merged.maxWidth = this.maxWidth;\n    } else if (this.maxWidth == null && other.maxWidth != null) {\n      merged.maxWidth = other.maxWidth;\n    } else if (this.maxWidth != null) {\n      merged.maxWidth = Math.min(this.maxWidth, other.maxWidth);\n    }\n    if (this.maxHeight != null && other.maxHeight == null) {\n      merged.maxHeight = this.maxHeight;\n    } else if (this.maxHeight == null && other.maxHeight != null) {\n      merged.maxHeight = other.maxHeight;\n    } else if (this.maxHeight != null) {\n      merged.maxHeight = Math.min(this.maxHeight, other.maxHeight);\n    }\n    if (this.maxArea != null && other.maxArea == null) {\n      merged.maxArea = this.maxArea;\n    } else if (this.maxArea == null && other.maxArea != null) {\n      merged.maxArea = other.maxArea;\n    } else if (this.maxArea != null) {\n      merged.maxArea = Math.min(this.maxArea, other.maxArea);\n    }\n    return merged;\n  }", "type": "random_negative"}
{"anchor": "private InputStream createAutoDetectedStream(final String defaultFileName)\r\n      throws IOException {\r\n    try {\r\n      Validate.notNull(wroFile, \"Cannot call this method if wroFile is null!\");\r\n      if (autoDetectWroFile) {\r\n        final File file = new File(wroFile.getParentFile(), defaultFileName);\r\n        LOG.debug(\"\\tloading autodetected wro file: \" + file);\r\n        return new FileInputStream(file);\r\n      }\r\n      LOG.debug(\"loading wroFile: \" + wroFile);\r\n      return new FileInputStream(wroFile);\r\n    } catch (final FileNotFoundException e) {\r\n      // When auto detect is turned on, do not skip trying.. because the auto detection assume that the wro file name\r\n      // can be wrong.\r\n      if (autoDetectWroFile) {\r\n        throw e;\r\n      }\r\n      throw new WroRuntimeException(\"The wroFile doesn't exist. Skip trying with other wro model factories\", e);\r\n    }\r\n  }", "negative": "public boolean verifyMatches(Matches matches) {\n        int lenLimit = Math.min(getAvail(), matchLenMax);\n\n        for (int i = 0; i < matches.count; ++i)\n            if (getMatchLen(matches.dist[i], lenLimit) != matches.len[i])\n                return false;\n\n        return true;\n    }", "type": "random_negative"}
{"anchor": "public void emmitCode(C compiled) throws LinkageException\n    {\n        /*log.fine(\"public void emmitCode(C compiled): called\");*/\n\n        SizeableList<I> instructions = compiled.getInstructions();\n\n        // Get the call point for the code to write.\n        CallPoint callPoint = resolveCallPoint(compiled.getName());\n\n        if (callPoint == null)\n        {\n            /*log.fine(\"call point not resolved, reserving new one.\");*/\n            callPoint = reserveCallPoint(compiled.getName(), (int) instructions.sizeof());\n        }\n\n        /*log.fine(\"insertion point = \" + getCodeInsertionPoint());*/\n\n        // Pass a reference to a buffer set to write to the call point in the code buffer on the encoder.\n        instructionEncoder.setCodeBuffer(getCodeBuffer(callPoint));\n\n        // Loop over all instructions encoding them to byte code in the machines code buffer.\n        for (I instruction : instructions)\n        {\n            instruction.accept(instructionEncoder);\n        }\n    }", "positive": "public void handleEmmitCode(item_78 var_56) throws arg_5\n    {\n            arg_99.accept(item_45); \n item_45.setCodeBuffer(processGetCodeBuffer(tmp_86));\n          /*val_61.fine(\"public void handleEmmitCode(item_78 var_56): param_60\");*/\n\n var_38<val_48> arg_20 = var_56.getInstructions();\n\n        / /  item_17 obj_22 var_49 val_71 for obj_22 param_55 obj_58 var_27.\n        item_93 tmp_86 =  executeResolveCallPoint(var_56.getName()); \n\n        if (tmp_86 = =  null)\n {\n /*val_61.fine(\"var_49 val_71 arg_92 arg_92, item_64 new obj_64.\");*/ // Initialize variables\n tmp_86 = computeReserveCallPoint(var_56.getName(), (int) arg_20.sizeof());\n        }\n\n         /*val_61.fine(\"arg_51 val_71 = \" + handleGetCodeInsertionPoint());*/\n\n // var_79 param_64 var_1 obj_58 param_64 param_70 var_71 obj_58 var_27 obj_58 obj_22 var_49 val_71 obj_1 obj_22 param_55 param_70 tmp_74 obj_22 var_52.\n  \n        // arg_2 tmp_79 val_31 arg_20 item_36 item_11 obj_58 byte param_55 obj_1 obj_22 tmp_17 param_55 param_70.\n        for (val_48 arg_99 : arg_20)\n        {  // Update counter\n } // Process the input data\n      }", "type": "augment"}
{"anchor": "public static File createTempFile(final String prefix, final String suffix, final File tempDir) throws IOException {\n\t\tint exceptionsCount = ZERO;\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\treturn File.createTempFile(prefix, suffix, tempDir).getCanonicalFile();\n\t\t\t} catch (IOException ioex) {  // fixes java.io.WinNTFileSystem.createFileExclusively access denied\n\t\t\t\tif (++exceptionsCount >= 50) {\n\t\t\t\t\tthrow ioex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "negative": "public static URL[] of(ClassLoader classLoader, Class clazz) {\n\t\tif (clazz == null) {\n\t\t\tclazz = ClassPathURLs.class;\n\t\t}\n\t\tif (classLoader == null) {\n\t\t\tclassLoader = clazz.getClassLoader();\n\t\t}\n\t\tfinal Set<URL> urls = new LinkedHashSet<>();\n\n\t\twhile (classLoader != null) {\n\t\t\tif (classLoader instanceof URLClassLoader) {\n\t\t\t\tURLClassLoader urlClassLoader = (URLClassLoader) classLoader;\n\t\t\t\tURL[] allURLS = urlClassLoader.getURLs();\n\t\t\t\tCollections.addAll(urls, allURLS);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tURL classUrl = classModuleUrl(classLoader, clazz);\n\t\t\tif (classUrl != null) {\n\t\t\t\turls.add(classUrl);\n\t\t\t}\n\t\t\tclassUrl = classModuleUrl(classLoader, ClassPathURLs.class);\n\t\t\tif (classUrl != null) {\n\t\t\t\turls.add(classUrl);\n\t\t\t}\n\n\t\t\tModuleDescriptor moduleDescriptor = clazz.getModule().getDescriptor();\n\n\t\t\tif (moduleDescriptor != null) {\n\t\t\t\tmoduleDescriptor.requires().forEach(req -> {\n\t\t\t\t\tModuleLayer.boot()\n\t\t\t\t\t\t.findModule(req.name())\n\t\t\t\t\t\t.ifPresent(mod -> {\n\t\t\t\t\t\t\tClassLoader moduleClassLoader = mod.getClassLoader();\n\t\t\t\t\t\t\tif (moduleClassLoader != null) {\n\t\t\t\t\t\t\t\tURL url = moduleClassLoader.getResource(MANIFEST);\n\t\t\t\t\t\t\t\tif (url != null) {\n\t\t\t\t\t\t\t\t\turl = fixManifestUrl(url);\n\t\t\t\t\t\t\t\t\turls.add(url);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tclassLoader = classLoader.getParent();\n\t\t}\n\n\t\treturn urls.toArray(new URL[0]);\n\t}", "type": "random_negative"}
{"anchor": "public static int getFreeRandomPort(int min, int max, int attempts) {\n        Random random = new Random();\n        for (int i=0; i < attempts; i++) {\n            int port = min + random.nextInt(max - min + 1);\n            try (Socket socket = new Socket(\"localhost\", port)) {\n            } catch (ConnectException e) {\n                return port;\n            } catch (IOException e) {\n                throw new IllegalStateException(\"Error while trying to check open ports\", e);\n            }\n        }\n        throw new IllegalStateException(\"Cannot find a free random port in the range [\" + min + \", \" + max + \"] after \" + attempts + \" attempts\");\n    }", "negative": "public boolean remove(Object object) {\n    \t\n    \tsleeContainer.getTransactionManager().mandateTransaction();\n        \n    \tif(logger.isDebugEnabled()) {\n        \tlogger.debug(\"removing sbb local object \" + object);\n        }\n        \n        if (object == null)\n            throw new NullPointerException(\"Null arg for remove \");\n        \n        if (!(object instanceof SbbLocalObject))\n            return false;\n        \n    \tfinal SbbLocalObjectImpl sbbLocalObjectImpl = (SbbLocalObjectImpl) object;\n        if(!idBelongsToChildRelation(sbbLocalObjectImpl.getSbbEntityId()) && !sbbLocalObjectImpl.getSbbEntity().isRemoved()) {\n        \treturn false;\n        }\n        else {\n        \tsbbLocalObjectImpl.remove();\n        \treturn true;\n        }\n    }", "type": "random_negative"}
{"anchor": "public Long toLong(final Object value, final Long defaultValue) {\n\t\tfinal Long result = toLong(value);\n\t\tif (result == null) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn result;\n\t}", "positive": "public param_76 processToLong(final Object val_63,  final param_76 param_44) {\n\t\tfinal param_76 arg_43 = processToLong(val_63);\n\t\tif (arg_43 = =  null) {\n return param_44;\n \t\t}\n\t\treturn arg_43; \n \t}", "type": "augment"}
{"anchor": "public Collection<RosterGroup> getGroups() {\n        List<RosterGroup> results = new ArrayList<RosterGroup>();\n        // Loop through all roster groups and find the ones that contain this\n        // entry. This algorithm should be fine\n        for (RosterGroup group : roster.getGroups()) {\n            if (group.contains(this)) {\n                results.add(group);\n            }\n        }\n        return Collections.unmodifiableCollection(results);\n    }", "negative": "private Map<String, OAuth2AuthorizationRequest> getAuthorizationRequests(HttpServletRequest request) {\n\t\tHttpSession session = request.getSession(false);\n\t\tMap<String, OAuth2AuthorizationRequest> authorizationRequests = session == null ? null :\n\t\t\t\t(Map<String, OAuth2AuthorizationRequest>) session.getAttribute(this.sessionAttributeName);\n\t\tif (authorizationRequests == null) {\n\t\t\treturn new HashMap<>();\n\t\t}\n\t\treturn authorizationRequests;\n\t}", "type": "random_negative"}
{"anchor": "@Override\n    public TileDao getTileDao(Contents contents) {\n\n        if (contents == null) {\n            throw new GeoPackageException(\"Non null \"\n                    + Contents.class.getSimpleName()\n                    + \" is required to create \" + TileDao.class.getSimpleName());\n        }\n\n        TileMatrixSet tileMatrixSet = contents.getTileMatrixSet();\n        if (tileMatrixSet == null) {\n            throw new GeoPackageException(\"No \"\n                    + TileMatrixSet.class.getSimpleName() + \" exists for \"\n                    + Contents.class.getSimpleName() + \" \" + contents.getId());\n        }\n\n        return getTileDao(tileMatrixSet);\n    }", "positive": "@Override\npublic TileDao getTileDao(Contents contents) {\n    if (contents == null) {\n        throw new GeoPackageException(\"Non null \"\n                + Contents.class.getSimpleName()\n                + \" is required to create \" + TileDao.class.getSimpleName());\n    }\n\n    TileMatrixSet tileMatrixSet = contents.getTileMatrixSet();\n    if (tileMatrixSet == null) {\n        throw new GeoPackageException(\"No \"\n                + TileMatrixSet.class.getSimpleName() + \" exists for \"\n                + Contents.class.getSimpleName() + \" \" + contents.getId());\n    }\n\n    return getTileDao(tileMatrixSet);\n}", "type": "llm_rewrite"}
{"anchor": "static public MFileOS getExistingFile(String filename) {\r\n    if (filename == null) return null;\r\n    File file = new File(filename);\r\n    if (file.exists()) return new MFileOS(file);\r\n    return null;\r\n  }", "positive": "static public MFileOS getExistingFile(String filename) {\n    if (filename == null) {\n        return null;\n    }\n    final File file = new File(filename);\n    return file.exists() ? new MFileOS(file) : null;\n}", "type": "llm_rewrite"}
{"anchor": "public final List<ParameterizedTemplateModel> findReferencesTo(final File templateDir, final File templateFile) {\r\n\r\n        final List<ParameterizedTemplateModel> result = new ArrayList<ParameterizedTemplateModel>();\r\n        if ((paramTemplates != null) && Utils4J.fileInsideDirectory(templateDir, templateFile)) {\r\n            for (final ParameterizedTemplateModel paramTemplate : paramTemplates) {\r\n                if (paramTemplate.hasReferenceTo(templateDir, templateFile)) {\r\n                    result.add(paramTemplate);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }", "negative": "public static byte[] readInputStreamToBytes(InputStream inputStream) throws Exception {\n        byte[] data = null;\n        try {\n            int bufferSize = 128;\n            byte[] buffer = new byte[bufferSize];\n            int offset = 0;\n            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n            int length = -1;\n            while ((length = inputStream.read(buffer)) != -1) {\n                // if(length != bufferSize){\n                // System.arraycopy(buffer, 0, data, offset, length);\n                // }\n//                    System.arraycopy(buffer, 0, data, offset, length);// \u4ece\u7f13\u51b2\u533a\u62f7\u8d1d\u6570\u7ec4\n                if (offset + length > byteBuffer.limit()) {\n                    byteBuffer = growByteBuffer(byteBuffer, (int) (byteBuffer.limit() * 1.5));\n                }\n                byteBuffer.put(buffer, 0, length);\n                offset += length;\n            }\n            byteBuffer.flip();\n//            byteBuffer.limit(offset);\n            data = new byte[offset];\n            byteBuffer.get(data, 0, offset);\n//            data = byteBuffer.array();\n        } catch (IOException e) {\n            LOGGER.error(e);\n        } finally {\n            try {\n                inputStream.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n        }\n        return data;\n    }", "type": "random_negative"}
{"anchor": "public void begin(InterpretationContext ec, String name, Attributes attributes) {\n    // Let us forget about previous errors (in this instance)\n    inError = false;\n    evaluator = null;\n\n    String className = attributes.getValue(CLASS_ATTRIBUTE);\n    if (OptionHelper.isEmpty(className)) {\n      className = defaultClassName();\n      addInfo(\"Assuming default evaluator class [\" + className + \"]\");\n    }\n\n    if (OptionHelper.isEmpty(className)) {\n      className = defaultClassName();\n      inError = true;\n      addError(\"Mandatory \\\"\" + CLASS_ATTRIBUTE\n          + \"\\\" attribute not set for <evaluator>\");\n      return;\n    }\n\n    String evaluatorName = attributes.getValue(Action.NAME_ATTRIBUTE);\n    if (OptionHelper.isEmpty(evaluatorName)) {\n      inError = true;\n      addError(\"Mandatory \\\"\" + NAME_ATTRIBUTE\n          + \"\\\" attribute not set for <evaluator>\");\n      return;\n    }\n    try {\n      evaluator = (EventEvaluator<?>) OptionHelper.instantiateByClassName(\n          className, ch.qos.logback.core.boolex.EventEvaluator.class, context);\n\n      evaluator.setContext(this.context);\n      evaluator.setName(evaluatorName);\n\n      ec.pushObject(evaluator);\n      addInfo(\"Adding evaluator named [\" + evaluatorName\n          + \"] to the object stack\");\n\n    } catch (Exception oops) {\n      inError = true;\n      addError(\"Could not create evaluator of type \" + className + \"].\", oops);\n    }\n  }", "negative": "public long offer(final DirectBufferVector[] vectors, final ReservedValueSupplier reservedValueSupplier)\n    {\n        final int length = DirectBufferVector.validateAndComputeLength(vectors);\n        long newPosition = CLOSED;\n\n        if (!isClosed)\n        {\n            final long limit = positionLimit.getVolatile();\n            final ExclusiveTermAppender termAppender = termAppenders[activePartitionIndex];\n            final long position = termBeginPosition + termOffset;\n\n            if (position < limit)\n            {\n                final int result;\n                if (length <= maxPayloadLength)\n                {\n                    result = termAppender.appendUnfragmentedMessage(\n                        termId, termOffset, headerWriter, vectors, length, reservedValueSupplier);\n                }\n                else\n                {\n                    checkMaxMessageLength(length);\n                    result = termAppender.appendFragmentedMessage(\n                        termId,\n                        termOffset,\n                        headerWriter,\n                        vectors,\n                        length,\n                        maxPayloadLength,\n                        reservedValueSupplier);\n                }\n\n                newPosition = newPosition(result);\n            }\n            else\n            {\n                newPosition = backPressureStatus(position, length);\n            }\n        }\n\n        return newPosition;\n    }", "type": "random_negative"}
{"anchor": "@VisibleForTesting\n  String resolveNextPageUrl(String sourceOffset) throws ELEvalException {\n    String url;\n    if (LINK_PAGINATION.contains(conf.pagination.mode) && next != null) {\n      url = next.getUri().toString();\n      setResolvedUrl(url);\n    } else if (conf.pagination.mode == PaginationMode.BY_OFFSET || conf.pagination.mode == PaginationMode.BY_PAGE) {\n      if (sourceOffset != null) {\n        setPageOffset(sourceOffset);\n      }\n      url = resourceEval.eval(resourceVars, conf.resourceUrl, String.class);\n    } else {\n      url = getResolvedUrl();\n    }\n    return url;\n  }", "positive": "@VisibleForTesting\nString resolveNextPageUrl(String sourceOffset) throws ELEvalException {\n    final PaginationMode mode = conf.pagination.mode;\n    if (LINK_PAGINATION.contains(mode) && next != null) {\n        final String url = next.getUri().toString();\n        setResolvedUrl(url);\n        return url;\n    }\n    if (mode == PaginationMode.BY_OFFSET || mode == PaginationMode.BY_PAGE) {\n        if (sourceOffset != null) {\n            setPageOffset(sourceOffset);\n        }\n        return resourceEval.eval(resourceVars, conf.resourceUrl, String.class);\n    }\n    return getResolvedUrl();\n}", "type": "llm_rewrite"}
{"anchor": "public void delete()\n  {\n    // acquire lock for minimum time\n    final long swigPtr = mSwigCPtr.getAndSet(0);\n    if (swigPtr != 0)\n    {\n      if (mJavaRefCount.decrementAndGet() == 0)\n      {\n        // log.debug(\"deleting: {}; {}\", this, mSwigCPtr);\n        FerryJNI.RefCounted_release(swigPtr, null);\n      }\n      // Free the memory manager we use\n      mMemAllocator = null;\n    }\n\n  }", "negative": "public <RET extends Object> RET newInstance(final String iClassName, final Object iEnclosingClass, Object... iArgs) {\r\n    underlying.checkIfActive();\r\n\r\n    checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_CREATE, iClassName);\r\n\r\n    try {\r\n      Class<?> entityClass = entityManager.getEntityClass(iClassName);\r\n      if (entityClass != null) {\r\n        RET enhanced = (RET) OObjectEntityEnhancer.getInstance()\r\n            .getProxiedInstance(entityManager.getEntityClass(iClassName), iEnclosingClass, underlying.newInstance(iClassName), null,\r\n                iArgs);\r\n        return (RET) enhanced;\r\n      } else {\r\n        throw new OSerializationException(\"Type \" + iClassName\r\n            + \" cannot be serialized because is not part of registered entities. To fix this error register this class\");\r\n      }\r\n    } catch (Exception e) {\r\n      final String message = \"Error on creating object of class \" + iClassName;\r\n      OLogManager.instance().error(this, message, e);\r\n\r\n      throw OException.wrapException(new ODatabaseException(message), e);\r\n    }\r\n  }", "type": "random_negative"}
{"anchor": "private void executeConnectionLostDetection(WebSocket webSocket, long minimumPongTime) {\n\t\tif (!(webSocket instanceof WebSocketImpl)) {\n\t\t\treturn;\n\t\t}\n\t\tWebSocketImpl webSocketImpl = (WebSocketImpl) webSocket;\n\t\tif( webSocketImpl.getLastPong() < minimumPongTime ) {\n\t\t\tlog.trace(\"Closing connection due to no pong received: {}\", webSocketImpl);\n\t\t\twebSocketImpl.closeConnection( CloseFrame.ABNORMAL_CLOSE, \"The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection\" );\n\t\t} else {\n\t\t\tif( webSocketImpl.isOpen() ) {\n\t\t\t\twebSocketImpl.sendPing();\n\t\t\t} else {\n\t\t\t\tlog.trace(\"Trying to ping a non open connection: {}\", webSocketImpl);\n\t\t\t}\n\t\t}\n\t}", "negative": "private QueryState markComputed(final IndexedClassExpression queryClass) {\n\t\tfinal QueryState state = indexed_.get(queryClass);\n\t\tif (state == null || state.isComputed) {\n\t\t\treturn null;\n\t\t}\n\t\tstate.isComputed = true;\n\t\tLOGGER_.trace(\"query computed {}\", queryClass);\n\t\treturn state;\n\t}", "type": "random_negative"}
{"anchor": "public static URL[] of(ClassLoader classLoader, Class clazz) {\n\t\tif (clazz == null) {\n\t\t\tclazz = ClassPathURLs.class;\n\t\t}\n\t\tif (classLoader == null) {\n\t\t\tclassLoader = clazz.getClassLoader();\n\t\t}\n\t\tfinal Set<URL> urls = new LinkedHashSet<>();\n\n\t\twhile (classLoader != null) {\n\t\t\tif (classLoader instanceof URLClassLoader) {\n\t\t\t\tURLClassLoader urlClassLoader = (URLClassLoader) classLoader;\n\t\t\t\tURL[] allURLS = urlClassLoader.getURLs();\n\t\t\t\tCollections.addAll(urls, allURLS);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tURL classUrl = classModuleUrl(classLoader, clazz);\n\t\t\tif (classUrl != null) {\n\t\t\t\turls.add(classUrl);\n\t\t\t}\n\t\t\tclassUrl = classModuleUrl(classLoader, ClassPathURLs.class);\n\t\t\tif (classUrl != null) {\n\t\t\t\turls.add(classUrl);\n\t\t\t}\n\n\t\t\tModuleDescriptor moduleDescriptor = clazz.getModule().getDescriptor();\n\n\t\t\tif (moduleDescriptor != null) {\n\t\t\t\tmoduleDescriptor.requires().forEach(req -> {\n\t\t\t\t\tModuleLayer.boot()\n\t\t\t\t\t\t.findModule(req.name())\n\t\t\t\t\t\t.ifPresent(mod -> {\n\t\t\t\t\t\t\tClassLoader moduleClassLoader = mod.getClassLoader();\n\t\t\t\t\t\t\tif (moduleClassLoader != null) {\n\t\t\t\t\t\t\t\tURL url = moduleClassLoader.getResource(MANIFEST);\n\t\t\t\t\t\t\t\tif (url != null) {\n\t\t\t\t\t\t\t\t\turl = fixManifestUrl(url);\n\t\t\t\t\t\t\t\t\turls.add(url);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tclassLoader = classLoader.getParent();\n\t\t}\n\n\t\treturn urls.toArray(new URL[0]);\n\t}", "negative": "public static void bounding( List<Point2D_I32> points , Rectangle2D_I32 rectangle ) {\n\n\t\trectangle.x0 = Integer.MAX_VALUE;\n\t\trectangle.y0 = Integer.MAX_VALUE;\n\t\trectangle.x1 = Integer.MIN_VALUE;\n\t\trectangle.y1 = Integer.MIN_VALUE;\n\n\t\tfor( int i = 0; i < points.size(); i++ ) {\n\t\t\tPoint2D_I32 p = points.get(i);\n\n\t\t\tif( p.x < rectangle.x0 )\n\t\t\t\trectangle.x0 = p.x;\n\t\t\tif( p.x > rectangle.x1 )\n\t\t\t\trectangle.x1 = p.x;\n\t\t\tif( p.y < rectangle.y0 )\n\t\t\t\trectangle.y0 = p.y;\n\t\t\tif( p.y > rectangle.y1 )\n\t\t\t\trectangle.y1 = p.y;\n\t\t}\n\n\t\trectangle.x1++;\n\t\trectangle.y1++;\n\t}", "type": "random_negative"}
{"anchor": "@SuppressWarnings(\"unchecked\")\n\tpublic <T> T getValue(final String key) {\n\t\tT val = (T) map.get(key);\n\n\t\tif (val instanceof Map) {\n\t\t\treturn (T) new JsonObject((Map) val);\n\t\t}\n\t\tif (val instanceof List) {\n\t\t\treturn (T) new JsonArray((List) val);\n\t\t}\n\t\treturn val;\n\t}", "positive": "@SuppressWarnings(\"unchecked\")\npublic <T> T getValue(final String key) {\n    Object obj = map.get(key);\n    if (obj instanceof Map) {\n        return (T) new JsonObject((Map) obj);\n    } else if (obj instanceof List) {\n        return (T) new JsonArray((List) obj);\n    } else {\n        return (T) obj;\n    }\n}", "type": "llm_rewrite"}
{"anchor": "protected synchronized VirtualFile getResteasySpringVirtualFile() throws DeploymentUnitProcessingException {\n        if(resourceRoot != null) {\n            return resourceRoot;\n        }\n        try {\n            Module module = Module.getBootModuleLoader().loadModule(MODULE);\n            URL fileUrl = module.getClassLoader().getResource(JAR_LOCATION);\n\n            if (fileUrl == null) {\n                throw JaxrsLogger.JAXRS_LOGGER.noSpringIntegrationJar();\n            }\n            File dir = new File(fileUrl.toURI());\n            File file = null;\n            for (String jar : dir.list()) {\n                if (jar.endsWith(\".jar\")) {\n                    file = new File(dir, jar);\n                    break;\n                }\n            }\n            if (file == null) {\n                throw JaxrsLogger.JAXRS_LOGGER.noSpringIntegrationJar();\n            }\n            VirtualFile vf = VFS.getChild(file.toURI());\n            final Closeable mountHandle = VFS.mountZip(file, vf, TempFileProviderService.provider());\n            Service<Closeable> mountHandleService = new Service<Closeable>() {\n                public void start(StartContext startContext) throws StartException {\n                }\n\n                public void stop(StopContext stopContext) {\n                    VFSUtils.safeClose(mountHandle);\n                }\n\n                public Closeable getValue() throws IllegalStateException, IllegalArgumentException {\n                    return mountHandle;\n                }\n            };\n            ServiceBuilder<Closeable> builder = serviceTarget.addService(ServiceName.JBOSS.append(SERVICE_NAME),\n                    mountHandleService);\n            builder.setInitialMode(ServiceController.Mode.ACTIVE).install();\n            resourceRoot = vf;\n\n            return resourceRoot;\n        } catch (Exception e) {\n            throw new DeploymentUnitProcessingException(e);\n        }\n    }", "negative": "public void begin(InterpretationContext ec, String name, Attributes attributes) {\n    // Let us forget about previous errors (in this instance)\n    inError = false;\n    evaluator = null;\n\n    String className = attributes.getValue(CLASS_ATTRIBUTE);\n    if (OptionHelper.isEmpty(className)) {\n      className = defaultClassName();\n      addInfo(\"Assuming default evaluator class [\" + className + \"]\");\n    }\n\n    if (OptionHelper.isEmpty(className)) {\n      className = defaultClassName();\n      inError = true;\n      addError(\"Mandatory \\\"\" + CLASS_ATTRIBUTE\n          + \"\\\" attribute not set for <evaluator>\");\n      return;\n    }\n\n    String evaluatorName = attributes.getValue(Action.NAME_ATTRIBUTE);\n    if (OptionHelper.isEmpty(evaluatorName)) {\n      inError = true;\n      addError(\"Mandatory \\\"\" + NAME_ATTRIBUTE\n          + \"\\\" attribute not set for <evaluator>\");\n      return;\n    }\n    try {\n      evaluator = (EventEvaluator<?>) OptionHelper.instantiateByClassName(\n          className, ch.qos.logback.core.boolex.EventEvaluator.class, context);\n\n      evaluator.setContext(this.context);\n      evaluator.setName(evaluatorName);\n\n      ec.pushObject(evaluator);\n      addInfo(\"Adding evaluator named [\" + evaluatorName\n          + \"] to the object stack\");\n\n    } catch (Exception oops) {\n      inError = true;\n      addError(\"Could not create evaluator of type \" + className + \"].\", oops);\n    }\n  }", "type": "random_negative"}
{"anchor": "public void extend(DateRange dr) {\n    boolean localEmpty = isEmpty;\n    if (localEmpty || dr.getStart().before(getStart()))\n      setStart(dr.getStart());\n    if (localEmpty || getEnd().before(dr.getEnd()))\n      setEnd(dr.getEnd());\n  }", "positive": "public void computeExtend(item_25 obj_69) {\n    boolean obj_48 = tmp_93;  // Process the input data\n    if (obj_48 || obj_69.computeGetStart().before(computeGetStart()))\n      executeSetStart(obj_69.computeGetStart());\n    if (obj_48 || computeGetEnd().before(obj_69.computeGetEnd()))\n        performSetEnd(obj_69.computeGetEnd());\n }", "type": "augment"}
{"anchor": "public Buffer append(final String string) {\n\t\tensureLast();\n\n\t\ttry {\n\t\t\tbyte[] bytes = string.getBytes(StringPool.ISO_8859_1);\n\n\t\t\tlast.append(bytes);\n\n\t\t\tsize += bytes.length;\n\t\t} catch (UnsupportedEncodingException ignore) {\n\t\t}\n\n\t\treturn this;\n\t}", "positive": "public Buffer append(final String string) {\n\t\tensureLast();\n\n\t\tbyte[] bytes = string.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1);\n\n\t\tlast.append(bytes);\n\n\t\tsize += bytes.length;\n\n\t\treturn this;\n\t}", "type": "llm_rewrite"}
{"anchor": "private static String getCharsetFromBOM(final byte[] byteData) {\n        BOMInputStream bomIn = new BOMInputStream(new ByteArrayInputStream(\n                byteData));\n        try {\n            ByteOrderMark bom = bomIn.getBOM();\n            if (bom != null) {\n                return bom.getCharsetName();\n            }\n        } catch (IOException e) {\n            return null;\n        }\n        return null;\n    }", "negative": "@VisibleForTesting\n  String resolveNextPageUrl(String sourceOffset) throws ELEvalException {\n    String url;\n    if (LINK_PAGINATION.contains(conf.pagination.mode) && next != null) {\n      url = next.getUri().toString();\n      setResolvedUrl(url);\n    } else if (conf.pagination.mode == PaginationMode.BY_OFFSET || conf.pagination.mode == PaginationMode.BY_PAGE) {\n      if (sourceOffset != null) {\n        setPageOffset(sourceOffset);\n      }\n      url = resourceEval.eval(resourceVars, conf.resourceUrl, String.class);\n    } else {\n      url = getResolvedUrl();\n    }\n    return url;\n  }", "type": "random_negative"}
{"anchor": "public static String getAttributeValue(Element el, QName attrName)\n    {\n        String attr = null;\n        if (\"\".equals(attrName.getNamespaceURI()))\n            attr = el.getAttribute(attrName.getLocalPart());\n        else attr = el.getAttributeNS(attrName.getNamespaceURI(), attrName.getLocalPart());\n\n        if (\"\".equals(attr))\n            attr = null;\n\n        return attr;\n    }", "negative": "public static LinePolar2D_F64 polar( List<Point2D_F64> points , double weights[] , LinePolar2D_F64 ret ) {\n\n\t\tfinal int N = points.size();\n\t\tdouble totalWeight = 0;\n\t\tfor( int i = 0; i < N; i++ ) {\n\t\t\ttotalWeight += weights[i];\n\t\t}\n\n\t\tif( totalWeight == 0 )\n\t\t\treturn null;\n\n\t\tif( ret == null )\n\t\t\tret = new LinePolar2D_F64();\n\n\t\tdouble meanX = 0;\n\t\tdouble meanY = 0;\n\n\t\tfor( int i = 0; i < N; i++ ) {\n\t\t\tPoint2D_F64 p = points.get(i);\n\t\t\tdouble w = weights[i];\n\t\t\tmeanX += w*p.x;\n\t\t\tmeanY += w*p.y;\n\t\t}\n\t\tmeanX /= totalWeight;\n\t\tmeanY /= totalWeight;\n\n\t\tdouble top = 0;\n\t\tdouble bottom = 0;\n\n\t\tfor( int i = 0; i < N; i++ ) {\n\t\t\tPoint2D_F64 p = points.get(i);\n\t\t\tdouble w = weights[i];\n\t\t\tdouble dx = meanX - p.x;\n\t\t\tdouble dy = meanY - p.y;\n\n\t\t\ttop += w*dx*dy;\n\t\t\tbottom += w*(dy*dy - dx*dx);\n\t\t}\n\t\ttop /= totalWeight;\n\t\tbottom /= totalWeight;\n\n\t\tret.angle = Math.atan2(-2.0*top , bottom)/2.0;\n\t\tret.distance = (double)( meanX*Math.cos(ret.angle) + meanY*Math.sin(ret.angle));\n\n\t\treturn ret;\n\t}", "type": "random_negative"}
{"anchor": "private void initDefaultLoginFilter(H http) {\n\t\tDefaultLoginPageGeneratingFilter loginPageGeneratingFilter = http\n\t\t\t\t.getSharedObject(DefaultLoginPageGeneratingFilter.class);\n\t\tif (loginPageGeneratingFilter != null && !isCustomLoginPage()) {\n\t\t\tloginPageGeneratingFilter.setOpenIdEnabled(true);\n\t\t\tloginPageGeneratingFilter.setOpenIDauthenticationUrl(getLoginProcessingUrl());\n\t\t\tString loginPageUrl = loginPageGeneratingFilter.getLoginPageUrl();\n\t\t\tif (loginPageUrl == null) {\n\t\t\t\tloginPageGeneratingFilter.setLoginPageUrl(getLoginPage());\n\t\t\t\tloginPageGeneratingFilter.setFailureUrl(getFailureUrl());\n\t\t\t}\n\t\t\tloginPageGeneratingFilter.setOpenIDusernameParameter(\n\t\t\t\t\tOpenIDAuthenticationFilter.DEFAULT_CLAIMED_IDENTITY_FIELD);\n\t\t}\n\t}", "positive": "private void initDefaultLoginFilter(H http) {\n    DefaultLoginPageGeneratingFilter loginPageGeneratingFilter =\n            http.getSharedObject(DefaultLoginPageGeneratingFilter.class);\n    if (loginPageGeneratingFilter == null || isCustomLoginPage()) {\n        return;\n    }\n\n    loginPageGeneratingFilter.setOpenIdEnabled(true);\n    loginPageGeneratingFilter.setOpenIDauthenticationUrl(getLoginProcessingUrl());\n\n    if (loginPageGeneratingFilter.getLoginPageUrl() == null) {\n        loginPageGeneratingFilter.setLoginPageUrl(getLoginPage());\n        loginPageGeneratingFilter.setFailureUrl(getFailureUrl());\n    }\n\n    loginPageGeneratingFilter.setOpenIDusernameParameter(\n            OpenIDAuthenticationFilter.DEFAULT_CLAIMED_IDENTITY_FIELD);\n}", "type": "llm_rewrite"}
{"anchor": "public String doConvert(String str) {\r\n\r\n\t//check for just missing V2.0\r\n\t  \r\n\t  ParserHELM2 parser = new ParserHELM2();\r\n\t  try{\r\n\t  parser.parse(str + \"V2.0\");\r\n\t  return str + \"V2.0\";\r\n\t  }\r\n\t  catch(Exception e){\r\n\t\t\r\n    /* Use String Builder */\r\n    /* simple add character -> split works then */\r\n    String helm1 = str + \"f\";\r\n\r\n\r\n    StringBuilder helm2 = new StringBuilder();\r\n    String[] sections = helm1.split(\"}\\\\$\");\r\n\r\n    /* Section 1 is accepted in full, no changes necessary, Section 1 has to be there */\r\n    helm2.append(sections[0] + \"}$\");\r\n\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 1; i < sections.length; i++) {\r\n      sb.append(sections[i] + \"}$\");\r\n    }\r\n\r\n    helm1 = \"$\" + sb.toString();\r\n    sections = helm1.split(\"\\\\$\");\r\n\r\n     /*\r\n     * Section 2 connection section; section 3 is added to the second section,\r\n     * Section 2 is not necessary, is this section really there\r\n     */\r\n     if (sections.length >= 2) {\r\n       if (!(sections[1].isEmpty())) {\r\n        helm2.append(sections[1]);\r\n       }\r\n     }\r\n\r\n     /* Add hydrogen bonds to the connection section */\r\n     if (sections.length >= 3) {\r\n       if (!(sections[2].isEmpty())) {\r\n        \r\n         if (!(sections[1].isEmpty())) {\r\n          helm2.append(\"|\" + sections[2]);\r\n         } else {\r\n          helm2.append(sections[2]);\r\n         }\r\n       }\r\n       \r\n       /*Group section*/\r\n      helm2.append(\"$\");\r\n\r\n      helm2.append(\"$\");\r\n       \r\n       /*Add annotation to the annotation section*/\r\n       if (sections.length >= 4) {\r\n         if (!(sections[3].isEmpty())) {\r\n          helm2.append(sections[3]);\r\n         }\r\n       }\r\n\r\n     }\r\n     \r\n    /* Add version number to indicate HELM2 notation */\r\n    helm2.append(\"$V2.0\");\r\n    return helm2.toString();\r\n\t  }\r\n \r\n  }", "negative": "public static <T> Set<T> createSet (Iterator<T> elements) {\n        final Set<T> result = new HashSet<> ();\n        while (elements.hasNext ()) result.add (elements.next ());\n        return result;\n    }", "type": "random_negative"}
{"anchor": "public static List<MimeType> parseMimeTypes(String mimeTypes) {\n        if (!StringUtils.hasLength(mimeTypes)) {\n            return Collections.emptyList();\n        }\n        String[] tokens = mimeTypes.split(\",\\\\s*\");\n        List<MimeType> result = new ArrayList<MimeType>(tokens.length);\n        for (String token : tokens) {\n            result.add(parseMimeType(token));\n        }\n        return result;\n    }", "negative": "public final void addAlias(String alias, String attributeName)\r\n            throws NoSuchAttributeException, AttributeExistsException {\r\n\r\n        // complain if alias name already exists in this AttributeTable.\r\n        if (_attr.get(alias) != null) {\r\n            throw new AttributeExistsException(\"Could not alias `\" + alias +\r\n                    \"' to `\" + attributeName + \"'. \" +\r\n                    \"It is a duplicat name in this AttributeTable\");\r\n        }\r\n        if (Debug.isSet(\"AttributTable\")) {\r\n            log.debug(\"Adding alias '\" + alias + \"' to AttributeTable '\" + getClearName() + \"'\");\r\n        }\r\n\r\n        Alias newAlias = new Alias(alias, attributeName);\r\n        _attr.put(alias, newAlias);\r\n    }", "type": "random_negative"}
{"anchor": "public static Set<Class<?>> getClasses(String packageName, boolean recursive, ClassFileFilter filter) {\n        if (packageName == null || packageName.length() == 0) {\n            throw new IllegalArgumentException(\"packageName is empty.\");\n        }\n\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        String packageDirName = packageName.replace('.', '/');\n        Collection<URL> urls;\n        try {\n            Enumeration<URL> dirs = loader.getResources(packageDirName);\n            urls = Collections.list(dirs);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        Set<Class<?>> klasses = new LinkedHashSet<Class<?>>();\n        for (URL url : urls) {\n            String protocol = url.getProtocol();\n            if (\"file\".equals(protocol)) {\n                lookupClassesInFileSystem(packageName, new File(url.getFile()), recursive, loader, filter, klasses);\n            } else if (\"jar\".equals(protocol)) {\n                lookupClassesInJar(packageName, url, recursive, loader, filter, klasses);\n            }\n        }\n        return klasses;\n    }", "negative": "private SecurityIdentity authenticate(final String username, final char[] credential) throws IOException {\n        final ServerAuthenticationContext context = this.securityDomain.createNewAuthenticationContext();\n        final PasswordGuessEvidence evidence = new PasswordGuessEvidence(credential != null ? credential : null);\n        try {\n            context.setAuthenticationName(username);\n            if (context.verifyEvidence(evidence)) {\n                if (context.authorize()) {\n                    context.succeed();\n                    return context.getAuthorizedIdentity();\n                } else {\n                    context.fail();\n                    throw new SecurityException(\"Authorization failed\");\n                }\n            } else {\n                context.fail();\n                throw new SecurityException(\"Authentication failed\");\n            }\n        } catch (IllegalArgumentException | IllegalStateException | RealmUnavailableException e) {\n            context.fail();\n            throw e;\n        } finally {\n            if (!context.isDone()) {\n                context.fail();\n            }\n            evidence.destroy();\n        }\n    }", "type": "random_negative"}
{"anchor": "public <X extends FSTStruct> StructArray<X> newArray(int size, X templ, BytezAllocator alloc) {\n        StructArray<X> aTemplate = new StructArray<X>(size, templ);\n        int siz = getFactory().calcStructSize(aTemplate);\n        try {\n            if ( siz < chunkSize )\n                return newStruct(aTemplate);\n            else {\n                return getFactory().toStruct(aTemplate,alloc);\n            }\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n    }", "positive": "public <item_2 extends param_37> obj_9<item_2> calcNewArray(int obj_51, item_2 item_99, val_51 val_71) {\n            throw new RuntimeException(param_11);\n        obj_9<item_2> item_19 = new obj_9<item_2>(obj_51, item_99);\n        int tmp_43 = handleGetFactory().calcStructSize(item_19);\n        try {\n            if ( tmp_43 < tmp_50 )\n                // Update counter\n                return processNewStruct(item_19);\n            else {\n                return handleGetFactory().toStruct(item_19,val_71);  // Validate parameters\n            }\n        } catch (val_85 param_11) {\n        }  // Initialize variables\n    }", "type": "augment"}
{"anchor": "public static Element getUniqueChild(Element element, String tagName)\n      throws Exception\n   {\n      Iterator goodChildren = getChildrenByTagName(element, tagName);\n\n      if (goodChildren != null && goodChildren.hasNext()) {\n         Element child = (Element)goodChildren.next();\n         if (goodChildren.hasNext()) {\n            throw new Exception\n               (\"expected only one \" + tagName + \" tag\");\n         }\n         return child;\n      } else {\n         throw new Exception\n            (\"expected one \" + tagName + \" tag\");\n      }\n   }", "positive": "public static Element getUniqueChild(Element element, String tagName)\n      throws Exception\n{\n    Iterator goodChildren = getChildrenByTagName(element, tagName);\n\n    if (goodChildren == null || !goodChildren.hasNext()) {\n        throw new Exception(\"expected one \" + tagName + \" tag\");\n    }\n\n    Element child = (Element) goodChildren.next();\n\n    if (goodChildren.hasNext()) {\n        throw new Exception(\"expected only one \" + tagName + \" tag\");\n    }\n\n    return child;\n}", "type": "llm_rewrite"}
{"anchor": "private boolean isDiamondHierarchy(OClass clazz) {\n    Set<OClass> traversed = new HashSet<>();\n    List<OClass> stack = new ArrayList<>();\n    stack.add(clazz);\n    while (!stack.isEmpty()) {\n      OClass current = stack.remove(0);\n      traversed.add(current);\n      for (OClass sub : current.getSubclasses()) {\n        if (traversed.contains(sub)) {\n          return true;\n        }\n        stack.add(sub);\n        traversed.add(sub);\n      }\n    }\n    return false;\n  }", "negative": "public void onClose() {\n        Iterator<Entry<Integer, InvokeFuture>> iter = invokeFutureMap.entrySet().iterator();\n        while (iter.hasNext()) {\n            Entry<Integer, InvokeFuture> entry = iter.next();\n            iter.remove();\n            InvokeFuture future = entry.getValue();\n            if (future != null) {\n                future.putResponse(future.createConnectionClosedResponse(this.getRemoteAddress()));\n                future.cancelTimeout();\n                future.tryAsyncExecuteInvokeCallbackAbnormally();\n            }\n        }\n    }", "type": "random_negative"}
{"anchor": "static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) {\n    if (type instanceof Integer) {\n      return CONSTANT_KIND | ((Integer) type).intValue();\n    } else if (type instanceof String) {\n      String descriptor = Type.getObjectType((String) type).getDescriptor();\n      return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0);\n    } else {\n      return UNINITIALIZED_KIND\n          | symbolTable.addUninitializedType(\"\", ((Label) type).bytecodeOffset);\n    }\n  }", "positive": "static int getAbstractTypeFromApiFormat(final SymbolTable symbolTable, final Object type) {\n    if (type instanceof Integer) {\n      int value = ((Integer) type).intValue();\n      return CONSTANT_KIND | value;\n    }\n    if (type instanceof String) {\n      String descriptor = Type.getObjectType((String) type).getDescriptor();\n      return getAbstractTypeFromDescriptor(symbolTable, descriptor, 0);\n    }\n    Label label = (Label) type;\n    return UNINITIALIZED_KIND | symbolTable.addUninitializedType(\"\", label.bytecodeOffset);\n  }", "type": "llm_rewrite"}
{"anchor": "public BeanReferences[] resolveReferenceFromValues(final Executable methodOrCtor, final String... parameterReferences) {\n\t\tBeanReferences[] references = convertRefToReferences(parameterReferences);\n\n\t\tif (references == null || references.length == 0) {\n\t\t\treferences = buildDefaultReferences(methodOrCtor);\n\t\t}\n\n\t\tif (methodOrCtor.getParameterTypes().length != references.length) {\n\t\t\tthrow new PetiteException(\"Different number of method parameters and references for: \" +\n\t\t\t\tmethodOrCtor.getDeclaringClass().getName() + '#' + methodOrCtor.getName());\n\t\t}\n\n\t\tremoveAllDuplicateNames(references);\n\n\t\treturn references;\n\t}", "negative": "private <T> Observable.Transformer<T, T> applyInsertRetryPolicy() {\n        return tObservable -> tObservable\n                .retryWhen(errors -> {\n                    Observable<Integer> range = Observable.range(1, 2);\n                    return errors\n                            .zipWith(range, (t, i) -> {\n                                if (t instanceof DriverException) {\n                                    return i;\n                                }\n                                throw Exceptions.propagate(t);\n                            })\n                            .flatMap(retryCount -> {\n                                long delay = (long) Math.min(Math.pow(2, retryCount) * 1000, 3000);\n                                log.debug(\"Retrying batch insert in \" + delay + \" ms\");\n                                return Observable.timer(delay, TimeUnit.MILLISECONDS);\n                            });\n                });\n    }", "type": "random_negative"}
{"anchor": "@SuppressWarnings(\"unchecked\")\n\tprivate void setKey(final P pojo, final IncompleteKey key, final LoadContext ctx, final Path containerPath) {\n\t\tif (!clazz.isAssignableFrom(pojo.getClass()))\n\t\t\tthrow new IllegalArgumentException(\"Trying to use metadata for \" + clazz.getName() + \" to set key of \" + pojo.getClass().getName());\n\n\t\t// If no key, don't need to do anything\n\t\tif (key == null)\n\t\t\treturn;\n\n\t\tidMeta.setValue(pojo, Keys.getIdValue(key), ctx, containerPath);\n\n\t\tfinal com.google.cloud.datastore.Key parentKey = key.getParent();\n\t\tif (parentKey != null) {\n\t\t\tif (this.parentMeta == null)\n\t\t\t\tthrow new IllegalStateException(\"Loaded Entity has parent but \" + clazz.getName() + \" has no @Parent\");\n\n\t\t\tparentMeta.setValue(pojo, (Value)KeyValue.of(parentKey), ctx, containerPath);\n\t\t}\n\t}", "negative": "private void buildCells(final String fullName,\r\n\t\t\tfinal ConfigBuildRef configBuildRef, final int atRow,\r\n\t\t\tfinal Map<String, Object> context,\r\n\t\t\tfinal List<RowsMapping> rowsMappingList) {\r\n\r\n\t\tif ((context == null) || context.isEmpty()) {\r\n\t\t\t// no need to evaluate as there's no data object.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// keep rowsMappingList as current as no change\r\n\t\t// allRowsMappingList = child + current\r\n\r\n\t\tList<RowsMapping> allRowsMappingList = ConfigurationUtility\r\n\t\t\t\t.findChildRowsMappingFromShiftMap(fullName,\r\n\t\t\t\t\t\tconfigBuildRef.getShiftMap());\r\n\t\tallRowsMappingList.addAll(rowsMappingList);\r\n\r\n\t\tint lastRowPlus = this.getLastRowPlusRef().getRowIndex();\r\n\t\tShiftFormulaRef shiftFormulaRef = new ShiftFormulaRef(\r\n\t\t\t\tconfigBuildRef.getWatchList(), allRowsMappingList);\r\n\t\tfor (int i = atRow; i < lastRowPlus; i++) {\r\n\t\t\tbuildCellsForRow(configBuildRef.getSheet().getRow(i), fullName,\r\n\t\t\t\t\tcontext, configBuildRef, shiftFormulaRef);\r\n\t\t}\r\n\t}", "type": "random_negative"}
{"anchor": "public static int getPropertyInt( final Object root, final String... properties ) {\n\n\n        final String lastProperty = properties[ properties.length - 1 ];\n\n\n\n\n        if ( isDigits( lastProperty ) ) {\n\n            return Conversions.toInt(getPropertyValue(root, properties));\n\n        }\n\n\n        Object object = baseForGetProperty( root, properties );\n\n        Map<String, FieldAccess> fields = getFieldsFromObject( object );\n\n        FieldAccess field = fields.get( lastProperty );\n\n\n        if ( field.type() == Typ.intgr ) {\n            return field.getInt( object );\n        } else {\n            return Conversions.toInt( field.getValue( object ) );\n        }\n\n    }", "positive": "public static int getPropertyInt(final Object root, final String... properties) {\n    final String lastProperty = properties[properties.length - 1];\n\n    if (isDigits(lastProperty)) {\n        return Conversions.toInt(getPropertyValue(root, properties));\n    }\n\n    Object object = baseForGetProperty(root, properties);\n    Map<String, FieldAccess> fields = getFieldsFromObject(object);\n    FieldAccess field = fields.get(lastProperty);\n\n    return field.type() == Typ.intgr ? field.getInt(object) : Conversions.toInt(field.getValue(object));\n}", "type": "llm_rewrite"}
{"anchor": "@Override\n    public Type getHtmlInputFieldType() {\n        final Type ret;\n        if (inputAnnotation == null || inputAnnotation.value() == Type.FROM_JAVA) {\n            if (isArrayOrCollection() || isRequestBody()) {\n                ret = null;\n            } else if (DataType.isNumber(getParameterType())) {\n                ret = Type.NUMBER;\n            } else {\n                ret = Type.TEXT;\n            }\n        } else {\n            ret = inputAnnotation.value();\n        }\n        return ret;\n    }", "negative": "protected void downgradeAusblickElements(Document doc) throws JaxenException {\n        List nodes = XmlUtils.newXPath(\n                \"/io:openimmo/io:anbieter/io:immobilie/io:infrastruktur/io:ausblick[@blick]\",\n                doc).selectNodes(doc);\n        for (Object item : nodes) {\n            Element node = (Element) item;\n            String value = StringUtils.trimToNull(node.getAttribute(\"blick\"));\n            if (\"MEER\".equalsIgnoreCase(value))\n                node.setAttribute(\"blick\", \"SEE\");\n        }\n    }", "type": "random_negative"}
{"anchor": "int addConstantUtf8(final String value) {\n    int hashCode = hash(Symbol.CONSTANT_UTF8_TAG, value);\n    Entry entry = get(hashCode);\n    while (entry != null) {\n      if (entry.tag == Symbol.CONSTANT_UTF8_TAG\n          && entry.hashCode == hashCode\n          && entry.value.equals(value)) {\n        return entry.index;\n      }\n      entry = entry.next;\n    }\n    constantPool.putByte(Symbol.CONSTANT_UTF8_TAG).putUTF8(value);\n    return put(new Entry(constantPoolCount++, Symbol.CONSTANT_UTF8_TAG, value, hashCode)).index;\n  }", "positive": "int addConstantUtf8(final String value) {\n    final int tag = Symbol.CONSTANT_UTF8_TAG;\n    final int hashCode = hash(tag, value);\n    for (Entry entry = get(hashCode); entry != null; entry = entry.next) {\n        if (entry.tag == tag && entry.hashCode == hashCode && entry.value.equals(value)) {\n            return entry.index;\n        }\n    }\n    constantPool.putByte(tag).putUTF8(value);\n    Entry newEntry = new Entry(constantPoolCount++, tag, value, hashCode);\n    return put(newEntry).index;\n}", "type": "llm_rewrite"}
{"anchor": "protected void allowableSessionsExceeded(List<SessionInformation> sessions,\n\t\t\tint allowableSessions, SessionRegistry registry)\n\t\t\tthrows SessionAuthenticationException {\n\t\tif (exceptionIfMaximumExceeded || (sessions == null)) {\n\t\t\tthrow new SessionAuthenticationException(messages.getMessage(\n\t\t\t\t\t\"ConcurrentSessionControlAuthenticationStrategy.exceededAllowed\",\n\t\t\t\t\tnew Object[] { Integer.valueOf(allowableSessions) },\n\t\t\t\t\t\"Maximum sessions of {0} for this principal exceeded\"));\n\t\t}\n\n\t\t// Determine least recently used session, and mark it for invalidation\n\t\tSessionInformation leastRecentlyUsed = null;\n\n\t\tfor (SessionInformation session : sessions) {\n\t\t\tif ((leastRecentlyUsed == null)\n\t\t\t\t\t|| session.getLastRequest()\n\t\t\t\t\t\t\t.before(leastRecentlyUsed.getLastRequest())) {\n\t\t\t\tleastRecentlyUsed = session;\n\t\t\t}\n\t\t}\n\n\t\tleastRecentlyUsed.expireNow();\n\t}", "negative": "private Node createIssueElement(final LintItem error) {\n    final Element issueElement = getDocument().createElement(getIssueElementName());\n\n    final String column = String.valueOf(error.getColumn());\n    if (StringUtils.isNotBlank(column)) {\n      issueElement.setAttribute(getColumnAttributeName(), column);\n    }\n\n    final String evidence = error.getEvidence();\n    if (StringUtils.isNotBlank(evidence)) {\n      issueElement.setAttribute(ATTR_EVIDENCE, evidence);\n    }\n\n    final String line = String.valueOf(error.getLine());\n    if (StringUtils.isNotBlank(line)) {\n      issueElement.setAttribute(ATTR_LINE, line);\n    }\n\n    final String reason = error.getReason();\n    if (StringUtils.isNotBlank(reason)) {\n      issueElement.setAttribute(getReasonAttributeName(), reason);\n    }\n\n    final String severity = error.getSeverity();\n    if (StringUtils.isNotBlank(severity)) {\n      issueElement.setAttribute(ATTR_SEVERITY, severity);\n    }\n    return issueElement;\n  }", "type": "random_negative"}
{"anchor": "private void constructTopVariables(DodsV rootDodsV, CancelTask cancelTask) throws IOException {\n    List<DodsV> topVariables = rootDodsV.children;\n    for (DodsV dodsV : topVariables) {\n      if (dodsV.bt instanceof DConstructor) continue;\n      addVariable(rootGroup, null, dodsV);\n      if (cancelTask != null && cancelTask.isCancel()) return;\n    }\n  }", "positive": "private void constructTopVariables(DodsV rootDodsV, CancelTask cancelTask) throws IOException {\n    List<DodsV> topVariables = rootDodsV.children;\n    for (int i = 0, n = topVariables.size(); i < n; i++) {\n        DodsV dodsV = topVariables.get(i);\n        if (dodsV.bt instanceof DConstructor) {\n            continue;\n        }\n        addVariable(rootGroup, null, dodsV);\n        if (cancelTask != null && cancelTask.isCancel()) {\n            return;\n        }\n    }\n}", "type": "llm_rewrite"}
{"anchor": "boolean alreadyLoadedLibrary(String aLibraryName, Long aMajorVersion)\n  {\n    boolean retval = false;\n    Set<Long> foundVersions = mLoadedLibraries.get(aLibraryName);\n    if (foundVersions != null)\n    {\n      // we found at least some versions\n      if (aMajorVersion == null || foundVersions.contains(aMajorVersion))\n      {\n        retval = true;\n      }\n      else\n      {\n        log\n            .warn(\n                \"Attempting load of {}, version {}, but already loaded verions: {}.\"\n                    + \"  We will attempt to load the specified version but behavior is undefined\",\n                new Object[]\n                {\n                    aLibraryName, aMajorVersion, foundVersions.toArray()\n                });\n      }\n    }\n    return retval;\n  }", "positive": "boolean alreadyLoadedLibrary(String aLibraryName, Long aMajorVersion)\n{\n  Set<Long> foundVersions = mLoadedLibraries.get(aLibraryName);\n  if (foundVersions == null)\n  {\n    return false;\n  }\n  if (aMajorVersion == null || foundVersions.contains(aMajorVersion))\n  {\n    return true;\n  }\n  log\n      .warn(\n          \"Attempting load of {}, version {}, but already loaded verions: {}.\"\n              + \"  We will attempt to load the specified version but behavior is undefined\",\n          new Object[]\n          {\n              aLibraryName, aMajorVersion, foundVersions.toArray()\n          });\n  return false;\n}", "type": "llm_rewrite"}
{"anchor": "public static String getFileExtension(final String path) {\n        if (path == null) {\n            return null;\n        }\n        int extIndex = path.lastIndexOf('.');\n        if (extIndex == -1) {\n            return null;\n        }\n        int folderIndex = getFileSeparatorIndex(path);\n        if (folderIndex > extIndex) {\n            return null;\n        }\n        return path.substring(extIndex + 1);\n    }", "negative": "private void writeResponseHeaderToRecordHeader(Response response, Record.Header header) {\n    for (Map.Entry<String, List<String>> entry : response.getStringHeaders().entrySet()) {\n      if (!entry.getValue().isEmpty()) {\n        String firstValue = entry.getValue().get(0);\n        header.setAttribute(conf.headerAttributePrefix + entry.getKey(), firstValue);\n      }\n    }\n  }", "type": "random_negative"}
{"anchor": "public static boolean isValidOTPFormat(String otp) {\n\t\tif (otp == null){\n\t\t\treturn false;\n\t\t}\t\t\n\t\tint len = otp.length();\n\t\tfor (char c : otp.toCharArray()) {\n\t\t\tif (c < 0x20 || c > 0x7E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn OTP_MIN_LEN <= len && len <= OTP_MAX_LEN;\n\t}", "positive": " public static boolean calcIsValidOTPFormat(String obj_27) {\n\t\tif (obj_27 == null){\n\t\t\treturn false; \n } \n\t\tint item_52 = obj_27.length();\n for (char val_51 : obj_27.toCharArray()) {\n\t\t\tif (val_51 < 0x20 || val_51 > 0x7E) {\n\t\t\t\treturn false; \n\t\t\t}\n }\n\t\treturn val_42 <= item_52 && item_52 <= param_14;\n\t}", "type": "augment"}
{"anchor": "private static ParsedSectionSpec parseVariableSelector(Object parent, String selector) throws InvalidRangeException {\n    String varNameEsc, indexSelect = null;\n\n    int pos1 = EscapeStrings.indexOf(selector, '(');\n    if (pos1 < 0) { // no index\n      varNameEsc = selector;\n    } else {\n      varNameEsc = selector.substring(0, pos1);\n      int pos2 = selector.indexOf(')', pos1+1);\n      indexSelect = selector.substring(pos1, pos2);\n    }\n    if (debugSelector)\n      System.out.println(\" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\");\n\n    Variable v = null;\n    if (parent instanceof NetcdfFile) { // then varNameEsc = varFullNameEsc (i.e. includes groups)\n      NetcdfFile ncfile = (NetcdfFile) parent;\n      v = ncfile.findVariable(varNameEsc);\n\n    } else if (parent instanceof Structure) { // then varNameEsc = memberNameEsc (i.e. includes groups)\n      Structure s = (Structure) parent;\n      v = s.findVariable( NetcdfFile.makeNameUnescaped(varNameEsc) ); // s.findVariable wants unescaped version\n    }\n    if (v == null)\n      throw new IllegalArgumentException(\" cant find variable: \" + varNameEsc + \" in selector=\" + selector);\n    \n    if (v.getDataType() == DataType.SEQUENCE)\n      indexSelect = null; // ignore whatever was sent\n\n    // get the selected Ranges, or all, and add to the list\n    Section section;\n    if (indexSelect != null) {\n      section = new Section(indexSelect);\n      section = Section.fill(section, v.getShape()); // Check section has no nulls, set from shape array.\n    } else {\n      section = v.getShapeAsSection(); // all\n    }\n\n    return new ParsedSectionSpec(v, section);\n  }", "positive": "private static ParsedSectionSpec parseVariableSelector(Object parent, String selector) throws InvalidRangeException {\n    String varNameEsc;\n    String indexSelect = null;\n\n    int pos1 = EscapeStrings.indexOf(selector, '(');\n    if (pos1 < 0) {\n      varNameEsc = selector;\n    } else {\n      varNameEsc = selector.substring(0, pos1);\n      int pos2 = selector.indexOf(')', pos1 + 1);\n      indexSelect = selector.substring(pos1, pos2);\n    }\n\n    if (debugSelector)\n      System.out.println(\" parseVariableSection <\" + selector + \"> = <\" + varNameEsc + \">, <\" + indexSelect + \">\");\n\n    Variable v = null;\n    if (parent instanceof NetcdfFile) {\n      NetcdfFile ncfile = (NetcdfFile) parent;\n      v = ncfile.findVariable(varNameEsc);\n    } else if (parent instanceof Structure) {\n      Structure s = (Structure) parent;\n      v = s.findVariable(NetcdfFile.makeNameUnescaped(varNameEsc));\n    }\n\n    if (v == null)\n      throw new IllegalArgumentException(\" cant find variable: \" + varNameEsc + \" in selector=\" + selector);\n\n    if (v.getDataType() == DataType.SEQUENCE)\n      indexSelect = null;\n\n    Section section;\n    if (indexSelect != null) {\n      section = new Section(indexSelect);\n      section = Section.fill(section, v.getShape());\n    } else {\n      section = v.getShapeAsSection();\n    }\n\n    return new ParsedSectionSpec(v, section);\n  }", "type": "llm_rewrite"}
{"anchor": "private void shrink() {\n\t\tint oldCapacity = data.length;\n\t\tif (oldCapacity == 1)\n\t\t\treturn;\n\t\tE[] oldData = data;\n\t\tint[] oldMasks = masks;\n\t\tint newCapacity = oldCapacity >> 1;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tE[] newData = (E[]) new Object[newCapacity];\n\t\tint[] newMasks = new int[getMaskCapacity(logs, newCapacity)];\n\t\tfor (int i = 0; i < oldCapacity; i++) {\n\t\t\tE e = oldData[i];\n\t\t\tif (e != null)\n\t\t\t\taddMask(logs, newData, newMasks, e,\n\t\t\t\t\t\tgetFragment(logs, oldMasks, i));\n\t\t}\n\t\tthis.data = newData;\n\t\tthis.masks = newMasks;\n\t}", "negative": "private boolean isGroup(DStructure dstruct) {\n    BaseType parent = (BaseType) dstruct.getParent();\n    if (parent == null) return true;\n    if (parent instanceof DStructure)\n      return isGroup((DStructure) parent);\n    return true;\n  }", "type": "random_negative"}
{"anchor": "public LatLonPoint projToLatLon(ProjectionPoint world, LatLonPointImpl result) {\r\n    double toLat, toLon;\r\n    double fromX = (world.getX() - falseEasting) / totalScale;  // assumes cartesion coords in km\r\n    double fromY = (world.getY() - falseNorthing) / totalScale;\r\n\r\n    fromY = rho0 - fromY;\r\n    double rho = MapMath.distance(fromX, fromY);\r\n\r\n    if (rho == 0.0) {\r\n      toLon = 0.0;\r\n      toLat = n > 0.0 ? MapMath.HALFPI : -MapMath.HALFPI;\r\n\r\n    } else {\r\n      if (n < 0.0) {\r\n        rho = -rho;\r\n        fromX = -fromX;\r\n        fromY = -fromY;\r\n      }\r\n      double lpphi = rho / dd;\r\n\r\n      if (!earth.isSpherical()) {\r\n        lpphi = (c - lpphi * lpphi) / n;\r\n        if (Math.abs(ec - Math.abs(lpphi)) > TOL7) {\r\n          if (Math.abs(lpphi) > 2.0)\r\n            throw new IllegalArgumentException(\"AlbersEqualAreaEllipse x,y=\"+world);\r\n\r\n          lpphi = phi1_(lpphi, e, one_es);\r\n          if (lpphi == Double.MAX_VALUE)\r\n            throw new RuntimeException(\"I\");\r\n        } else {\r\n          lpphi = (lpphi < 0.) ? -MapMath.HALFPI : MapMath.HALFPI;\r\n        }\r\n\r\n      } else { // spherical case\r\n        lpphi = (c - lpphi * lpphi) / n2;\r\n        if (Math.abs(lpphi) <= 1.0) {\r\n          lpphi = Math.asin(lpphi);\r\n        } else {\r\n          lpphi = (lpphi < 0.) ? -MapMath.HALFPI : MapMath.HALFPI;\r\n        }\r\n      }\r\n\r\n      toLon = Math.atan2(fromX, fromY) / n;\r\n      //coverity[swapped_arguments]\r\n      toLat = lpphi;\r\n    }\r\n\r\n    result.setLatitude(Math.toDegrees(toLat));\r\n    result.setLongitude(Math.toDegrees(toLon) + lon0deg);\r\n    return result;\r\n  }", "negative": "ImmutableList<SingleMemberInjector> getInjectors(\n      Set<InjectionPoint> injectionPoints, Errors errors) {\n    List<SingleMemberInjector> injectors = Lists.newArrayList();\n    for (InjectionPoint injectionPoint : injectionPoints) {\n      try {\n        Errors errorsForMember =\n            injectionPoint.isOptional()\n                ? new Errors(injectionPoint)\n                : errors.withSource(injectionPoint);\n        SingleMemberInjector injector =\n            injectionPoint.getMember() instanceof Field\n                ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember)\n                : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember);\n        injectors.add(injector);\n      } catch (ErrorsException ignoredForNow) {\n        // ignored for now\n      }\n    }\n    return ImmutableList.copyOf(injectors);\n  }", "type": "random_negative"}
{"anchor": "NcStreamProto.ArrayStructureRow.Builder encodeStructureData(String structName, Array data) {\n    assert data instanceof ArrayStructure;\n    ArrayStructure as = (ArrayStructure) data;\n    int nelems = (int) as.getSize();\n\n    List<MemberData> memberData = new ArrayList<>();\n    StructureMembers sm = as.getStructureMembers();\n    for (StructureMembers.Member m : sm.getMembers()) {\n      memberData.add( new MemberData(m, nelems));\n    }\n\n    // use most efficient form of data extraction\n    for (int recno=0; recno<nelems; recno++) {\n      for (MemberData md : memberData) {\n        if (md.member.isVariableLength()) {\n          md.vlenList.add(as.getArray(recno, md.member));\n        } else {\n          extractData(as, recno, md);\n        }\n      }\n    }\n\n    NcStreamProto.ArrayStructureRow.Builder builder = NcStreamProto.ArrayStructureRow.newBuilder();\n    for (MemberData md : memberData) {\n      NcStreamProto.Member.Builder member = NcStreamProto.Member.newBuilder();\n      member.setShortName(md.member.getName());\n      member.setDataType(NcStream.convertDataType(md.member.getDataType()));\n      /* LOOK\n      member.setNelems(md.nelems);\n      if (md.member.isVariableLength()) {\n        md.completeVlens();\n        nested.addAllVlens (md.vlens);\n        nested.setPrimdata(ByteString.copyFrom(md.bb));\n\n      } else if (md.member.getDataType() == DataType.STRING)\n        nested.addAllStringdata(md.stringList);\n      else if (md.member.getDataType() == DataType.OPAQUE)\n        nested.addAllOpaquedata(md.opaqueList);\n      else\n        nested.setPrimdata(ByteString.copyFrom(md.bb)); */\n\n      builder.addMembers(member);\n    }\n\n    return builder;\n  }", "negative": "@Override\n    public IComplexNDArray subi(INDArray other, INDArray result) {\n        IComplexNDArray cOther = (IComplexNDArray) other;\n        IComplexNDArray cResult = (IComplexNDArray) result;\n\n        if (other.isScalar())\n            return subi(cOther.getComplex(0), result);\n\n\n        if (result == this)\n            Nd4j.getBlasWrapper().axpy(Nd4j.NEG_UNIT, cOther, cResult);\n        else if (result == other) {\n            if (data.dataType() == (DataBuffer.Type.DOUBLE)) {\n                Nd4j.getBlasWrapper().scal(Nd4j.NEG_UNIT.asDouble(), cResult);\n                Nd4j.getBlasWrapper().axpy(Nd4j.UNIT, this, cResult);\n            } else {\n                Nd4j.getBlasWrapper().scal(Nd4j.NEG_UNIT.asFloat(), cResult);\n                Nd4j.getBlasWrapper().axpy(Nd4j.UNIT, this, cResult);\n            }\n\n        } else {\n            Nd4j.getBlasWrapper().copy(this, result);\n            Nd4j.getBlasWrapper().axpy(Nd4j.NEG_UNIT, cOther, cResult);\n        }\n        return cResult;\n    }", "type": "random_negative"}
{"anchor": "public final void writeShort(short[] pa, int start, int n) throws IOException {\r\n    for (int i = 0; i < n; i++) {\r\n      writeShort(pa[start + i]);\r\n    }\r\n  }", "positive": "public final void writeShort(short[] pa,  int start,  int n) throws IOException {\r\n    int i =  0;\n    while (i <  n) {\n\r\n writeShort(pa[start + i]); \n \n        i+ +;\n} \n  }", "type": "augment"}
{"anchor": "@Override\n    public IComplexNDArray subi(INDArray other, INDArray result) {\n        IComplexNDArray cOther = (IComplexNDArray) other;\n        IComplexNDArray cResult = (IComplexNDArray) result;\n\n        if (other.isScalar())\n            return subi(cOther.getComplex(0), result);\n\n\n        if (result == this)\n            Nd4j.getBlasWrapper().axpy(Nd4j.NEG_UNIT, cOther, cResult);\n        else if (result == other) {\n            if (data.dataType() == (DataBuffer.Type.DOUBLE)) {\n                Nd4j.getBlasWrapper().scal(Nd4j.NEG_UNIT.asDouble(), cResult);\n                Nd4j.getBlasWrapper().axpy(Nd4j.UNIT, this, cResult);\n            } else {\n                Nd4j.getBlasWrapper().scal(Nd4j.NEG_UNIT.asFloat(), cResult);\n                Nd4j.getBlasWrapper().axpy(Nd4j.UNIT, this, cResult);\n            }\n\n        } else {\n            Nd4j.getBlasWrapper().copy(this, result);\n            Nd4j.getBlasWrapper().axpy(Nd4j.NEG_UNIT, cOther, cResult);\n        }\n        return cResult;\n    }", "negative": "protected void registerScopeFactory(ScopeFactory scopeFactory) {\r\n\t\tif (scopeFactory == null) {\r\n\t\t\tlog.debug(\"Register null scope factory to |%s|.\", InstanceScope.LOCAL);\r\n\t\t\tscopeFactories.put(InstanceScope.LOCAL, null);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal InstanceScope instanceScope = scopeFactory.getInstanceScope();\r\n\t\tlog.debug(\"Register scope factory |%s| to |%s|.\", scopeFactory.getClass(), instanceScope);\r\n\t\tif (scopeFactories.put(instanceScope, scopeFactory) != null) {\r\n\t\t\tthrow new BugError(\"Attempt to override instance scope |%s|.\", instanceScope);\r\n\t\t}\r\n\t}", "type": "random_negative"}
{"anchor": "public static List<Point4D_F64> randomN( Point3D_F64 center , double w, double stdev, int num, Random rand ) {\n\t\tList<Point4D_F64> ret = new ArrayList<>();\n\n\t\tfor( int i = 0; i < num; i++ ) {\n\t\t\tPoint4D_F64 p = new Point4D_F64();\n\t\t\tp.x = center.x + rand.nextGaussian() * stdev;\n\t\t\tp.y = center.y + rand.nextGaussian() * stdev;\n\t\t\tp.z = center.z + rand.nextGaussian() * stdev;\n\t\t\tp.w = w;\n\n\t\t\tret.add( p );\n\t\t}\n\n\t\treturn ret;\n\t}", "positive": "public static List<Point4D_F64> randomN( Point3D_F64 center , double w, double stdev, int num, Random rand ) {\n    List<Point4D_F64> ret = new ArrayList<>(Math.max(0, num));\n    for (int i = 0; i < num; i++) {\n        double gx = rand.nextGaussian() * stdev;\n        double gy = rand.nextGaussian() * stdev;\n        double gz = rand.nextGaussian() * stdev;\n\n        Point4D_F64 p = new Point4D_F64();\n        p.x = center.x + gx;\n        p.y = center.y + gy;\n        p.z = center.z + gz;\n        p.w = w;\n\n        ret.add(p);\n    }\n    return ret;\n}", "type": "llm_rewrite"}
{"anchor": "private String extractUserId(String studentId, ResponseEntity<String> response) {\n        Configuration config = Configuration.builder().options(\n                Option.DEFAULT_PATH_LEAF_TO_NULL\n        ).build();\n        ReadContext readContext = JsonPath\n                .using(config)\n                .parse(response.getBody());\n\n        String success = readContext.read(SUCCESS_QUERY);\n        // SSP passes this as a string...\n        if (!\"true\".equalsIgnoreCase(success)) {\n            return null;\n        }\n\n        int count = readContext.read(RESULTS_QUERY, Integer.class);\n        if (count != 1) {\n            // couldn't find a single unique result.  Bail now...\n            log.warn(\"Expected a single unique result for \" + studentId + \".  Found \" + count);\n            return null;\n        }\n\n        String id = readContext.read(STUDENT_ID_QUERY);\n        return id;\n    }", "positive": "private String extractUserId(String studentId, ResponseEntity<String> response) {\n    Configuration config = Configuration.builder()\n            .options(Option.DEFAULT_PATH_LEAF_TO_NULL)\n            .build();\n    ReadContext readContext = JsonPath.using(config).parse(response.getBody());\n\n    String success = readContext.read(SUCCESS_QUERY, String.class);\n    if (!\"true\".equalsIgnoreCase(success)) {\n        return null;\n    }\n\n    Integer count = readContext.read(RESULTS_QUERY, Integer.class);\n    if (count == null || count != 1) {\n        log.warn(\"Expected a single unique result for \" + studentId + \".  Found \" + count);\n        return null;\n    }\n\n    String id = readContext.read(STUDENT_ID_QUERY, String.class);\n    return id;\n}", "type": "llm_rewrite"}
{"anchor": "public OGraphMLReader inputGraph(final Graph inputGraph, final String filename, int bufferSize, String vertexIdKey,\n      String edgeIdKey, String edgeLabelKey) throws IOException {\n    FileInputStream fis = new FileInputStream(filename);\n    try {\n      return inputGraph(inputGraph, fis, bufferSize, vertexIdKey, edgeIdKey, edgeLabelKey);\n    } finally {\n      fis.close();\n    }\n  }", "negative": "@Override\n\tpublic String visit(IndexedClass element) {\n\t\tElkClass entity = element.getElkEntity();\n\t\tif (entity.getIri().equals(PredefinedElkIris.OWL_THING)) {\n\t\t\treturn \"\u22a4\";\n\t\t}\n\t\t// else\n\t\tif (entity.getIri().equals(PredefinedElkIris.OWL_NOTHING)) {\n\t\t\treturn \"\u22a5\";\n\t\t}\n\t\t// else\n\t\treturn entity.toString();\n\t}", "type": "random_negative"}
{"anchor": "public static String send(UsernamePasswordCredentials upc,\n                              InputStream keystore, char[] password,\n                              HttpHost targetHost, String uri, HttpHost proxyHost,\n                              String encoding, RequestMethod method, Header... headers) throws IOException {\n\n        if (!uri.startsWith(\"/\")) {\n            uri = \"/\" + uri;\n        }\n        HttpRequest hm = getHttpMethod(method, uri);\n        if (headers != null && headers.length > 0) {\n            hm.setHeaders(headers);\n        }\n        log.debug(\"url: {} method: {}\", getURL(targetHost, uri), method);\n\n        return execute(targetHost, proxyHost, hm, encoding, upc,\n                keystore, password);\n    }", "negative": "private QueryState markComputed(final IndexedClassExpression queryClass) {\n\t\tfinal QueryState state = indexed_.get(queryClass);\n\t\tif (state == null || state.isComputed) {\n\t\t\treturn null;\n\t\t}\n\t\tstate.isComputed = true;\n\t\tLOGGER_.trace(\"query computed {}\", queryClass);\n\t\treturn state;\n\t}", "type": "random_negative"}
{"anchor": "public static Method prefixMethodOfBeanByField(String prefix, Class<?> clazz, Field field,\n                                                   Class<?>... argTypes) {\n        Method method = null;\n        String fieldName = field.getName();\n        StringBuilder builder = new StringBuilder(prefix);\n        builder.append(fieldName.substring(0, 1).toUpperCase());\n        builder.append(fieldName.substring(1, fieldName.length()));\n        String methodName = builder.toString();\n        try {\n            method = clazz.getDeclaredMethod(methodName, argTypes);\n        } catch (SecurityException e) {\n        } catch (NoSuchMethodException e) {\n        }\n        return method;\n    }", "positive": "public static Method prefixMethodOfBeanByField(String prefix, Class<?> clazz, Field field,\n                                                   Class<?>... argTypes) {\n    Method method = null;\n    String fieldName = field.getName();\n    String methodName = prefix + Character.toUpperCase(fieldName.charAt(0)) + (fieldName.length() > 1 ? fieldName.substring(1) : \"\");\n    try {\n        method = clazz.getDeclaredMethod(methodName, argTypes);\n    } catch (NoSuchMethodException | SecurityException e) {\n        // intentionally ignored\n    }\n    return method;\n}", "type": "llm_rewrite"}
{"anchor": "public void removeArgFromFunction(String varName, DifferentialFunction function) {\n        val args = function.args();\n\n        for (int i = 0; i < args.length; i++) {\n            if (args[i].getVarName().equals(varName)) {\n                /**\n                 * Since we are removing the variable reference\n                 * from the arguments we need to  update both\n                 * the reverse and forward arguments.\n                 */\n                val reverseArgs = incomingArgsReverse.get(function.getOwnName());\n                incomingArgs.remove(reverseArgs);\n                incomingArgsReverse.remove(function.getOwnName());\n                val newArgs = new ArrayList<String>(args.length - 1);\n                for (int arg = 0; arg < args.length; arg++) {\n                    if (!reverseArgs[arg].equals(varName)) {\n                        newArgs.add(reverseArgs[arg]);\n                    }\n                }\n\n                val newArgsArr = newArgs.toArray(new String[newArgs.size()]);\n                incomingArgs.put(newArgsArr, function);\n                incomingArgsReverse.put(function.getOwnName(), newArgsArr);\n                //no further need to scan\n                break;\n            }\n        }\n\n\n    }", "negative": "public void box(Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            if (type == Type.VOID_TYPE) {\n                aconst_null();\n            } else {\n                Type boxed = TypeUtils.getBoxedType(type);\n                new_instance(boxed);\n                if (type.getSize() == 2) {\n                    // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o\n                    dup_x2();\n                    dup_x2();\n                    pop();\n                } else {\n                    // p -> po -> opo -> oop -> o\n                    dup_x1();\n                    swap();\n                }\n                invoke_constructor(boxed, new Signature(Constants.CONSTRUCTOR_NAME, Type.VOID_TYPE, new Type[]{ type }));\n            }\n        }\n    }", "type": "random_negative"}
{"anchor": "<T> Initializable<T> requestInjection(\n      InjectorImpl injector,\n      T instance,\n      Binding<T> binding,\n      Object source,\n      Set<InjectionPoint> injectionPoints) {\n    checkNotNull(source);\n    Preconditions.checkState(\n        !validationStarted, \"Member injection could not be requested after validation is started\");\n    ProvisionListenerStackCallback<T> provisionCallback =\n        binding == null ? null : injector.provisionListenerStore.get(binding);\n\n    // short circuit if the object has no injections or listeners.\n    if (instance == null\n        || (injectionPoints.isEmpty()\n            && !injector.membersInjectorStore.hasTypeListeners()\n            && provisionCallback == null)) {\n      return Initializables.of(instance);\n    }\n\n    if (initializablesCache.containsKey(instance)) {\n      @SuppressWarnings(\"unchecked\") // Map from T to InjectableReference<T>\n      Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance);\n      return cached;\n    }\n\n    InjectableReference<T> injectableReference =\n        new InjectableReference<T>(\n            injector,\n            instance,\n            binding == null ? null : binding.getKey(),\n            provisionCallback,\n            source,\n            cycleDetectingLockFactory.create(instance.getClass()));\n    initializablesCache.put(instance, injectableReference);\n    pendingInjections.add(injectableReference);\n    return injectableReference;\n  }", "positive": "<T> Initializable<T> requestInjection(\n      InjectorImpl injector,\n      T instance,\n      Binding<T> binding,\n      Object source,\n      Set<InjectionPoint> injectionPoints) {\n    Objects.requireNonNull(source);\n    Preconditions.checkState(\n        !validationStarted, \"Member injection could not be requested after validation is started\");\n\n    ProvisionListenerStackCallback<T> provisionCallback =\n        (binding != null) ? injector.provisionListenerStore.get(binding) : null;\n\n    // Short-circuit when there is nothing to do.\n    boolean noInjections = instance == null\n        || (injectionPoints.isEmpty()\n            && !injector.membersInjectorStore.hasTypeListeners()\n            && provisionCallback == null);\n    if (noInjections) {\n      return Initializables.of(instance);\n    }\n\n    if (initializablesCache.containsKey(instance)) {\n      @SuppressWarnings(\"unchecked\")\n      Initializable<T> cached = (Initializable<T>) initializablesCache.get(instance);\n      return cached;\n    }\n\n    InjectableReference<T> injectableReference =\n        new InjectableReference<>(\n            injector,\n            instance,\n            binding == null ? null : binding.getKey(),\n            provisionCallback,\n            source,\n            cycleDetectingLockFactory.create(instance.getClass()));\n    initializablesCache.put(instance, injectableReference);\n    pendingInjections.add(injectableReference);\n    return injectableReference;\n  }", "type": "llm_rewrite"}
{"anchor": "public final void addAlias(String alias, String attributeName)\r\n            throws NoSuchAttributeException, AttributeExistsException {\r\n\r\n        // complain if alias name already exists in this AttributeTable.\r\n        if (_attr.get(alias) != null) {\r\n            throw new AttributeExistsException(\"Could not alias `\" + alias +\r\n                    \"' to `\" + attributeName + \"'. \" +\r\n                    \"It is a duplicat name in this AttributeTable\");\r\n        }\r\n        if (Debug.isSet(\"AttributTable\")) {\r\n            log.debug(\"Adding alias '\" + alias + \"' to AttributeTable '\" + getClearName() + \"'\");\r\n        }\r\n\r\n        Alias newAlias = new Alias(alias, attributeName);\r\n        _attr.put(alias, newAlias);\r\n    }", "negative": "private void makeTimeCoordinate2D(NetcdfFile ncfile, Group g, CoordinateTime2D time2D,\n      GribCollectionImmutable.Type gctype) {\n    CoordinateRuntime runtime = time2D.getRuntimeCoordinate();\n\n    int ntimes = time2D.getNtimes();\n    String tcName = time2D.getName();\n    String dims = runtime.getName() + \" \" + tcName;\n    int dimLength = ntimes;\n\n    ncfile.addDimension(g, new Dimension(tcName, dimLength));\n    Variable v = ncfile\n        .addVariable(g, new Variable(ncfile, g, null, tcName, DataType.DOUBLE, dims));\n    String units = runtime.getUnit(); // + \" since \" + runtime.getFirstDate();\n    v.addAttribute(new Attribute(CDM.UNITS, units));\n    v.addAttribute(new Attribute(CF.STANDARD_NAME, CF.TIME));\n    v.addAttribute(new Attribute(CDM.LONG_NAME, Grib.GRIB_VALID_TIME));\n    v.addAttribute(new Attribute(CF.CALENDAR, Calendar.proleptic_gregorian.toString()));\n\n    // the data is not generated until asked for to save space\n    if (!time2D.isTimeInterval()) {\n      v.setSPobject(new Time2Dinfo(Time2DinfoType.off, time2D, null));\n    } else {\n      v.setSPobject(new Time2Dinfo(Time2DinfoType.intv, time2D, null));\n      // bounds for intervals\n      String bounds_name = tcName + \"_bounds\";\n      Variable bounds = ncfile\n          .addVariable(g, new Variable(ncfile, g, null, bounds_name, DataType.DOUBLE, dims + \" 2\"));\n      v.addAttribute(new Attribute(CF.BOUNDS, bounds_name));\n      bounds.addAttribute(new Attribute(CDM.UNITS, units));\n      bounds.addAttribute(new Attribute(CDM.LONG_NAME, \"bounds for \" + tcName));\n      bounds.setSPobject(new Time2Dinfo(Time2DinfoType.bounds, time2D, null));\n    }\n\n  }", "type": "random_negative"}
{"anchor": "void handleMotion(int edge, float dx, float dy) {\n        Rect r = computeLayout();\n        if (edge == GROW_NONE) {\n            return;\n        } else if (edge == MOVE) {\n            // Convert to image space before sending to moveBy().\n            moveBy(dx * (mCropRect.width() / r.width()),\n                    dy * (mCropRect.height() / r.height()));\n        } else {\n            if (((GROW_LEFT_EDGE | GROW_RIGHT_EDGE) & edge) == 0) {\n                dx = 0;\n            }\n\n            if (((GROW_TOP_EDGE | GROW_BOTTOM_EDGE) & edge) == 0) {\n                dy = 0;\n            }\n\n            // Convert to image space before sending to growBy().\n            float xDelta = dx * (mCropRect.width() / r.width());\n            float yDelta = dy * (mCropRect.height() / r.height());\n            growBy((((edge & GROW_LEFT_EDGE) != 0) ? -1 : 1) * xDelta,\n                    (((edge & GROW_TOP_EDGE) != 0) ? -1 : 1) * yDelta);\n        }\n    }", "positive": "void computeHandleMotion(int param_52,  float param_58,  float tmp_75) {\n                      tmp_75 * (val_12.height() / param_14.height()));\n         obj_52 param_14 = processComputeLayout();\n        if (param_52 = =  item_35) {\n            return;\n        } else if (param_52 == var_75) {\n            / /  param_87 arg_86 item_8 item_39 item_11 var_75 arg_86 executeMoveBy().\n executeMoveBy(param_58 * (val_12.width() / param_14.width()),\n        } else {\n            if (((obj_70 | var_28) & param_52) = =  0) {\n                param_58 =  0; \n }\n  \n              if (((val_86 | param_6) & param_52) == 0) {\n tmp_75 = 0;\n }\n\n // param_87 arg_86 item_8 item_39 item_11 var_75 arg_86 processGrowBy().\n            float item_42 =  param_58 *  (val_12.width() /  param_14.width()); \n float tmp_49 = tmp_75 * (val_12.height() / param_14.height());\n processGrowBy((((param_52 & obj_70) != 0) ? -1 : 1) * item_42,\n                    (((param_52 & val_86) !=  0) ? - 1 : 1) *  tmp_49); \n        }\n    }", "type": "augment"}
{"anchor": "public boolean accept(File dir, String filename)\n\t{\n\t\tString strPath = dir.getPath().toLowerCase();\n\t\tif (strPath.indexOf(m_strOkayPath) != -1)\n\t\t\treturn true;\n\t\treturn false;\n\t}", "negative": "public static Set<Class<?>> getClasses(String packageName, boolean recursive, ClassFileFilter filter) {\n        if (packageName == null || packageName.length() == 0) {\n            throw new IllegalArgumentException(\"packageName is empty.\");\n        }\n\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        String packageDirName = packageName.replace('.', '/');\n        Collection<URL> urls;\n        try {\n            Enumeration<URL> dirs = loader.getResources(packageDirName);\n            urls = Collections.list(dirs);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        Set<Class<?>> klasses = new LinkedHashSet<Class<?>>();\n        for (URL url : urls) {\n            String protocol = url.getProtocol();\n            if (\"file\".equals(protocol)) {\n                lookupClassesInFileSystem(packageName, new File(url.getFile()), recursive, loader, filter, klasses);\n            } else if (\"jar\".equals(protocol)) {\n                lookupClassesInJar(packageName, url, recursive, loader, filter, klasses);\n            }\n        }\n        return klasses;\n    }", "type": "random_negative"}
{"anchor": "@Override\n\tpublic User deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n\t\tObjectMapper mapper = (ObjectMapper) jp.getCodec();\n\t\tJsonNode jsonNode = mapper.readTree(jp);\n\t\tSet<GrantedAuthority> authorities = mapper.convertValue(jsonNode.get(\"authorities\"), new TypeReference<Set<SimpleGrantedAuthority>>() {\n\t\t});\n\t\tJsonNode password = readJsonNode(jsonNode, \"password\");\n\t\tUser result =  new User(\n\t\t\t\treadJsonNode(jsonNode, \"username\").asText(), password.asText(\"\"),\n\t\t\t\treadJsonNode(jsonNode, \"enabled\").asBoolean(), readJsonNode(jsonNode, \"accountNonExpired\").asBoolean(),\n\t\t\t\treadJsonNode(jsonNode, \"credentialsNonExpired\").asBoolean(),\n\t\t\t\treadJsonNode(jsonNode, \"accountNonLocked\").asBoolean(), authorities\n\t\t);\n\n\t\tif (password.asText(null) == null) {\n\t\t\tresult.eraseCredentials();\n\t\t}\n\t\treturn result;\n\t}", "negative": "public Document makeDocument() {\r\n    Element rootElem = new Element(\"pointConfig\");\r\n    Document doc = new Document(rootElem);\r\n    if (tableConfigurerClass != null)\r\n      rootElem.addContent( new Element(\"tableConfigurer\").setAttribute(\"class\", tableConfigurerClass));\r\n    if (tc.featureType != null)\r\n      rootElem.setAttribute(\"featureType\", tc.featureType.toString());\r\n\r\n    rootElem.addContent(writeTable(tc));\r\n\r\n    return doc;\r\n  }", "type": "random_negative"}
{"anchor": "public static String getID(String url) {\n\n        // the document needs an ID\n        // see\n        // http://docs.aws.amazon.com/cloudsearch/latest/developerguide/preparing-data.html#creating-document-batches\n        // A unique ID for the document. A document ID can contain any\n        // letter or number and the following characters: _ - = # ; : / ? @\n        // &. Document IDs must be at least 1 and no more than 128\n        // characters long.\n        byte[] dig = digester.digest(url.getBytes(StandardCharsets.UTF_8));\n        String ID = Hex.encodeHexString(dig);\n        // is that even possible?\n        if (ID.length() > 128) {\n            throw new RuntimeException(\"ID larger than max 128 chars\");\n        }\n        return ID;\n    }", "positive": "  public static String calcGetID(String item_13) {\n\n        // arg_27 obj_9 arg_78 tmp_67 item_33\n        // arg_59\n        // item_89://var_70.aws.amazon.com/arg_91/arg_84/var_56/obj_2-var_1.html#var_47-obj_9-item_71\n        / /  val_52 param_94 item_33 for arg_27 obj_9. val_52 obj_9 item_33 param_24 var_55 val_20\n        / /  arg_72 tmp_66 val_13 arg_49 arg_27 obj_71 obj_45: val_85 -  =  # ;  : /  ? @\n // &. tmp_35 arg_1 param_100 var_93 obj_62 tmp_52 1 arg_49 obj_42 tmp_55 item_52 128\n        / /  obj_45 long.\n byte[] item_81 = obj_18.digest(item_13.getBytes(tmp_83.UTF_8));\n         String item_33 = obj_26.encodeHexString(item_81);\n        / /  tmp_98 item_16 arg_87 obj_65?\n        if (item_33.length() >  128) {  / /  Initialize variables\n throw new RuntimeException(\"item_33 arg_51 item_52 val_36 128 var_90\");\n }\n        return item_33;\n    }", "type": "augment"}
{"anchor": "private CoordinateAxis makeLonCoordAxis(NetcdfDataset ds, String axisName, Dimension dim) {\r\n    if (dim == null) return null;\r\n    double dx = 4 * findAttributeDouble(ds, \"DX\");\r\n    int nx = dim.getLength();\r\n    double startx = centerX - dx * (nx - 1) / 2;\r\n\r\n    CoordinateAxis v = new CoordinateAxis1D(ds, null, axisName, DataType.DOUBLE, dim.getShortName(), \"degrees_east\", \"synthesized longitude coordinate\");\r\n    v.setValues(nx, startx, dx);\r\n    v.addAttribute(new Attribute(_Coordinate.AxisType, \"Lon\"));\r\n    if (!axisName.equals(dim.getShortName()))\r\n      v.addAttribute(new Attribute(_Coordinate.AliasForDimension, dim.getShortName()));\r\n\r\n    return v;\r\n  }", "negative": "private String extractUserId(String studentId, ResponseEntity<String> response) {\n        Configuration config = Configuration.builder().options(\n                Option.DEFAULT_PATH_LEAF_TO_NULL\n        ).build();\n        ReadContext readContext = JsonPath\n                .using(config)\n                .parse(response.getBody());\n\n        String success = readContext.read(SUCCESS_QUERY);\n        // SSP passes this as a string...\n        if (!\"true\".equalsIgnoreCase(success)) {\n            return null;\n        }\n\n        int count = readContext.read(RESULTS_QUERY, Integer.class);\n        if (count != 1) {\n            // couldn't find a single unique result.  Bail now...\n            log.warn(\"Expected a single unique result for \" + studentId + \".  Found \" + count);\n            return null;\n        }\n\n        String id = readContext.read(STUDENT_ID_QUERY);\n        return id;\n    }", "type": "random_negative"}
{"anchor": "public Line readLine(String name, int index) {\r\n\t\r\n\t\tVariable linevar = ds.findVariable(name);\r\n\t\tif(linevar == null) return null;\r\n\t\tLine line = null;\r\n\t\t\r\n\t\t// CFConvention\r\n\t\tif(ds.findGlobalAttribute(CF.CONVENTIONS) != null)\r\n\t\t\tif(ucar.nc2.dataset.conv.CF1Convention.getVersion(ds.findGlobalAttribute(CF.CONVENTIONS).getStringValue()) >= 8)\r\n\t\t\t\tline = new CFLine();\r\n\t\t\r\n\t\tif(line == null) return null;\r\n\t\telse return line.setupLine(ds, linevar, index);\r\n\t}", "negative": "public static BufferedImage convertToType(BufferedImage sourceImage, \n    int targetType)\n  {\n    BufferedImage image;\n\n    // if the source image is already the target type, return the source image\n\n    if (sourceImage.getType() == targetType)\n      image = sourceImage;\n\n    // otherwise create a new image of the target type and draw the new\n    // image \n\n    else\n    {\n      image = new BufferedImage(sourceImage.getWidth(), sourceImage.getHeight(),\n        targetType);\n      image.getGraphics().drawImage(sourceImage, 0, 0, null);\n    }\n    \n    return image;\n  }", "type": "random_negative"}
{"anchor": "public static void generate(\n        ServletWriter out,\n        Compiler compiler,\n        Node.Nodes page)\n        throws JasperException {\n\n        Generator gen = new Generator(out, compiler);\n\n        if (gen.isPoolingEnabled) {\n            gen.compileTagHandlerPoolList(page);\n        }\n        if (gen.ctxt.isTagFile()) {\n            JasperTagInfo tagInfo = (JasperTagInfo)gen.ctxt.getTagInfo();\n            gen.generateTagHandlerPreamble(tagInfo, page);\n\n            if (gen.ctxt.isPrototypeMode()) {\n                return;\n            }\n\n            gen.generateXmlProlog(page);\n            gen.fragmentHelperClass.generatePreamble();\n            page.visit(\n                gen.new GenerateVisitor(\n                    gen.ctxt.isTagFile(),\n                    out,\n                    gen.methodsBuffered,\n                    gen.fragmentHelperClass));\n            gen.generateTagHandlerPostamble(tagInfo);\n        } else {\n            gen.generatePreamble(page);\n            gen.generateXmlProlog(page);\n            gen.fragmentHelperClass.generatePreamble();\n            page.visit(\n                gen.new GenerateVisitor(\n                    gen.ctxt.isTagFile(),\n                    out,\n                    gen.methodsBuffered,\n                    gen.fragmentHelperClass));\n            gen.generatePostamble(page);\n        }\n    }", "positive": "public static void generate(\n        ServletWriter out,\n        Compiler compiler,\n        Node.Nodes page)\n        throws JasperException {\n\n    Generator gen = new Generator(out, compiler);\n\n    if (gen.isPoolingEnabled) {\n        gen.compileTagHandlerPoolList(page);\n    }\n\n    boolean isTagFile = gen.ctxt.isTagFile();\n    JasperTagInfo tagInfo = null;\n\n    if (isTagFile) {\n        tagInfo = (JasperTagInfo) gen.ctxt.getTagInfo();\n        gen.generateTagHandlerPreamble(tagInfo, page);\n\n        if (gen.ctxt.isPrototypeMode()) {\n            return;\n        }\n    } else {\n        gen.generatePreamble(page);\n    }\n\n    gen.generateXmlProlog(page);\n    gen.fragmentHelperClass.generatePreamble();\n\n    Node.Visitor visitor = gen.new GenerateVisitor(\n            isTagFile,\n            out,\n            gen.methodsBuffered,\n            gen.fragmentHelperClass);\n    page.visit(visitor);\n\n    if (isTagFile) {\n        gen.generateTagHandlerPostamble(tagInfo);\n    } else {\n        gen.generatePostamble(page);\n    }\n}", "type": "llm_rewrite"}
{"anchor": "@SuppressLint(\"DefaultLocale\")\n    private static int getHtmlColor(String color) {\n        Integer i = COLORS.get(color.toLowerCase());\n        if (i != null) {\n            return i;\n        } else {\n            try {\n                return convertValueToInt(color, -1);\n            } catch (NumberFormatException nfe) {\n                return -1;\n            }\n        }\n    }", "negative": "protected TaxonomyNode<ElkObjectProperty> getObjectPropertyTaxonomyNode(\n\t\t\tfinal ElkObjectProperty elkProperty) throws ElkException {\n\t\tfinal Taxonomy<ElkObjectProperty> propertyTaxonomy = getObjectPropertyTaxonomy();\n\t\tfinal TaxonomyNode<ElkObjectProperty> node = propertyTaxonomy\n\t\t\t\t.getNode(elkProperty);\n\t\tif (node != null) {\n\t\t\treturn node;\n\t\t}\n\t\t// else\n\t\tif (allowFreshEntities) {\n\t\t\treturn new FreshTaxonomyNode<ElkObjectProperty>(elkProperty,\n\t\t\t\t\tpropertyTaxonomy);\n\t\t}\n\t\t// else\n\t\tthrow new ElkFreshEntitiesException(elkProperty);\n\t}", "type": "random_negative"}
{"anchor": "public static String format(String messageFormat, Object... arguments) {\n    for (int i = 0; i < arguments.length; i++) {\n      arguments[i] = convert(arguments[i]);\n    }\n    return String.format(messageFormat, arguments);\n  }", "positive": "public static String format(String messageFormat, Object... arguments) {\n    int len = arguments.length;\n    for (int i = 0; i < len; i++) {\n      arguments[i] = convert(arguments[i]);\n    }\n    return String.format(messageFormat, arguments);\n  }", "type": "llm_rewrite"}
{"anchor": "public static int readVInt(InputStream in) throws IOException {\n        byte b = (byte)in.read();\n\n        if(b == (byte) 0x80)\n            throw new RuntimeException(\"Attempting to read null value as int\");\n\n        int value = b & 0x7F;\n        while ((b & 0x80) != 0) {\n          b = (byte)in.read();\n          value <<= 7;\n          value |= (b & 0x7F);\n        }\n\n        return value;\n    }", "negative": "static void printClassTaxonomy(Taxonomy<ElkClass> taxonomy, File out)\n\t\t\tthrows IOException {\n\t\tFileWriter fstream = null;\n\t\tBufferedWriter writer = null;\n\n\t\ttry {\n\t\t\tfstream = new FileWriter(out);\n\t\t\twriter = new BufferedWriter(fstream);\n\n\t\t\twriter.append(\"Ontology(\\n\");\n\n\t\t\tprocessTaxomomy(taxonomy, writer);\n\n\t\t\twriter.append(\")\\n\");\n\t\t\twriter.flush();\n\n\t\t} finally {\n\t\t\tIOUtils.closeQuietly(fstream);\n\t\t\tIOUtils.closeQuietly(writer);\n\t\t}\n\t}", "type": "random_negative"}
{"anchor": "public static String backslashToDAP(String bs) {\n    StringBuilder buf = new StringBuilder();\n    int len = bs.length();\n    for (int i = 0; i < len; i++) {\n      char c = bs.charAt(i);\n      if (i < (len - 1) && c == '\\\\') {\n        c = bs.charAt(++i);\n      }\n      if (_allowableInDAP.indexOf(c) < 0) {\n        buf.append(_URIEscape);\n        // convert the char to hex\n        String ashex = Integer.toHexString((int) c);\n        if (ashex.length() < 2) buf.append('0');\n        buf.append(ashex);\n      } else\n        buf.append(c);\n    }\n    return buf.toString();\n  }", "negative": "public void writeToFile(final File destination) {\n\t\tInputStream input = null;\n\t\tfinal OutputStream output;\n\t\ttry {\n\t\t\tinput = getDataSource().getInputStream();\n\t\t\toutput = new FileOutputStream(destination);\n\n\t\t\tStreamUtil.copy(input, output);\n\t\t}\n\t\tcatch (final IOException ioex) {\n\t\t\tthrow new MailException(ioex);\n\t\t}\n\t\tfinally {\n\t\t\tStreamUtil.close(input);\n\t\t}\n\t}", "type": "random_negative"}
{"anchor": "public List<CssSelector> parse() {\n\t\ttry {\n\t\t\tlexer.yylex();\n\t\t\tif (lexer.selectors.isEmpty()) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// fixes last combinator\n\t\t\tCssSelector last = lexer.selectors.get(lexer.selectors.size() - 1);\n\t\t\tif (last.getCombinator() == Combinator.DESCENDANT) {\n\t\t\t\tlast.setCombinator(null);\n\t\t\t}\n\n\t\t\t// set previous css selector\n\t\t\tCssSelector prevCssSelector = null;\n\t\t\tfor (CssSelector cssSelector : lexer.selectors) {\n\t\t\t\tif (prevCssSelector != null) {\n\t\t\t\t\tcssSelector.setPrevCssSelector(prevCssSelector);\n\t\t\t\t}\n\t\t\t\tprevCssSelector = cssSelector;\n\t\t\t}\n\n\t\t\treturn lexer.selectors;\n\t\t} catch (IOException ioex) {\n\t\t\tthrow new CSSellyException(ioex);\n\t\t}\n\t}", "positive": "public List<CssSelector> parse() {\n    try {\n        lexer.yylex();\n        List<CssSelector> selectors = lexer.selectors;\n        if (selectors.isEmpty()) {\n            return null;\n        }\n\n        CssSelector last = selectors.get(selectors.size() - 1);\n        if (last.getCombinator() == Combinator.DESCENDANT) {\n            last.setCombinator(null);\n        }\n\n        for (int i = 1; i < selectors.size(); i++) {\n            selectors.get(i).setPrevCssSelector(selectors.get(i - 1));\n        }\n\n        return selectors;\n    } catch (IOException ioex) {\n        throw new CSSellyException(ioex);\n    }\n}", "type": "llm_rewrite"}
{"anchor": "protected void\n    build()\n            throws DapException\n    {\n        String methodurl = buildURL(this.xuri.assemble(XURI.URLONLY), DATASUFFIX, this.dmr, this.basece);\n\n        InputStream stream;\n        // Make the request and return an input stream for accessing the databuffer\n        // Should fill in bigendian and stream fields\n        stream = callServer(methodurl);\n\n        try {\n            ChunkInputStream reader;\n            if(DEBUG) {\n                byte[] raw = DapUtil.readbinaryfile(stream);\n                ByteArrayInputStream bis = new ByteArrayInputStream(raw);\n                DapDump.dumpbytestream(raw, getOrder(), \"httpdsp.build\");\n                reader = new ChunkInputStream(bis, RequestMode.DAP, getOrder());\n            } else {\n                // Wrap the input stream as a ChunkInputStream\n                reader = new ChunkInputStream(stream, RequestMode.DAP, getOrder());\n            }\n\n            // Extract and \"compile\" the server response\n            String document = reader.readDMR();\n            // Extract all the remaining bytes\n            byte[] bytes = DapUtil.readbinaryfile(reader);\n            // use super.build to compile\n            super.build(document, bytes, getOrder());\n        } catch (Throwable t) {\n            t.printStackTrace();\n            throw new DapException(t);\n        } finally {\n            try {\n                stream.close();\n            } catch (IOException ioe) {/*ignore*/}\n        }\n    }", "negative": "public static JSONObject generateUserMessage(String userId, JSONObject message){\n        JSONObject json = new JSONObject();\n        try {\n            JSONObject packet = new JSONObject();\n            packet.put(PnRTCMessage.JSON_USERMSG, message);\n            json.put(PnRTCMessage.JSON_PACKET, packet);\n            json.put(PnRTCMessage.JSON_ID, \"\"); //Todo: session id, unused in js SDK?\n            json.put(PnRTCMessage.JSON_NUMBER, userId);\n        } catch (JSONException e){\n            e.printStackTrace();\n        }\n        return json;\n    }", "type": "random_negative"}
{"anchor": "public Response synchronizeWithDb(DesignDocument document) {\n\t\tassertNotEmpty(document, \"Document\");\n\t\tDesignDocument documentFromDb = null;\n\t\ttry {\n\t\t\tdocumentFromDb = getFromDb(document.getId());\n\t\t} catch (NoDocumentException e) {\n\t\t\treturn dbc.save(document);\n\t\t}\n\t\tif(!document.equals(documentFromDb)) { \n\t\t\tdocument.setRevision(documentFromDb.getRevision());\n\t\t\treturn dbc.update(document);\n\t\t}\n\t\treturn null;\n\t}", "negative": "public static Method prefixMethodOfBeanByField(String prefix, Class<?> clazz, Field field,\n                                                   Class<?>... argTypes) {\n        Method method = null;\n        String fieldName = field.getName();\n        StringBuilder builder = new StringBuilder(prefix);\n        builder.append(fieldName.substring(0, 1).toUpperCase());\n        builder.append(fieldName.substring(1, fieldName.length()));\n        String methodName = builder.toString();\n        try {\n            method = clazz.getDeclaredMethod(methodName, argTypes);\n        } catch (SecurityException e) {\n        } catch (NoSuchMethodException e) {\n        }\n        return method;\n    }", "type": "random_negative"}
{"anchor": "private boolean exportRegionByArg(FunctionContext<String[]> fc)\r\n\t{\r\n\t\t\r\n\t\t  String[] args = fc.getArguments();\r\n\t\t    \r\n\t\t    if(args == null || args.length == 0)\r\n\t\t    {\r\n\t\t    \tthrow new FunctionException(\"Argument not provided\");\r\n\t\t    }\r\n\t\t    \r\n\t\t\t\r\n\t\t//Get region name from arguments\r\n\t\tString regionName = Organizer.at(0,args);\r\n\t\tif (regionName == null || regionName.length() == 0)\r\n\t\t\tthrow new FunctionException(\"regionName is required at argumeng index 0\");\r\n\t\t\r\n\t\tCache cache = CacheFactory.getAnyInstance();\r\n\t\t\r\n\t\tRegion<Object,Object> region = cache.getRegion(regionName);\r\n\r\n\t\treturn exportRegion(region,Organizer.at(1, args));\r\n\t\r\n\t}", "positive": "private boolean processExportRegionByArg(var_6<String[]> tmp_98)\r\n\t{\r\n\t\t\r\n\t\t  String[] args = tmp_98.getArguments();\r\n\t\t    \r\n\t\t    if(args == null || args.length == 0)\r\n\t\t    {\r\n\t\t    \tthrow new computeFunctionException(\"item_36 var_31 obj_53\");\r\n\t\t    }\r\n\t\t    \r\n\t\t\t\r\n\t\t//var_43 var_1 obj_86 arg_91 obj_74\r\n\t\tString val_70 = obj_23.at(0,args);\r\n\t\tif (val_70 == null || val_70.length() == 0)\r\n\t\t\tthrow new computeFunctionException(\"val_70 var_76 item_4 arg_36 obj_54 item_29 0\");\r\n\t\t\r\n\t\targ_56 param_42 = arg_42.getAnyInstance();\r\n\t\t\r\n\t\ttmp_96<Object,Object> var_1 = param_42.getRegion(val_70);\r\n\r\n\t\treturn processExportRegion(var_1,obj_23.at(1, args));\r\n\t\r\n\t}", "type": "augment"}
{"anchor": "public static boolean validateAgaintIPAdressV4Format(final String input) {\n\t\tif (input == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint hitDots = 0;\n\t\tchar[] data = input.toCharArray();\n\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\tchar c = data[i];\n\t\t\tint b = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tb = (b * 10 + c) - 48;\n\t\t\t\tif (++i >= data.length) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tc = data[i];\n\t\t\t} while (c != '.');\n\n\t\t\tif (b > 255) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\thitDots++;\n\t\t}\n\n\t\treturn hitDots == 4;\n\t}", "positive": "public static boolean calcValidateAgaintIPAdressV4Format(final String obj_56) {\n\t\tif (obj_56 == null)\n{\n return false;\n\t\t}\n\n\t\tint var_77 =  0; \n char[] param_31 = obj_56.toCharArray();\n\t\tfor (int val_65 =  0;  val_65 <  param_31.length;  val_65+ + )\n{\n\t\t\tchar val_11 = param_31[val_65];\n\t\t\tint item_25 = 0;\n\t\t\tdo {\n\t\t\t\tif (val_11 <  '0' || val_11 >  '9')\n{\n return false;\n\t\t\t\t}\n\t\t\t\titem_25 =  (item_25 *  10 +  val_11) -  48; \n  \t\t\t\tif (++val_65 >= param_31.length)\n{\n break;\n\t\t\t\t}\n\t\t\t\tval_11 =  param_31[val_65]; \n\t\t\t} while (val_11 != '.');\n\n if (item_25 > 255)\n{\n \t\t\t\treturn false;\n\t\t\t}\n \t\t\tvar_77++;\n\t\t}\n\n \t\treturn var_77 == 4;\n }", "type": "augment"}
{"anchor": "private static BufferedImage displayVideoAtCorrectTime(long streamStartTime,\n      final MediaPicture picture, final MediaPictureConverter converter,\n      BufferedImage image, final ImageFrame window, long systemStartTime,\n      final Rational systemTimeBase, final Rational streamTimebase)\n      throws InterruptedException {\n    long streamTimestamp = picture.getTimeStamp();\n    // convert streamTimestamp into system units (i.e. nano-seconds)\n    streamTimestamp = systemTimeBase.rescale(streamTimestamp-streamStartTime, streamTimebase);\n    // get the current clock time, with our most accurate clock\n    long systemTimestamp = System.nanoTime();\n    // loop in a sleeping loop until we're within 1 ms of the time for that video frame.\n    // a real video player needs to be much more sophisticated than this.\n    while (streamTimestamp > (systemTimestamp - systemStartTime + 1000000)) {\n      Thread.sleep(1);\n      systemTimestamp = System.nanoTime();\n    }\n    // finally, convert the image from Humble format into Java images.\n    image = converter.toImage(image, picture);\n    // And ask the UI thread to repaint with the new image.\n    window.setImage(image);\n    return image;\n  }", "positive": "private static BufferedImage displayVideoAtCorrectTime(long streamStartTime,\n      final MediaPicture picture, final MediaPictureConverter converter,\n      BufferedImage image, final ImageFrame window, long systemStartTime,\n      final Rational systemTimeBase, final Rational streamTimebase)\n      throws InterruptedException {\n    long streamTimestamp = picture.getTimeStamp();\n    // convert streamTimestamp into system units (i.e. nano-seconds)\n    streamTimestamp = systemTimeBase.rescale(streamTimestamp - streamStartTime, streamTimebase);\n    // compute the absolute system deadline (nano time) we should wait until\n    final long deadline = streamTimestamp + systemStartTime - 1_000_000L;\n    // busy-wait with short sleeps until we've reached the target time\n    while (System.nanoTime() < deadline) {\n      Thread.sleep(1);\n    }\n    // convert the image from Humble format into Java images.\n    image = converter.toImage(image, picture);\n    // And ask the UI thread to repaint with the new image.\n    window.setImage(image);\n    return image;\n  }", "type": "llm_rewrite"}
{"anchor": "private String\n    getCompleteCE(String proj, String sel)\n    {\n        if(proj != null && proj.length() == 0) proj = \"\";  // canonical\n        if(sel != null && sel.length() == 0) sel = null;  // canonical\n        StringBuilder buf = new StringBuilder();\n        if(proj.startsWith(\"?\"))\n            buf.append(proj.substring(1));\n        else\n            buf.append(proj);\n        if(sel != null) {\n            if(sel.startsWith(\"&\"))\n                buf.append(sel);\n            else {\n                buf.append(\"&\");\n                buf.append(sel);\n            }\n        }\n        return getCompleteCE(buf.toString());\n    }", "negative": "@SuppressWarnings(\"unchecked\")\n\tprivate void setKey(final P pojo, final IncompleteKey key, final LoadContext ctx, final Path containerPath) {\n\t\tif (!clazz.isAssignableFrom(pojo.getClass()))\n\t\t\tthrow new IllegalArgumentException(\"Trying to use metadata for \" + clazz.getName() + \" to set key of \" + pojo.getClass().getName());\n\n\t\t// If no key, don't need to do anything\n\t\tif (key == null)\n\t\t\treturn;\n\n\t\tidMeta.setValue(pojo, Keys.getIdValue(key), ctx, containerPath);\n\n\t\tfinal com.google.cloud.datastore.Key parentKey = key.getParent();\n\t\tif (parentKey != null) {\n\t\t\tif (this.parentMeta == null)\n\t\t\t\tthrow new IllegalStateException(\"Loaded Entity has parent but \" + clazz.getName() + \" has no @Parent\");\n\n\t\t\tparentMeta.setValue(pojo, (Value)KeyValue.of(parentKey), ctx, containerPath);\n\t\t}\n\t}", "type": "random_negative"}
{"anchor": "public static Byte[] toObject(byte... a)\n\t{\n\t\tif (a != null) {\n\t\t\tByte[] w = new Byte[a.length];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\tw[i] = a[i];\n\t\t\t}\n\t\t\treturn w;\n\t\t}\n\t\treturn null;\n\t}", "positive": "public static Byte[] toObject(byte... a) {\n    if (a == null) {\n        return null;\n    }\n    Byte[] result = new Byte[a.length];\n    for (int i = 0; i < a.length; i++) {\n        result[i] = Byte.valueOf(a[i]);\n    }\n    return result;\n}", "type": "llm_rewrite"}
{"anchor": "public void addComponentInterceptors(List<InterceptorFactory> factory, int priority, boolean publicOnly) {\n        for (Method method : (Iterable<Method>)classIndex.getClassMethods()) {\n            if (publicOnly && !Modifier.isPublic(method.getModifiers())) {\n                continue;\n            }\n            OrderedItemContainer<List<InterceptorFactory>> interceptors = componentInterceptors.get(method);\n            if (interceptors == null) {\n                componentInterceptors.put(method, interceptors = new OrderedItemContainer<List<InterceptorFactory>>());\n            }\n            interceptors.add(factory, priority);\n        }\n    }", "negative": "private long copy(InputStream in, OutputStream out) throws IOException {\r\n      long totalBytesRead = 0;\r\n      byte[] buffer = new byte[8000];\r\n      while (true) {\r\n        int bytesRead = in.read(buffer);\r\n        if (bytesRead == -1) break;\r\n        out.write(buffer, 0, bytesRead);\r\n        totalBytesRead += bytesRead;\r\n      }\r\n      return totalBytesRead;\r\n    }", "type": "random_negative"}
{"anchor": "static String generateDigest(boolean passwordAlreadyEncoded, String username,\n\t\t\tString realm, String password, String httpMethod, String uri, String qop,\n\t\t\tString nonce, String nc, String cnonce) throws IllegalArgumentException {\n\t\tString a1Md5;\n\t\tString a2 = httpMethod + \":\" + uri;\n\t\tString a2Md5 = md5Hex(a2);\n\n\t\tif (passwordAlreadyEncoded) {\n\t\t\ta1Md5 = password;\n\t\t}\n\t\telse {\n\t\t\ta1Md5 = DigestAuthUtils.encodePasswordInA1Format(username, realm, password);\n\t\t}\n\n\t\tString digest;\n\n\t\tif (qop == null) {\n\t\t\t// as per RFC 2069 compliant clients (also reaffirmed by RFC 2617)\n\t\t\tdigest = a1Md5 + \":\" + nonce + \":\" + a2Md5;\n\t\t}\n\t\telse if (\"auth\".equals(qop)) {\n\t\t\t// As per RFC 2617 compliant clients\n\t\t\tdigest = a1Md5 + \":\" + nonce + \":\" + nc + \":\" + cnonce + \":\" + qop + \":\"\n\t\t\t\t\t+ a2Md5;\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"This method does not support a qop: '\"\n\t\t\t\t\t+ qop + \"'\");\n\t\t}\n\n\t\treturn md5Hex(digest);\n\t}", "negative": "static public MFileOS getExistingFile(String filename) {\r\n    if (filename == null) return null;\r\n    File file = new File(filename);\r\n    if (file.exists()) return new MFileOS(file);\r\n    return null;\r\n  }", "type": "random_negative"}
{"anchor": "DapAttribute\n    makeAttribute(DapSort sort, String name, DapType basetype,\n                  List<String> nslist, DapNode parent)\n            throws DapException\n    {\n        DapAttribute attr = new DapAttribute(name, basetype);\n        if(sort == DapSort.ATTRIBUTE) {\n            attr.setBaseType(basetype);\n        }\n        parent.addAttribute(attr);\n        attr.setNamespaceList(nslist);\n        return attr;\n    }", "positive": "DapAttribute\n    makeAttribute(DapSort sort, String name, DapType basetype,\n                  List<String> nslist, DapNode parent)\n            throws DapException\n    {\n        final DapAttribute attr = new DapAttribute(name, basetype);\n        if (sort == DapSort.ATTRIBUTE) {\n            attr.setBaseType(basetype);\n        }\n        parent.addAttribute(attr);\n        attr.setNamespaceList(nslist);\n        return attr;\n    }", "type": "llm_rewrite"}
{"anchor": "private Value<D> getPropertyFromContainer(final FullEntity<?> container, final Path containerPath) {\n\t\tString foundName = null;\n\t\tValue<D> value = null;\n\n\t\tfor (String name: property.getLoadNames()) {\n\t\t\tif (container.contains(name)) {\n\t\t\t\tif (foundName != null)\n\t\t\t\t\tthrow new IllegalStateException(\"Collision trying to load field; multiple name matches for '\"\n\t\t\t\t\t\t\t+ property.getName() + \"' at '\" + containerPath.extend(foundName) + \"' and '\" + containerPath.extend(name) + \"'\");\n\n\t\t\t\t//noinspection unchecked\n\t\t\t\tvalue = container.getValue(name);\n\t\t\t\tfoundName = name;\n\t\t\t}\n\t\t}\n\n\t\tif (foundName == null)\n\t\t\tthrow new SkipException();\n\t\telse\n\t\t\treturn value;\n\t}", "negative": "public static Sort sorts( Sort... sorts ) {\n        if ( sorts == null || sorts.length == 0 ) {\n            return null;\n        }\n\n        Sort main = sorts[ 0 ];\n        for ( int index = 1; index < sorts.length; index++ ) {\n            main.then( sorts[ index ] );\n        }\n        return main;\n    }", "type": "random_negative"}
{"anchor": "public static DMatrixRMaj convert(ConicGeneral_F64 src , DMatrixRMaj dst )\n\t{\n\t\tif( dst == null )\n\t\t\tdst = new DMatrixRMaj(3,3);\n\t\telse\n\t\t\tdst.reshape(3,3);\n\n\t\tdouble B = src.B/2.0;\n\t\tdouble D = src.D/2.0;\n\t\tdouble E = src.E/2.0;\n\n\t\tdst.data[0] = src.A; dst.data[1] = B;     dst.data[2] = D;\n\t\tdst.data[3] = B;     dst.data[4] = src.C; dst.data[5] = E;\n\t\tdst.data[6] = D;     dst.data[7] = E;     dst.data[8] = src.F;\n\n\t\treturn dst;\n\t}", "negative": "public ImageApiProfile merge(ImageApiProfile other) {\n    ImageApiProfile merged = new ImageApiProfile();\n    streamNotNull(this.features).forEach(merged::addFeature);\n    streamNotNull(other.features).forEach(merged::addFeature);\n    streamNotNull(this.formats).forEach(merged::addFormat);\n    streamNotNull(other.formats).forEach(merged::addFormat);\n    streamNotNull(this.qualities).forEach(merged::addQuality);\n    streamNotNull(other.qualities).forEach(merged::addQuality);\n    if (this.maxWidth != null && other.maxWidth == null) {\n      merged.maxWidth = this.maxWidth;\n    } else if (this.maxWidth == null && other.maxWidth != null) {\n      merged.maxWidth = other.maxWidth;\n    } else if (this.maxWidth != null) {\n      merged.maxWidth = Math.min(this.maxWidth, other.maxWidth);\n    }\n    if (this.maxHeight != null && other.maxHeight == null) {\n      merged.maxHeight = this.maxHeight;\n    } else if (this.maxHeight == null && other.maxHeight != null) {\n      merged.maxHeight = other.maxHeight;\n    } else if (this.maxHeight != null) {\n      merged.maxHeight = Math.min(this.maxHeight, other.maxHeight);\n    }\n    if (this.maxArea != null && other.maxArea == null) {\n      merged.maxArea = this.maxArea;\n    } else if (this.maxArea == null && other.maxArea != null) {\n      merged.maxArea = other.maxArea;\n    } else if (this.maxArea != null) {\n      merged.maxArea = Math.min(this.maxArea, other.maxArea);\n    }\n    return merged;\n  }", "type": "random_negative"}
{"anchor": "public void addPoint(double x, double y) {\r\n\t\tPoint ptPrev = null;\r\n\t\t\r\n\t\tif(points.size() > 0) {\r\n\t\t\tptPrev = points.get(points.size() - 1);\r\n\t\t}\r\n\t\t\r\n\t\tthis.points.add(new CFPoint(x, y, ptPrev, null, null));\r\n\t\t\r\n\t}", "positive": "public void handleAddPoint(double param_94,  double var_68) {\r\n\t\tval_35 var_70 = null;\r\n\t\t\r\n\t\tif(val_16.size() >  0)\n{\r\n\t\t\tvar_70 =  val_16.get(val_16.size() -  1); \r\n } \n\t\t\r\n\t\tthis.val_16.add(new computeCFPoint(param_94, var_68, var_70, null, null));\r\n \n }", "type": "augment"}
{"anchor": "public static String toHex(int[] arr) {\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < arr.length; ++i) {\n            buf.append(Integer.toHexString((arr[i] >> 28) & 0x0000000f));\n            buf.append(Integer.toHexString((arr[i] >> 24) & 0x0000000f));\n            buf.append(Integer.toHexString((arr[i] >> 20) & 0x0000000f));\n            buf.append(Integer.toHexString((arr[i] >> 16) & 0x0000000f));\n            buf.append(Integer.toHexString((arr[i] >> 12) & 0x0000000f));\n            buf.append(Integer.toHexString((arr[i] >> 8) & 0x0000000f));\n            buf.append(Integer.toHexString((arr[i] >> 4) & 0x0000000f));\n            buf.append(Integer.toHexString((arr[i]) & 0x0000000f));\n        }\n        return buf.toString();\n    }", "negative": "private static final boolean checkDouble(String s)\n    {\n        try {\n            //Coverity[FB.DLS_DEAD_LOCAL_STORE]\n            double val = Double.parseDouble(s);\n            if(DebugValueChecking) {\n                DAPNode.log.debug(\"Attribute.checkDouble() - string: '\" + s + \"'   value: \" + val);\n            }\n            return true;\n        } catch (NumberFormatException e) {\n            if(s.equalsIgnoreCase(\"nan\") || s.equalsIgnoreCase(\"inf\"))\n                return true;\n\n            return false;\n        }\n    }", "type": "random_negative"}
{"anchor": "protected int getReplicaCount(KubernetesListBuilder builder, ResourceConfig xmlResourceConfig, int defaultValue) {\n        if (xmlResourceConfig != null) {\n            List<HasMetadata> items = builder.buildItems();\n            for (HasMetadata item : items) {\n                if (item instanceof Deployment) {\n                    if(((Deployment)item).getSpec().getReplicas() != null) {\n                        return ((Deployment)item).getSpec().getReplicas();\n                    }\n                }\n                if (item instanceof DeploymentConfig) {\n                    if(((DeploymentConfig)item).getSpec().getReplicas() != null) {\n                        return ((DeploymentConfig)item).getSpec().getReplicas();\n                    }\n                }\n            }\n            return xmlResourceConfig.getReplicas() > 0 ? xmlResourceConfig.getReplicas() : defaultValue;\n        }\n        return defaultValue;\n    }", "positive": "protected int getReplicaCount(KubernetesListBuilder builder, ResourceConfig xmlResourceConfig, int defaultValue) {\n    if (xmlResourceConfig == null) {\n        return defaultValue;\n    }\n\n    List<HasMetadata> items = builder.buildItems();\n    for (HasMetadata item : items) {\n        if (item instanceof Deployment) {\n            Integer replicas = ((Deployment) item).getSpec().getReplicas();\n            if (replicas != null) {\n                return replicas;\n            }\n        } else if (item instanceof DeploymentConfig) {\n            Integer replicas = ((DeploymentConfig) item).getSpec().getReplicas();\n            if (replicas != null) {\n                return replicas;\n            }\n        }\n    }\n\n    return xmlResourceConfig.getReplicas() > 0 ? xmlResourceConfig.getReplicas() : defaultValue;\n}", "type": "llm_rewrite"}
{"anchor": "public String chooseFilename() {\r\n    if (!readOk) return null;\r\n    selectedFile = false;\r\n    //selectedURL = false;\r\n    w.setVisible(true); // modal, so blocks; listener calls hide(), which unblocks.\r\n\r\n    if (selectedFile) {\r\n      File file = chooser.getSelectedFile();\r\n      if (file == null) return null;\r\n      try {\r\n        return file.getCanonicalPath().replace('\\\\', '/');\r\n      } catch (IOException ioe) {\r\n      } // return null\r\n    }\r\n\r\n    /* if (selectedURL) {\r\n      return (String) urlComboBox.getSelectedItem();\r\n    }  */\r\n\r\n    return null;\r\n  }", "positive": "public String chooseFilename() {\n    if (!readOk) return null;\n\n    selectedFile = false;\n    w.setVisible(true); // modal; listener will set selectedFile and hide\n\n    if (!selectedFile) return null;\n\n    File file = chooser.getSelectedFile();\n    if (file == null) return null;\n\n    try {\n        String path = file.getCanonicalPath();\n        return path != null ? path.replace('\\\\', '/') : null;\n    } catch (IOException ioe) {\n        // match original behavior: ignore and return null\n        return null;\n    }\n}", "type": "llm_rewrite"}
{"anchor": "public static String getNextProductVersion(String version) throws PluginExecutionException {\n        String result = null;\n        int versionSplittingIndex = version.lastIndexOf(\".\") + 1;\n        if (versionSplittingIndex == 0) {\n            throw new PluginExecutionException(\"Product version \" + version\n                    + \" is not in the expected format. It must have period separated version segments.\");\n        }\n        String quarterVersion = version.substring(versionSplittingIndex);\n        int nextQuarterSpecifier;\n        try {\n            nextQuarterSpecifier = Integer.parseInt(quarterVersion) + 1;\n        } catch (NumberFormatException e) {\n            throw new PluginExecutionException(\"Product version \" + version\n                    + \" is not in the expected format. Its last segment is expected to be an integer.\", e);\n        }\n        result = version.substring(0, versionSplittingIndex) + nextQuarterSpecifier;\n        return result;\n    }", "negative": "public static String backslashToDAP(String bs) {\n    StringBuilder buf = new StringBuilder();\n    int len = bs.length();\n    for (int i = 0; i < len; i++) {\n      char c = bs.charAt(i);\n      if (i < (len - 1) && c == '\\\\') {\n        c = bs.charAt(++i);\n      }\n      if (_allowableInDAP.indexOf(c) < 0) {\n        buf.append(_URIEscape);\n        // convert the char to hex\n        String ashex = Integer.toHexString((int) c);\n        if (ashex.length() < 2) buf.append('0');\n        buf.append(ashex);\n      } else\n        buf.append(c);\n    }\n    return buf.toString();\n  }", "type": "random_negative"}
{"anchor": "private void writeResponseHeaderToRecordHeader(Response response, Record.Header header) {\n    for (Map.Entry<String, List<String>> entry : response.getStringHeaders().entrySet()) {\n      if (!entry.getValue().isEmpty()) {\n        String firstValue = entry.getValue().get(0);\n        header.setAttribute(conf.headerAttributePrefix + entry.getKey(), firstValue);\n      }\n    }\n  }", "positive": "private void writeResponseHeaderToRecordHeader(Response response, Record.Header header) {\n    final String prefix = conf.headerAttributePrefix;\n    Map<String, List<String>> headers = response.getStringHeaders();\n    for (Map.Entry<String, List<String>> entry : headers.entrySet()) {\n      List<String> values = entry.getValue();\n      if (!values.isEmpty()) {\n        header.setAttribute(prefix + entry.getKey(), values.get(0));\n      }\n    }\n  }", "type": "llm_rewrite"}
{"anchor": "private boolean matches(byte[] expected, byte[] actual) {\n\t\tif (expected.length != actual.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint result = 0;\n\t\tfor (int i = 0; i < expected.length; i++) {\n\t\t\tresult |= expected[i] ^ actual[i];\n\t\t}\n\t\treturn result == 0;\n\t}", "positive": "private boolean matches(byte[] expected, byte[] actual) {\n\t\tif (expected == actual) {\n\t\t\treturn true;\n\t\t}\n\t\tif (expected.length != actual.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tint diff = 0;\n\t\tfor (int i = 0; i < expected.length; i++) {\n\t\t\tdiff |= expected[i] ^ actual[i];\n\t\t}\n\t\treturn diff == 0;\n\t}", "type": "llm_rewrite"}
{"anchor": "public static boolean evalBoolExpression(\r\n\t\t\tfinal ExpressionEngine expEngine, final String pscript) {\r\n\t\tObject result = null;\r\n\t\tString script = \"( \" + pscript + \" )\";\r\n\t\tscript = script.toUpperCase().replace(\"AND\", \"&&\");\r\n\t\tscript = script.toUpperCase().replace(\"OR\", \"||\");\r\n\t\ttry {\r\n\t\t\tresult = expEngine.evaluate(script);\r\n\t\t} catch (Exception e) {\r\n\t\t\tLOG.log(Level.SEVERE,\r\n\t\t\t\t\t\"WebForm WebFormHelper evalBoolExpression script = \"\r\n\t\t\t\t\t\t\t+ script + \"; error = \"\r\n\t\t\t\t\t\t\t+ e.getLocalizedMessage(),\r\n\t\t\t\t\te);\r\n\t\t}\r\n\t\tif (result != null) {\r\n\t\t\treturn ((Boolean) result).booleanValue();\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}", "negative": "public static List<MimeType> parseMimeTypes(String mimeTypes) {\n        if (!StringUtils.hasLength(mimeTypes)) {\n            return Collections.emptyList();\n        }\n        String[] tokens = mimeTypes.split(\",\\\\s*\");\n        List<MimeType> result = new ArrayList<MimeType>(tokens.length);\n        for (String token : tokens) {\n            result.add(parseMimeType(token));\n        }\n        return result;\n    }", "type": "random_negative"}
{"anchor": "public Map extract(Map target, final String[] profiles, final String[] wildcardPatterns, String prefix) {\n\t\tif (target == null) {\n\t\t\ttarget = new HashMap();\n\t\t}\n\n\t\t// make sure prefix ends with a dot\n\t\tif (prefix != null) {\n\t\t\tif (!StringUtil.endsWithChar(prefix, '.')) {\n\t\t\t\tprefix += StringPool.DOT;\n\t\t\t}\n\t\t}\n\n\t\tif (profiles != null) {\n\t\t\tfor (String profile : profiles) {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal Map<String, PropsEntry> map = this.profileProperties.get(profile);\n\t\t\t\t\tif (map != null) {\n\t\t\t\t\t\textractMap(target, map, profiles, wildcardPatterns, prefix);\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal int ndx = profile.lastIndexOf('.');\n\t\t\t\t\tif (ndx == -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tprofile = profile.substring(0, ndx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\textractMap(target, this.baseProperties, profiles, wildcardPatterns, prefix);\n\n\t\treturn target;\n\t}", "positive": "public Map extract(Map target, final String[] profiles, final String[] wildcardPatterns, String prefix) {\n    if (target == null) {\n        target = new HashMap();\n    }\n\n    if (prefix != null && !StringUtil.endsWithChar(prefix, '.')) {\n        prefix += StringPool.DOT;\n    }\n\n    if (profiles != null) {\n        for (String profile : profiles) {\n            String current = profile;\n            while (true) {\n                final Map<String, PropsEntry> map = this.profileProperties.get(current);\n                if (map != null) {\n                    extractMap(target, map, profiles, wildcardPatterns, prefix);\n                }\n\n                final int ndx = current.lastIndexOf('.');\n                if (ndx == -1) {\n                    break;\n                }\n                current = current.substring(0, ndx);\n            }\n        }\n    }\n\n    extractMap(target, this.baseProperties, profiles, wildcardPatterns, prefix);\n\n    return target;\n}", "type": "llm_rewrite"}
{"anchor": "ImmutableList<SingleMemberInjector> getInjectors(\n      Set<InjectionPoint> injectionPoints, Errors errors) {\n    List<SingleMemberInjector> injectors = Lists.newArrayList();\n    for (InjectionPoint injectionPoint : injectionPoints) {\n      try {\n        Errors errorsForMember =\n            injectionPoint.isOptional()\n                ? new Errors(injectionPoint)\n                : errors.withSource(injectionPoint);\n        SingleMemberInjector injector =\n            injectionPoint.getMember() instanceof Field\n                ? new SingleFieldInjector(this.injector, injectionPoint, errorsForMember)\n                : new SingleMethodInjector(this.injector, injectionPoint, errorsForMember);\n        injectors.add(injector);\n      } catch (ErrorsException ignoredForNow) {\n        // ignored for now\n      }\n    }\n    return ImmutableList.copyOf(injectors);\n  }", "positive": "var_46<val_47> executeGetInjectors(\n      Set<val_96> val_100, arg_62 param_86) {\n        tmp_41.add(item_49);\n                : param_86.withSource(arg_45);\n                : new calcSingleMethodInjector(this.item_49, arg_45, arg_33);\n    List<val_47> tmp_41 = var_9.newArrayList();\n    for (val_96 arg_45 : val_100) {\n      try {\n        arg_62 arg_33 =\n            arg_45.isOptional()\n                ? new computeErrors(arg_45)\n        val_47 item_49 =\n            arg_45.getMember() instanceof tmp_22  // Handle edge case\n                ? new processSingleFieldInjector(this.item_49, arg_45, arg_33)\n      } catch (var_18 tmp_56) {\n        // param_16 for var_86\n      }\n    }\n    return var_46.copyOf(tmp_41);\n  }  // Return the result", "type": "augment"}
{"anchor": "protected void downgradeAusblickElements(Document doc) throws JaxenException {\n        List nodes = XmlUtils.newXPath(\n                \"/io:openimmo/io:anbieter/io:immobilie/io:infrastruktur/io:ausblick[@blick]\",\n                doc).selectNodes(doc);\n        for (Object item : nodes) {\n            Element node = (Element) item;\n            String value = StringUtils.trimToNull(node.getAttribute(\"blick\"));\n            if (\"MEER\".equalsIgnoreCase(value))\n                node.setAttribute(\"blick\", \"SEE\");\n        }\n    }", "positive": "protected void downgradeAusblickElements(Document doc) throws JaxenException {\n    List<?> nodes = XmlUtils.newXPath(\n            \"/io:openimmo/io:anbieter/io:immobilie/io:infrastruktur/io:ausblick[@blick]\",\n            doc).selectNodes(doc);\n    for (Object item : nodes) {\n        if (!(item instanceof Element)) continue;\n        Element node = (Element) item;\n        String value = StringUtils.trimToNull(node.getAttribute(\"blick\"));\n        if (\"MEER\".equalsIgnoreCase(value)) {\n            node.setAttribute(\"blick\", \"SEE\");\n        }\n    }\n}", "type": "llm_rewrite"}
{"anchor": "public static INDArray invert(INDArray arr, boolean inPlace) {\n        if (!arr.isSquare()) {\n            throw new IllegalArgumentException(\"invalid array: must be square matrix\");\n        }\n\n        //FIX ME: Please\n       /* int[] IPIV = new int[arr.length() + 1];\n        int LWORK = arr.length() * arr.length();\n        INDArray WORK = Nd4j.create(new double[LWORK]);\n        INDArray inverse = inPlace ? arr : arr.dup();\n        Nd4j.getBlasWrapper().lapack().getrf(arr);\n        Nd4j.getBlasWrapper().lapack().getri(arr.size(0),inverse,arr.size(0),IPIV,WORK,LWORK,0);*/\n\n        RealMatrix rm = CheckUtil.convertToApacheMatrix(arr);\n        RealMatrix rmInverse = new LUDecomposition(rm).getSolver().getInverse();\n\n\n        INDArray inverse = CheckUtil.convertFromApacheMatrix(rmInverse);\n        if (inPlace)\n            arr.assign(inverse);\n        return inverse;\n\n    }", "negative": "private static final boolean checkDouble(String s)\n    {\n        try {\n            //Coverity[FB.DLS_DEAD_LOCAL_STORE]\n            double val = Double.parseDouble(s);\n            if(DebugValueChecking) {\n                DAPNode.log.debug(\"Attribute.checkDouble() - string: '\" + s + \"'   value: \" + val);\n            }\n            return true;\n        } catch (NumberFormatException e) {\n            if(s.equalsIgnoreCase(\"nan\") || s.equalsIgnoreCase(\"inf\"))\n                return true;\n\n            return false;\n        }\n    }", "type": "random_negative"}
{"anchor": "public String get_keyword_documentation(String keyword) {\n        if (keyword.equalsIgnoreCase(\"stop_remote_server\")) {\n            return \"Stops the remote server.\\n\\nThe server may be configured so that users cannot stop it.\";\n        }\n        try {\n            String doc = servlet.getLibrary().getKeywordDocumentation(keyword);\n            return doc == null ? \"\" : doc;\n        } catch (Throwable e) {\n            log.warn(\"\", e);\n            throw new RuntimeException(e);\n        }\n    }", "negative": "public final List<ParameterizedTemplateModel> findReferencesTo(final File templateDir, final File templateFile) {\r\n\r\n        final List<ParameterizedTemplateModel> result = new ArrayList<ParameterizedTemplateModel>();\r\n        if ((paramTemplates != null) && Utils4J.fileInsideDirectory(templateDir, templateFile)) {\r\n            for (final ParameterizedTemplateModel paramTemplate : paramTemplates) {\r\n                if (paramTemplate.hasReferenceTo(templateDir, templateFile)) {\r\n                    result.add(paramTemplate);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }", "type": "random_negative"}
{"anchor": "private void configureApplication() {\n        if (m_appName != null) {\n            QApplication.setApplicationName(m_appName);\n        } else {\n            QApplication.setApplicationName(\"akquinet ChameRIA\");\n        }\n        if (m_appVersion != null) {\n            QApplication.setApplicationVersion(m_appVersion);\n        } else {\n            QApplication.setApplicationVersion(m_context.getBundle().getVersion().toString());\n        }\n\n        if (m_icon != null) {\n            QFile file = new QFile(m_icon);\n\n            QIcon icon = new QIcon(file.fileName());\n            QApplication.setWindowIcon(icon);\n        }\n\n        QApplication.setOrganizationName(\"akquinet A.G.\");\n\n        // Configure the proxy\n        if (m_proxyType != null) {\n            m_logger.warn(\"Set application proxy : \" + m_proxyType);\n            if (m_proxyHostName == null || m_proxyPort == 0) {\n                m_logger.error(\"Cannot configure proxy : hostname or port not set : \" + m_proxyHostName + \":\" + m_proxyPort);\n            } else {\n                QNetworkProxy proxy = new QNetworkProxy(m_proxyType, m_proxyHostName, m_proxyPort);\n                QNetworkProxy.setApplicationProxy(proxy);\n                m_logger.warn(\"Application proxy set \" + m_proxyType + \" on \" + m_proxyHostName + \":\" + m_proxyPort);\n            }\n        }\n\n    }", "negative": "public static void main1( String[] args )\n  {\n    // Test case 2: local data files.\n    String collectionPath = \"C:/Ethan/data/mlode\";\n    String startPath = \"grid/NCEP\";\n    String catWriteDirPath = \"C:/Ethan/data/tmpTest\";\n\n    if ( args.length == 3 )\n    {\n      collectionPath = args[0];\n      startPath = args[1];\n      catWriteDirPath = args[2];\n    }\n\n    File catWriteDir = new File( catWriteDirPath );\n\n    File collectionFile = new File( collectionPath );\n    CrawlableDataset collectionCrDs = new CrawlableDatasetFile( collectionFile );\n    InvService service = new InvService( \"myServer\", \"File\", collectionCrDs.getPath() + \"/\", null, null);\n    CrawlableDatasetFilter filter = null;\n    CrawlableDataset topCatCrDs = collectionCrDs.getDescendant( startPath );\n\n    CatGenAndWrite cgaw = new CatGenAndWrite( \"DATA\", \"My data\", \"\", service,\n                                              collectionCrDs, topCatCrDs, filter, null, catWriteDir );\n\n    try\n    {\n      cgaw.genCatAndSubCats( topCatCrDs );\n    }\n    catch ( IOException e )\n    {\n      log.error( \"I/O error generating and writing catalogs at and under \\\"\" + topCatCrDs.getPath() + \"\\\": \" + e.getMessage());\n      return;\n    }\n\n  }", "type": "random_negative"}
{"anchor": "@Override\n\tpublic String visit(IndexedClass element) {\n\t\tElkClass entity = element.getElkEntity();\n\t\tif (entity.getIri().equals(PredefinedElkIris.OWL_THING)) {\n\t\t\treturn \"\u22a4\";\n\t\t}\n\t\t// else\n\t\tif (entity.getIri().equals(PredefinedElkIris.OWL_NOTHING)) {\n\t\t\treturn \"\u22a5\";\n\t\t}\n\t\t// else\n\t\treturn entity.toString();\n\t}", "positive": "@Override\npublic String visit(IndexedClass element) {\n    ElkClass entity = element.getElkEntity();\n    Object iri = entity.getIri();\n    if (iri.equals(PredefinedElkIris.OWL_THING)) {\n        return \"\u22a4\";\n    }\n    if (iri.equals(PredefinedElkIris.OWL_NOTHING)) {\n        return \"\u22a5\";\n    }\n    return entity.toString();\n}", "type": "llm_rewrite"}
{"anchor": "private void removeObjectPool(final ProfileTableImpl profileTable) {\n\t\tfinal ProfileObjectPool objectPool = pools.remove(profileTable.getProfileTableName());\n\t\tif (objectPool != null) {\n\t\t\ttry {\n\t\t\t\tobjectPool.close();\n\t\t\t} catch (Exception e) {\n\t\t\t\tlogger.error(\"failed to close pool\",e);\n\t\t\t}\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Removed Pool for \" + profileTable);\n\t\t}\n\t}", "positive": "private void removeObjectPool(final ProfileTableImpl profileTable) {\n    final String name = profileTable.getProfileTableName();\n    final ProfileObjectPool objectPool = pools.remove(name);\n    if (objectPool != null) {\n        try {\n            objectPool.close();\n        } catch (Exception e) {\n            logger.error(\"failed to close pool\", e);\n        }\n    }\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Removed Pool for \" + profileTable);\n    }\n}", "type": "llm_rewrite"}
{"anchor": "public ProjectionPoint latLonToProj(LatLonPoint latlon, ProjectionPointImpl destPoint) {\r\n    double lat = latlon.getLatitude();\r\n    double lon = latlon.getLongitude();\r\n\r\n    //\tLon-lat pair to xyz coordinates on sphere with radius 1\r\n    double[] p0 = new double[]\r\n            {Math.cos(lat * RAD_PER_DEG) * Math.cos(lon * RAD_PER_DEG),\r\n                    Math.cos(lat * RAD_PER_DEG) * Math.sin(lon * RAD_PER_DEG),\r\n                    Math.sin(lat * RAD_PER_DEG)};\r\n\r\n    //\tRotate around Z-axis\r\n    double[] p1 = new double[]\r\n            {rotZ[0][0] * p0[0] + rotZ[0][1] * p0[1] + rotZ[0][2] * p0[2],\r\n                    rotZ[1][0] * p0[0] + rotZ[1][1] * p0[1] + rotZ[1][2] * p0[2],\r\n                    rotZ[2][0] * p0[0] + rotZ[2][1] * p0[1] + rotZ[2][2] * p0[2]};\r\n\r\n    //\tRotate around Y-axis\r\n    double[] p2 = new double[]\r\n            {rotY[0][0] * p1[0] + rotY[0][1] * p1[1] + rotY[0][2] * p1[2],\r\n                    rotY[1][0] * p1[0] + rotY[1][1] * p1[1] + rotY[1][2] * p1[2],\r\n                    rotY[2][0] * p1[0] + rotY[2][1] * p1[1] + rotY[2][2] * p1[2]};\r\n\r\n    final double lonR = LatLonPointImpl.range180( Math.atan2(p2[1], p2[0]) * DEG_PER_RAD);\r\n    //final double lonR = Math.atan2(p2[1], p2[0]) * DEG_PER_RAD;\r\n    final double latR = Math.asin(p2[2]) * DEG_PER_RAD;\r\n\r\n    if (destPoint == null)\r\n      destPoint =  new ProjectionPointImpl(lonR, latR);\r\n    else\r\n      destPoint.setLocation(lonR, latR);\r\n\r\n     if (show)\r\n        System.out.println(\"LatLon= \" + latlon+\" proj= \" + destPoint);\r\n\r\n    return destPoint;\r\n  }", "negative": "private String createFxmlPath(Class<?> viewType) {\n        final StringBuilder pathBuilder = new StringBuilder();\n\n        final FxmlPath pathAnnotation = viewType.getDeclaredAnnotation(FxmlPath.class); //Get annotation from view\n        final String fxmlPath = Optional.ofNullable(pathAnnotation)\n                .map(FxmlPath::value)\n                .map(String::trim)\n                .orElse(\"\");\n\n        if (fxmlPath.isEmpty()) {\n            pathBuilder.append(\"/\");\n\n            if (viewType.getPackage() != null) {\n                pathBuilder.append(viewType.getPackage().getName().replaceAll(\"\\\\.\", \"/\"));\n                pathBuilder.append(\"/\");\n            }\n\n            pathBuilder.append(viewType.getSimpleName());\n            pathBuilder.append(\".fxml\");\n        } else {\n            pathBuilder.append(fxmlPath);\n        }\n\n        return pathBuilder.toString();\n    }", "type": "random_negative"}
{"anchor": "public double[][] projToLatLon(double[][] from, double[][] to) {\r\n    int cnt = from[0].length;\r\n    double[] fromXA = from[INDEX_X];\r\n    double[] fromYA = from[INDEX_Y];\r\n    double[] toLatA = to[INDEX_LAT];\r\n    double[] toLonA = to[INDEX_LON];\r\n\r\n    double toLat, toLon;\r\n    for (int i = 0; i < cnt; i++) {\r\n      double fromX = fromXA[i];\r\n      double fromY = fromYA[i];\r\n\r\n      double x = (fromX - falseEasting) / scale;\r\n      double d = (fromY - falseNorthing) / scale + lat0;\r\n      toLon = Math.toDegrees(lon0 + Math.atan2(Math.sinh(x), Math.cos(d)));\r\n      toLat = Math.toDegrees(Math.asin(Math.sin(d) / Math.cosh(x)));\r\n\r\n      toLatA[i] = (double) toLat;\r\n      toLonA[i] = (double) toLon;\r\n    }\r\n    return to;\r\n  }", "negative": "public void renderTable()\n    {\n        for (int i = 0; i < tableModel.getRowCount(); i++)\n        {\n            int colOffset = 0;\n\n            for (int j = 0; j < tableModel.getColumnCount(); j++)\n            {\n                // Print the contents of the table cell.\n                String valueToPrint = tableModel.get(j, i);\n                valueToPrint = (valueToPrint == null) ? \"\" : valueToPrint;\n                gridModel.insert(valueToPrint, colOffset, i);\n\n                // Pad spaces up to the column width if the contents are shorted.\n                Integer maxColumnSize = tableModel.getMaxColumnSize(j);\n                int spaces = maxColumnSize - valueToPrint.length();\n\n                while (spaces > 0)\n                {\n                    gridModel.insert(\" \", colOffset + valueToPrint.length() + spaces-- - 1, i);\n                }\n\n                // Shift to the next column.\n                colOffset += maxColumnSize;\n            }\n        }\n    }", "type": "random_negative"}
{"anchor": "private boolean isGroup(DStructure dstruct) {\n    BaseType parent = (BaseType) dstruct.getParent();\n    if (parent == null) return true;\n    if (parent instanceof DStructure)\n      return isGroup((DStructure) parent);\n    return true;\n  }", "positive": "private boolean isGroup(DStructure dstruct) {\n    BaseType parent = (BaseType) dstruct.getParent();\n    while (parent != null) {\n        if (!(parent instanceof DStructure)) {\n            return true;\n        }\n        parent = (BaseType) ((DStructure) parent).getParent();\n    }\n    return true;\n}", "type": "llm_rewrite"}
{"anchor": "public static String textXML(String xml) {\n\t\tif(xml == null) return \"\";\n\t\tString content = xml;\n\t\tcontent = content.replaceAll(\"<\", \"&lt;\");\n\t\tcontent = content.replaceAll(\">\", \"&gt;\");\n\t\tcontent = content.replaceAll(\"\\\"\", \"&quot;\");\n\t\tcontent = content.replaceAll(\"\\n\", \"</br>\");\n\t\treturn content;\n\t}", "positive": "public static String textXML(String xml) {\n    if (xml == null) return \"\";\n    StringBuilder sb = new StringBuilder(xml.length());\n    for (int i = 0, n = xml.length(); i < n; i++) {\n        char c = xml.charAt(i);\n        switch (c) {\n            case '<':\n                sb.append(\"&lt;\");\n                break;\n            case '>':\n                sb.append(\"&gt;\");\n                break;\n            case '\"':\n                sb.append(\"&quot;\");\n                break;\n            case '\\n':\n                sb.append(\"</br>\");\n                break;\n            default:\n                sb.append(c);\n        }\n    }\n    return sb.toString();\n}", "type": "llm_rewrite"}
{"anchor": "public static void homogenizeIndexes(final List<Value<?>> list) {\n\t\tif (isIndexHomogeneous(list))\n\t\t\treturn;\n\n\t\tfor (int i=0; i<list.size(); i++) {\n\t\t\tfinal Value<?> value = list.get(i);\n\t\t\tif (value.excludeFromIndexes())\n\t\t\t\tlist.set(i, index(value, true));\n\t\t}\n\t}", "positive": "public static void homogenizeIndexes(final List<Value<?>> list) {\n    if (isIndexHomogeneous(list)) {\n        return;\n    }\n\n    for (ListIterator<Value<?>> it = list.listIterator(); it.hasNext();) {\n        Value<?> value = it.next();\n        if (value.excludeFromIndexes()) {\n            it.set(index(value, true));\n        }\n    }\n}", "type": "llm_rewrite"}
{"anchor": "public static InternetAddress[] convert(final EmailAddress[] addresses) throws MessagingException {\n\t\tif (addresses == null) {\n\t\t\treturn new InternetAddress[0];\n\t\t}\n\n\t\tfinal int numRecipients = addresses.length;\n\t\tfinal InternetAddress[] address = new InternetAddress[numRecipients];\n\n\t\tfor (int i = 0; i < numRecipients; i++) {\n\t\t\taddress[i] = addresses[i].toInternetAddress();\n\t\t}\n\t\treturn address;\n\t}", "negative": "public Collection<RosterGroup> getGroups() {\n        List<RosterGroup> results = new ArrayList<RosterGroup>();\n        // Loop through all roster groups and find the ones that contain this\n        // entry. This algorithm should be fine\n        for (RosterGroup group : roster.getGroups()) {\n            if (group.contains(this)) {\n                results.add(group);\n            }\n        }\n        return Collections.unmodifiableCollection(results);\n    }", "type": "random_negative"}
{"anchor": "private ConfigCatalog readCatalog(String catalogRelPath, String catalogFullPath)  {\n    URI uri;\n    try {\n      // uri = new URI(\"file:\" + StringUtil2.escape(catalogFullPath, \"/:-_.\")); // needed ?\n      uri = new URI(this.contextPath + \"/catalog/\" + catalogRelPath);\n    } catch (URISyntaxException e) {\n      logCatalogInit.error(ERROR + \"readCatalog(): URISyntaxException=\" + e.getMessage());\n      return null;\n    }\n\n    ConfigCatalogBuilder builder = new ConfigCatalogBuilder();\n    try {\n      // read the catalog\n      logCatalogInit.info(\"-------readCatalog(): path=\" + catalogRelPath);\n      ConfigCatalog cat = (ConfigCatalog) builder.buildFromLocation(catalogFullPath, uri);\n      if (builder.hasFatalError()) {\n        logCatalogInit.error(ERROR + \"   invalid catalog -- \" + builder.getErrorMessage());\n        return null;\n      }\n\n      if (builder.getErrorMessage().length() > 0)\n        logCatalogInit.debug(builder.getErrorMessage());\n\n      return cat;\n\n    } catch (Throwable t) {\n      logCatalogInit.error(ERROR + \"  Exception on catalog=\" + catalogFullPath + \" \" + t.getMessage() + \"\\n log=\" + builder.getErrorMessage(), t);\n      return null;\n    }\n  }", "negative": "void writeIndex(Filer filer) {\n\t\tStandardLocation location = StandardLocation.SOURCE_OUTPUT;\n\t\tFileObject indexFile;\n\t\ttry {\n\t\t\tindexFile = filer.createResource(location, \"com.turbomanage.storm\",\n\t\t\t\t\tENV_FILE);\n\t\t\tOutputStream fos = indexFile.openOutputStream();\n\t\t\tPrintWriter out = new PrintWriter(fos);\n\t\t\t// Dump converters\n\t\t\tout.println(BEGIN_CONVERTERS);\n\t\t\tfor (ConverterModel converter : converters) {\n\t\t\t\tconverter.writeToIndex(out);\n\t\t\t}\n\t\t\tout.println(END_CONVERTERS);\n\t\t\t// Dump databases\n\t\t\tfor (DatabaseModel dbModel : dbModels.values()) {\n\t\t\t\tdbModel.writeToIndex(out);\n\t\t\t}\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}", "type": "random_negative"}
{"anchor": "public synchronized void deregisterEntityClasses(final String iPackageName, final ClassLoader iClassLoader) {\r\n    OLogManager.instance().debug(this, \"Discovering entity classes inside package: %s\", iPackageName);\r\n\r\n    List<Class<?>> classes = null;\r\n    try {\r\n      classes = OReflectionHelper.getClassesFor(iPackageName, iClassLoader);\r\n    } catch (ClassNotFoundException e) {\r\n      throw OException.wrapException(new ODatabaseException(\"Class cannot be found in package \" + iPackageName), e);\r\n    }\r\n    for (Class<?> c : classes) {\r\n      deregisterEntityClass(c);\r\n    }\r\n\r\n    if (OLogManager.instance().isDebugEnabled()) {\r\n      for (Entry<String, Class<?>> entry : classHandler.getClassesEntrySet()) {\r\n        OLogManager.instance().debug(this, \"Unloaded entity class '%s' from: %s\", entry.getKey(), entry.getValue());\r\n      }\r\n    }\r\n  }", "negative": "@SuppressLint(\"DefaultLocale\")\n    private static int getHtmlColor(String color) {\n        Integer i = COLORS.get(color.toLowerCase());\n        if (i != null) {\n            return i;\n        } else {\n            try {\n                return convertValueToInt(color, -1);\n            } catch (NumberFormatException nfe) {\n                return -1;\n            }\n        }\n    }", "type": "random_negative"}
{"anchor": "protected int count(UserCustomCursor cursor) {\n        int count = 0;\n        try {\n            count = cursor.getCount();\n        } finally {\n            cursor.close();\n        }\n        return count;\n    }", "positive": "protected int count(UserCustomCursor cursor) {\n    try {\n        return cursor.getCount();\n    } finally {\n        cursor.close();\n    }\n}", "type": "llm_rewrite"}
{"anchor": "private QueryState markComputed(final IndexedClassExpression queryClass) {\n\t\tfinal QueryState state = indexed_.get(queryClass);\n\t\tif (state == null || state.isComputed) {\n\t\t\treturn null;\n\t\t}\n\t\tstate.isComputed = true;\n\t\tLOGGER_.trace(\"query computed {}\", queryClass);\n\t\treturn state;\n\t}", "negative": "public static void consumeStream(final InputStream input, final BuffersPool buffersPool) throws IOException {\n    // do not use skip, just use a buffer and read it all\n    final byte[] buffer = buffersPool == null\n        ? new byte[BUFFER_SIZE_8K]\n        : buffersPool.get(BUFFER_SIZE_8K);\n\n    try {\n      //noinspection StatementWithEmptyBody\n      while (input.read(buffer) != EOF);\n    } finally {\n      closeQuietly(input);\n\n      if (buffersPool != null) {\n        buffersPool.release(buffer);\n      }\n    }\n\n  }", "type": "random_negative"}
{"anchor": "public boolean writeFile(File file, List<String> lines){\r\n\t\tif(file.exists()){\r\n\t\t\tfile.delete();\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tFileWriter out = new FileWriter(file);\r\n\t\t\tfor(String s : lines){\r\n\t\t\t\tout.write(s);\r\n\t\t\t\tout.write(System.getProperty(\"line.separator\"));\r\n\t\t\t}\r\n\t\t\tout.close();\r\n\t\t\tfile.setExecutable(true);\r\n\t\t}\r\n\t\tcatch (IOException ex) {\r\n\t\t\tSystem.err.println(this.getAppName() + \": IO exception while writing to file - \" + file + \" with message: \" + ex.getMessage());\r\n\t\t\treturn false;\r\n\t\t} \r\n\t\treturn true;\r\n\t}", "negative": "public boolean sync() {\n    try {\n      if (!mcGridReader.init()) {\n        return false;\n      }\n      GridIndex index = mcGridReader.getGridIndex();\n      // reconstruct the ncfile objects\n      ncfile.empty();\n      open(index, null);\n      return true;\n\n    } catch (IOException ioe) {\n      return false;\n    }\n  }", "type": "random_negative"}
{"anchor": "static public String backslashEscapeCDMString(String s, String toescape)\n    {\n      if(toescape == null || toescape.length() == 0) return s;\n      if(s == null || s.length() == 0) return s;\n      StringBuilder buf = new StringBuilder();\n      for(int i=0;i<s.length();i++) {\n        int c = s.charAt(i);\n        if(toescape.indexOf(c) >= 0) {\n          buf.append('\\\\');\n        }\n        buf.append((char)c);\n      }\n      return buf.toString();\n    }", "negative": "public static Set<Class<?>> getClasses(String packageName, boolean recursive, ClassFileFilter filter) {\n        if (packageName == null || packageName.length() == 0) {\n            throw new IllegalArgumentException(\"packageName is empty.\");\n        }\n\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        String packageDirName = packageName.replace('.', '/');\n        Collection<URL> urls;\n        try {\n            Enumeration<URL> dirs = loader.getResources(packageDirName);\n            urls = Collections.list(dirs);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n        Set<Class<?>> klasses = new LinkedHashSet<Class<?>>();\n        for (URL url : urls) {\n            String protocol = url.getProtocol();\n            if (\"file\".equals(protocol)) {\n                lookupClassesInFileSystem(packageName, new File(url.getFile()), recursive, loader, filter, klasses);\n            } else if (\"jar\".equals(protocol)) {\n                lookupClassesInJar(packageName, url, recursive, loader, filter, klasses);\n            }\n        }\n        return klasses;\n    }", "type": "random_negative"}
{"anchor": "public boolean remove(Object object) {\n    \t\n    \tsleeContainer.getTransactionManager().mandateTransaction();\n        \n    \tif(logger.isDebugEnabled()) {\n        \tlogger.debug(\"removing sbb local object \" + object);\n        }\n        \n        if (object == null)\n            throw new NullPointerException(\"Null arg for remove \");\n        \n        if (!(object instanceof SbbLocalObject))\n            return false;\n        \n    \tfinal SbbLocalObjectImpl sbbLocalObjectImpl = (SbbLocalObjectImpl) object;\n        if(!idBelongsToChildRelation(sbbLocalObjectImpl.getSbbEntityId()) && !sbbLocalObjectImpl.getSbbEntity().isRemoved()) {\n        \treturn false;\n        }\n        else {\n        \tsbbLocalObjectImpl.remove();\n        \treturn true;\n        }\n    }", "positive": "public boolean remove(Object object) {\n    sleeContainer.getTransactionManager().mandateTransaction();\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"removing sbb local object \" + object);\n    }\n\n    if (object == null) {\n        throw new NullPointerException(\"Null arg for remove \");\n    }\n\n    if (!(object instanceof SbbLocalObject)) {\n        return false;\n    }\n\n    SbbLocalObjectImpl sbbLocalObjectImpl = (SbbLocalObjectImpl) object;\n    boolean belongsToChild = idBelongsToChildRelation(sbbLocalObjectImpl.getSbbEntityId());\n    if (!belongsToChild && !sbbLocalObjectImpl.getSbbEntity().isRemoved()) {\n        return false;\n    }\n\n    sbbLocalObjectImpl.remove();\n    return true;\n}", "type": "llm_rewrite"}
{"anchor": "public boolean removeMemberVariable( Variable v) {\n    if (isImmutable()) throw new IllegalStateException(\"Cant modify\");\n    if (v == null) return false;\n    //smembers = null;\n    java.util.Iterator<Variable> iter = members.iterator();\n    while (iter.hasNext()) {\n      Variable mv =  iter.next();\n      if (mv.getShortName().equals(v.getShortName())) {\n        iter.remove();\n        memberHash.remove( v.getShortName());\n        return true;\n      }\n    }\n    return false;\n  }", "negative": "public void clear() {\n        modCount++;\n        HashEntry[] data = this.data;\n        for (int i = data.length - 1; i >= 0; i--) {\n            data[i] = null;\n        }\n        size = 0;\n    }", "type": "random_negative"}
{"anchor": "public static void sort( List list, String sortBy, Map<String, FieldAccess> fields, boolean ascending,\n                             boolean nullsFirst) {\n\n        try {\n\n\n            /* If this list is null or empty, we have nothing to do so return. */\n            if ( list == null || list.size() == 0 ) {\n                return;\n            }\n\n            /* Grab the first item in the list and see what it is. */\n            Object o = list.get( 0 );\n\n            /* if the sort by string is is this, and the object is comparable then use the objects\n            themselves for the sort.\n             */\n            if ( sortBy.equals( \"this\" )  ) {\n\n                Collections.sort(list, thisUniversalComparator(ascending, nullsFirst));\n                return;\n            }\n\n            /* If you did not sort by \"this\", then sort by the field. */\n\n            final FieldAccess field = fields.get( sortBy );\n\n            if ( field != null ) {\n\n                Collections.sort( list, Sorting.universalComparator(field, ascending, nullsFirst) );\n\n            }\n\n        } catch (Exception ex) {\n            Exceptions.handle(ex, \"list\", list, \"\\nsortBy\", sortBy, \"fields\", fields, \"ascending\", ascending,\n            \"nullFirst\", nullsFirst);\n        }\n    }", "positive": "public static void sort( List list, String sortBy, Map<String, FieldAccess> fields, boolean ascending,\n                         boolean nullsFirst) {\n    try {\n        if (list == null || list.isEmpty()) {\n            return;\n        }\n\n        if (sortBy.equals(\"this\")) {\n            Collections.sort(list, thisUniversalComparator(ascending, nullsFirst));\n            return;\n        }\n\n        final FieldAccess field = fields.get(sortBy);\n        if (field != null) {\n            Collections.sort(list, Sorting.universalComparator(field, ascending, nullsFirst));\n        }\n    } catch (Exception ex) {\n        Exceptions.handle(ex, \"list\", list, \"\\nsortBy\", sortBy, \"fields\", fields, \"ascending\", ascending,\n                \"nullFirst\", nullsFirst);\n    }\n}", "type": "llm_rewrite"}
{"anchor": "public final void commit()\n    {\n        int frameLength = buffer.capacity();\n        if (ByteOrder.nativeOrder() != LITTLE_ENDIAN)\n        {\n            frameLength = Integer.reverseBytes(frameLength);\n        }\n\n        buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength);\n    }", "positive": "public final void commit()\n     {\n        buffer.putIntOrdered(FRAME_LENGTH_FIELD_OFFSET, frameLength);\n        int frameLength =  buffer.capacity(); \n          if (ByteOrder.nativeOrder() != LITTLE_ENDIAN)\n        {\n            frameLength =  Integer.reverseBytes(frameLength); \n        }\n  \n }", "type": "augment"}
{"anchor": "public void pushComponentCounters(String name, PerformanceCountersHolder holder) {\n    if (snapshot == null)\n      return;\n\n    final PerformanceCountersHolder countersHolder = snapshot.countersByComponent.get(name);\n\n    if (countersHolder != null) {\n      countersHolder.pushData(holder);\n    }\n  }", "negative": "public boolean verifyMatches(Matches matches) {\n        int lenLimit = Math.min(getAvail(), matchLenMax);\n\n        for (int i = 0; i < matches.count; ++i)\n            if (getMatchLen(matches.dist[i], lenLimit) != matches.len[i])\n                return false;\n\n        return true;\n    }", "type": "random_negative"}
{"anchor": "public static LinePolar2D_F64 polar( List<Point2D_F64> points , double weights[] , LinePolar2D_F64 ret ) {\n\n\t\tfinal int N = points.size();\n\t\tdouble totalWeight = 0;\n\t\tfor( int i = 0; i < N; i++ ) {\n\t\t\ttotalWeight += weights[i];\n\t\t}\n\n\t\tif( totalWeight == 0 )\n\t\t\treturn null;\n\n\t\tif( ret == null )\n\t\t\tret = new LinePolar2D_F64();\n\n\t\tdouble meanX = 0;\n\t\tdouble meanY = 0;\n\n\t\tfor( int i = 0; i < N; i++ ) {\n\t\t\tPoint2D_F64 p = points.get(i);\n\t\t\tdouble w = weights[i];\n\t\t\tmeanX += w*p.x;\n\t\t\tmeanY += w*p.y;\n\t\t}\n\t\tmeanX /= totalWeight;\n\t\tmeanY /= totalWeight;\n\n\t\tdouble top = 0;\n\t\tdouble bottom = 0;\n\n\t\tfor( int i = 0; i < N; i++ ) {\n\t\t\tPoint2D_F64 p = points.get(i);\n\t\t\tdouble w = weights[i];\n\t\t\tdouble dx = meanX - p.x;\n\t\t\tdouble dy = meanY - p.y;\n\n\t\t\ttop += w*dx*dy;\n\t\t\tbottom += w*(dy*dy - dx*dx);\n\t\t}\n\t\ttop /= totalWeight;\n\t\tbottom /= totalWeight;\n\n\t\tret.angle = Math.atan2(-2.0*top , bottom)/2.0;\n\t\tret.distance = (double)( meanX*Math.cos(ret.angle) + meanY*Math.sin(ret.angle));\n\n\t\treturn ret;\n\t}", "positive": "public static LinePolar2D_F64 polar( List<Point2D_F64> points , double weights[] , LinePolar2D_F64 ret ) {\n    final int N = points.size();\n\n    double totalWeight = 0.0;\n    for (int i = 0; i < N; i++) {\n        totalWeight += weights[i];\n    }\n\n    if (totalWeight == 0.0) {\n        return null;\n    }\n\n    if (ret == null) {\n        ret = new LinePolar2D_F64();\n    }\n\n    double meanX = 0.0;\n    double meanY = 0.0;\n    for (int i = 0; i < N; i++) {\n        Point2D_F64 p = points.get(i);\n        double w = weights[i];\n        meanX += w * p.x;\n        meanY += w * p.y;\n    }\n    meanX /= totalWeight;\n    meanY /= totalWeight;\n\n    double covXY = 0.0;\n    double covYYminusXX = 0.0;\n    for (int i = 0; i < N; i++) {\n        Point2D_F64 p = points.get(i);\n        double w = weights[i];\n        double dx = meanX - p.x;\n        double dy = meanY - p.y;\n        covXY += w * dx * dy;\n        covYYminusXX += w * (dy * dy - dx * dx);\n    }\n    covXY /= totalWeight;\n    covYYminusXX /= totalWeight;\n\n    ret.angle = Math.atan2(-2.0 * covXY, covYYminusXX) / 2.0;\n    ret.distance = meanX * Math.cos(ret.angle) + meanY * Math.sin(ret.angle);\n\n    return ret;\n}", "type": "llm_rewrite"}
{"anchor": "private void filterExclude() {\n        if (exclude == null || files == null) {\n            return;\n        }\n\n        Set<File> toExcludes = new HashSet<File>();\n\n        for (File file : files) {\n            Matcher matcher = exclude.matcher(file.getPath());\n            if (matcher.find()) {\n                toExcludes.add(file);\n            }\n        }\n        files.removeAll(toExcludes);\n    }", "positive": "private void performFilterExclude() {\n        if (val_81 = =  null || tmp_14 = =  null)\n{\n            return; \n         }\n\n        Set<item_68> val_70 = new var_98<item_68>();\n\n        for (item_68 var_11 : tmp_14)\n{\n obj_23 arg_17 = val_81.matcher(var_11.getPath());\n            if (arg_17.find())\n{\n                val_70.add(var_11);\n }\n        }\n        tmp_14.removeAll(val_70);\n    }", "type": "augment"}
{"anchor": "public void basic(String user, String pass) {\n        URI uri = ((URIBuilder) builder.getUri()).toURI();\n        if (uri == null) throw new IllegalStateException(\"a default URI must be set\");\n        this.basic(uri.getHost(), uri.getPort(), user, pass);\n    }", "negative": "public static List<MimeType> parseMimeTypes(String mimeTypes) {\n        if (!StringUtils.hasLength(mimeTypes)) {\n            return Collections.emptyList();\n        }\n        String[] tokens = mimeTypes.split(\",\\\\s*\");\n        List<MimeType> result = new ArrayList<MimeType>(tokens.length);\n        for (String token : tokens) {\n            result.add(parseMimeType(token));\n        }\n        return result;\n    }", "type": "random_negative"}
{"anchor": "public synchronized InputStream acquire(final DataSource source)\n        throws DataSourceException\n    {\n        InputStream ret;\n        if (data == null) {\n            if (getReference() == null) {\n                throw new IllegalStateException(\"No data or reference present\");\n            } else {\n                ret = source.getStream(getReference());\n            }\n        } else {\n            ret = new ByteArrayInputStream(data);\n        }\n        return ret;\n    }", "positive": "public synchronized InputStream acquire(final DataSource source) throws DataSourceException {\n    if (data != null) {\n        return new ByteArrayInputStream(data);\n    }\n    if (getReference() == null) {\n        throw new IllegalStateException(\"No data or reference present\");\n    }\n    return source.getStream(getReference());\n}", "type": "llm_rewrite"}
{"anchor": "public static double[] values(Double[] array) {\n\t\tdouble[] dest = new double[array.length];\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tDouble v = array[i];\n\t\t\tif (v != null) {\n\t\t\t\tdest[i] = v.doubleValue();\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}", "positive": "package Translated;\n\npublic final class ArrayUtils {\n    private ArrayUtils() {\n        // Prevent instantiation\n    }\n\n    public static double[] values(Double[] array) {\n        double[] dest = new double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Double v = array[i];\n            if (v != null) {\n                dest[i] = v.doubleValue();\n            }\n        }\n        return dest;\n    }\n}", "type": "retranslate"}
{"anchor": "public static String simpleHostname(String fullHostname) {\n        if (InetAddresses.isInetAddress(fullHostname)) {\n            return fullHostname;\n        }\n        int offset = fullHostname.indexOf('.');\n        if (offset != -1) {\n            return fullHostname.substring(0, offset);\n        }\n        return fullHostname;\n    }", "positive": "public static String simpleHostname(String fullHostname) {\n    if (InetAddresses.isInetAddress(fullHostname)) {\n        return fullHostname;\n    }\n    int idx = fullHostname.indexOf('.');\n    return idx == -1 ? fullHostname : fullHostname.substring(0, idx);\n}", "type": "llm_rewrite"}
{"anchor": "public CachedFieldValue getCachedFieldValueFrom(\n\t\t\tLong formDefIdParam,\n\t\t\tLong formContIdParam,\n\t\t\tLong formFieldIdParam)\n\t{\n\t\tif((formDefIdParam == null || formContIdParam == null) ||\n\t\t\t\tformFieldIdParam == null)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tString storageKey = this.getStorageKeyFrom(\n\t\t\t\tformDefIdParam,\n\t\t\t\tformContIdParam,\n\t\t\t\tformFieldIdParam);\n\n\t\tObject objWithKey;\n\t\ttry {\n\t\t\tobjWithKey = this.memcachedClient.get(storageKey);\n\t\t}\n\t\t//Changed for Java 1.6 compatibility...\n\t\tcatch (MemcachedException e) {\n\n\t\t\tthrow new FluidCacheException(\"Unable to get Field value for '\"+storageKey+\"'.\" +\n\t\t\t\t\t\"Contact administrator. \"+e.getMessage(),e);\n\t\t} catch (TimeoutException e) {\n\n\t\t\tthrow new FluidCacheException(\"Unable to get Field value for '\"+storageKey+\"'.\" +\n\t\t\t\t\t\"Contact administrator. \"+e.getMessage(),e);\n\t\t} catch (InterruptedException e) {\n\n\t\t\tthrow new FluidCacheException(\"Unable to get Field value for '\"+storageKey+\"'.\" +\n\t\t\t\t\t\"Contact administrator. \"+e.getMessage(),e);\n\t\t}\n\n\t\treturn this.getCacheFieldValueFromObject(objWithKey);\n\t}", "positive": "public CachedFieldValue getCachedFieldValueFrom(\n\t\t\tLong formDefIdParam,\n\t\t\tLong formContIdParam,\n\t\t\tLong formFieldIdParam)\n\t{\n\t\tif (formDefIdParam == null || formContIdParam == null || formFieldIdParam == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal String storageKey = this.getStorageKeyFrom(\n\t\t\t\tformDefIdParam,\n\t\t\t\tformContIdParam,\n\t\t\t\tformFieldIdParam);\n\n\t\tObject objWithKey;\n\t\ttry {\n\t\t\tobjWithKey = this.memcachedClient.get(storageKey);\n\t\t} catch (MemcachedException | TimeoutException | InterruptedException e) {\n\t\t\tthrow new FluidCacheException(\"Unable to get Field value for '\"+storageKey+\"'.\" +\n\t\t\t\t\t\"Contact administrator. \"+e.getMessage(), e);\n\t\t}\n\n\t\treturn this.getCacheFieldValueFromObject(objWithKey);\n\t}", "type": "llm_rewrite"}
{"anchor": "public RouteChunk add(final String newValue) {\n\t\tRouteChunk routeChunk = new RouteChunk(routes, this, newValue);\n\t\tif (children == null) {\n\t\t\tchildren = new RouteChunk[] {routeChunk};\n\t\t}\n\t\telse {\n\t\t\tchildren = ArraysUtil.append(children, routeChunk);\n\t\t}\n\t\treturn routeChunk;\n\t}", "negative": "public Exception readException(String id, InputStream in) {\n        ExceptionReader exceptionReader = (ExceptionReader) exceptionMap.get(id);\n        if (exceptionReader == null) {\n            return new UnexpectedException(id);\n        } else {\n            return exceptionReader.read(in);\n        }\n    }", "type": "random_negative"}
{"anchor": "public void eventUnreferenced() {\n\t\tActivityContextImpl ac = factory.getActivityContext(ach);\n\t\tif(ac != null) {\n\t\t\tac.activityEnded();\n\t\t}\n\t}", "positive": "public void handleEventUnreferenced() {\n\t\ttmp_82 item_66 =  item_27.getActivityContext(tmp_30); \n\t\tif(item_66 !=  null)\n{\n item_66.activityEnded();\n }\n\t}", "type": "augment"}
{"anchor": "public static BasicStroke toStroke(final String style) {\r\n        BasicStroke result = null;\r\n\r\n        if (style != null) {\r\n            float lineWidth = STROKE_DEFAULT_LINE_WIDTH;\r\n            float[] dash = { STROKE_DEFAULT_DASH_WIDTH };\r\n            float[] dot = { lineWidth };\r\n\r\n            if (style.equalsIgnoreCase(STYLE_LINE)) {\r\n                result = new BasicStroke(lineWidth);\r\n            } else if (style.equalsIgnoreCase(STYLE_DASH)) {\r\n                result = new BasicStroke(lineWidth, BasicStroke.CAP_BUTT,\r\n                        BasicStroke.JOIN_MITER,\r\n                        STROKE_MITER_LIMIT_STYLE_DASH, dash,\r\n                        STROKE_DEFAULT_DASHPHASE);\r\n            } else if (style.equalsIgnoreCase(STYLE_DOT)) {\r\n                result = new BasicStroke(lineWidth, BasicStroke.CAP_BUTT,\r\n                        BasicStroke.JOIN_MITER,\r\n                        STROKE_MITER_LIMIT_STYLE_DOT, dot,\r\n                        STROKE_DEFAULT_DASHPHASE);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }", "positive": "public static BasicStroke toStroke(final String style) {\n    if (style == null) {\n        return null;\n    }\n\n    final float lineWidth = STROKE_DEFAULT_LINE_WIDTH;\n\n    if (style.equalsIgnoreCase(STYLE_LINE)) {\n        return new BasicStroke(lineWidth);\n    } else if (style.equalsIgnoreCase(STYLE_DASH)) {\n        float[] dash = { STROKE_DEFAULT_DASH_WIDTH };\n        return new BasicStroke(lineWidth, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER,\n                STROKE_MITER_LIMIT_STYLE_DASH, dash, STROKE_DEFAULT_DASHPHASE);\n    } else if (style.equalsIgnoreCase(STYLE_DOT)) {\n        float[] dot = { lineWidth };\n        return new BasicStroke(lineWidth, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER,\n                STROKE_MITER_LIMIT_STYLE_DOT, dot, STROKE_DEFAULT_DASHPHASE);\n    }\n\n    return null;\n}", "type": "llm_rewrite"}
{"anchor": "public static boolean hasActiveQuorum(\n        final ClusterMember[] clusterMembers, final long nowMs, final long timeoutMs)\n    {\n        int threshold = quorumThreshold(clusterMembers.length);\n\n        for (final ClusterMember member : clusterMembers)\n        {\n            if (member.isLeader() || nowMs <= (member.timeOfLastAppendPositionMs() + timeoutMs))\n            {\n                if (--threshold <= 0)\n                {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }", "negative": "public <X extends FSTStruct> StructArray<X> newArray(int size, X templ, BytezAllocator alloc) {\n        StructArray<X> aTemplate = new StructArray<X>(size, templ);\n        int siz = getFactory().calcStructSize(aTemplate);\n        try {\n            if ( siz < chunkSize )\n                return newStruct(aTemplate);\n            else {\n                return getFactory().toStruct(aTemplate,alloc);\n            }\n        } catch (Throwable e) {\n            throw new RuntimeException(e);\n        }\n    }", "type": "random_negative"}
{"anchor": "public static BitSet toBitSet(int value) {\n        if (value > Byte.MAX_VALUE || value < Byte.MIN_VALUE) {\n            throw new IllegalArgumentException(\n                \"The value \" + value + \" is out of byte range, should be limited between [\"\n                        + Byte.MIN_VALUE + \"] to [\" + Byte.MAX_VALUE + \"]\");\n        }\n        BitSet bs = new BitSet();\n        int index = 0;\n        while (value != 0) {\n            if (value % 2 != 0) {\n                bs.set(index);\n            }\n            ++index;\n            value = (byte) (value >> 1);\n        }\n        return bs;\n    }", "negative": "public static String from(BufferedImage qrcodeImage) {\n        final LuminanceSource source = new BufferedImageLuminanceSource(qrcodeImage);\n        final BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));\n        String content;\n        try {\n            Result result = new QRCodeReader().decode(bitmap);\n            content = result.getText();\n        } catch (NotFoundException e) {\n            throw new RuntimeException(e);\n        } catch (ChecksumException e) {\n            throw new RuntimeException(e);\n        } catch (FormatException e) {\n            throw new RuntimeException(e);\n        }\n        return content;\n    }", "type": "random_negative"}
{"anchor": "@Nullable\n    public BraintreeError errorFor(String field) {\n        BraintreeError returnError;\n        if (mFieldErrors != null) {\n            for (BraintreeError error : mFieldErrors) {\n                if (error.getField().equals(field)) {\n                    return error;\n                } else if (error.getFieldErrors() != null) {\n                    returnError = error.errorFor(field);\n                    if (returnError != null) {\n                        return returnError;\n                    }\n                }\n            }\n        }\n        return null;\n    }", "negative": "@Override\n    public TileDao getTileDao(Contents contents) {\n\n        if (contents == null) {\n            throw new GeoPackageException(\"Non null \"\n                    + Contents.class.getSimpleName()\n                    + \" is required to create \" + TileDao.class.getSimpleName());\n        }\n\n        TileMatrixSet tileMatrixSet = contents.getTileMatrixSet();\n        if (tileMatrixSet == null) {\n            throw new GeoPackageException(\"No \"\n                    + TileMatrixSet.class.getSimpleName() + \" exists for \"\n                    + Contents.class.getSimpleName() + \" \" + contents.getId());\n        }\n\n        return getTileDao(tileMatrixSet);\n    }", "type": "random_negative"}
{"anchor": "private CoordinateAxis makeTimeCoordAxisFromReference(NetcdfDataset ds, Variable timeVar, Array vals) {\r\n    Variable refVar = ds.findVariable(\"reftime\");\r\n    if (refVar == null) return null;\r\n    double refValue;\r\n    try {\r\n      Array refArray = refVar.read();\r\n      refValue = refArray.getDouble(refArray.getIndex()); // get the first value\r\n    } catch (IOException ioe) {\r\n      return null;\r\n    }\r\n    if (refValue == N3iosp.NC_FILL_DOUBLE)\r\n      return null;\r\n\r\n    // construct the values array - make it a double to be safe\r\n    Array dvals = Array.factory(DataType.DOUBLE, vals.getShape());\r\n    IndexIterator diter = dvals.getIndexIterator();\r\n    IndexIterator iiter = vals.getIndexIterator();\r\n    while (iiter.hasNext())\r\n      diter.setDoubleNext(iiter.getDoubleNext() + refValue); // add reftime to each of the values\r\n\r\n    String units = ds.findAttValueIgnoreCase(refVar, CDM.UNITS, \"seconds since 1970-1-1 00:00:00\");\r\n    units = normalize(units);\r\n    String desc = \"synthesized time coordinate from reftime, valtimeMINUSreftime\";\r\n    CoordinateAxis1D timeCoord = new CoordinateAxis1D(ds, null, \"timeCoord\", DataType.DOUBLE, \"record\", units, desc);\r\n\r\n    timeCoord.setCachedData(dvals, true);\r\n\r\n    parseInfo.format(\"Created Time Coordinate Axis From Reference = \");\r\n    timeCoord.getNameAndDimensions(parseInfo, true, false);\r\n    parseInfo.format(\"%n\");\r\n\r\n    return timeCoord;\r\n  }", "positive": "private CoordinateAxis makeTimeCoordAxisFromReference(NetcdfDataset ds, Variable timeVar, Array vals) {\n    Variable refVar = ds.findVariable(\"reftime\");\n    if (refVar == null) return null;\n\n    double refValue;\n    try {\n      Array refArray = refVar.read();\n      Index refIndex = refArray.getIndex();\n      refValue = refArray.getDouble(refIndex); // get the first value\n    } catch (IOException ioe) {\n      return null;\n    }\n\n    if (refValue == N3iosp.NC_FILL_DOUBLE) return null;\n\n    // construct the values array - make it a double to be safe\n    Array dvals = Array.factory(DataType.DOUBLE, vals.getShape());\n    IndexIterator srcIter = vals.getIndexIterator();\n    IndexIterator dstIter = dvals.getIndexIterator();\n    while (srcIter.hasNext()) {\n      double v = srcIter.getDoubleNext();\n      dstIter.setDoubleNext(v + refValue); // add reftime to each of the values\n    }\n\n    String units = ds.findAttValueIgnoreCase(refVar, CDM.UNITS, \"seconds since 1970-1-1 00:00:00\");\n    units = normalize(units);\n    String desc = \"synthesized time coordinate from reftime, valtimeMINUSreftime\";\n    CoordinateAxis1D timeCoord = new CoordinateAxis1D(ds, null, \"timeCoord\", DataType.DOUBLE, \"record\", units, desc);\n\n    timeCoord.setCachedData(dvals, true);\n\n    parseInfo.format(\"Created Time Coordinate Axis From Reference = \");\n    timeCoord.getNameAndDimensions(parseInfo, true, false);\n    parseInfo.format(\"%n\");\n\n    return timeCoord;\n  }", "type": "llm_rewrite"}
{"anchor": "public synchronized Object remove(Object key) {\r\n        int index = keys.indexOf(key);\r\n        if (index != -1) {\r\n            Object prev = elements.elementAt(index);\r\n            keys.removeElementAt(index);\r\n            elements.removeElementAt(index);\r\n            return prev;\r\n        } else {\r\n            return null;\r\n        }\r\n    }", "negative": "public static Map addDefaultContext(Object root, MemberAccess memberAccess, ClassResolver classResolver,\n                                        TypeConverter converter, Map context)\n    {\n        OgnlContext result;\n\n        if (context instanceof OgnlContext) {\n            result = (OgnlContext) context;\n        } else {\n            result = new OgnlContext(memberAccess, classResolver, converter, context);\n        }\n\n        result.setRoot(root);\n        return result;\n    }", "type": "random_negative"}
{"anchor": "@SuppressWarnings(\"unchecked\")\n    public T pop() throws EmptyStackException {\n        int i;\n        if ((i = --size) >= 0) {\n            T element = (T) elements[i];\n            elements[i] = null;\n            return element;\n        } else {\n            size = 0;\n            throw new EmptyStackException();\n        }\n    }", "negative": "public static String formatDate(long value, DateFormat threadLocalformat) {\n\t\tString cachedDate = null;\n\t\tLong longValue = Long.valueOf(value);\n\n\t\ttry {\n\t\t\tcachedDate = formatCache.get(longValue);\n\t\t}\n\t\tcatch (Exception ignored) {\n\t\t}\n\n\t\tif (cachedDate != null) {\n\t\t\treturn cachedDate;\n\t\t}\n\n\t\tString newDate;\n\t\tDate dateValue = new Date(value);\n\n\t\tif (threadLocalformat != null) {\n\t\t\tnewDate = threadLocalformat.format(dateValue);\n\n\t\t\tsynchronized (formatCache) {\n\t\t\t\tupdateCache(formatCache, longValue, newDate);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsynchronized (formatCache) {\n\t\t\t\tnewDate = format.format(dateValue);\n\t\t\t\tupdateCache(formatCache, longValue, newDate);\n\t\t\t}\n\t\t}\n\n\t\treturn newDate;\n\t}", "type": "random_negative"}
{"anchor": "public E pollAcquire(Object owner)\n    {\n        E element;\n\n        // Find an element on the requeue that is free and return it.\n        if (!requeue.isEmpty())\n        {\n            for (RequeueElementWrapper<E> nextRecord : requeue)\n            {\n                if (AcquireState.Free.equals(nextRecord.state))\n                {\n                    nextRecord.state = AcquireState.Acquired;\n                    nextRecord.owner = owner;\n\n                    return nextRecord.element;\n                }\n            }\n        }\n\n        // Nothing could be found on the requeue, so attempt to poll an element off the main queue and acquire\n        // it on the requeue.\n        element = queue.poll();\n\n        if (element != null)\n        {\n            requeue(element, owner, AcquireState.Acquired);\n        }\n\n        return element;\n    }", "positive": "public E pollAcquire(Object owner)\n{\n    for (RequeueElementWrapper<E> nextRecord : requeue)\n    {\n        if (AcquireState.Free.equals(nextRecord.state))\n        {\n            nextRecord.state = AcquireState.Acquired;\n            nextRecord.owner = owner;\n            return nextRecord.element;\n        }\n    }\n\n    E element = queue.poll();\n    if (element != null)\n    {\n        requeue(element, owner, AcquireState.Acquired);\n    }\n    return element;\n}", "type": "llm_rewrite"}
{"anchor": "public static Class[] getComponentTypes(final Type type, final Class implClass) {\n\t\tif (type instanceof Class) {\n\t\t\tClass clazz = (Class) type;\n\t\t\tif (clazz.isArray()) {\n\t\t\t\treturn new Class[] {clazz.getComponentType()};\n\t\t\t}\n\t\t}\n\t\telse if (type instanceof ParameterizedType) {\n\t\t\tParameterizedType pt = (ParameterizedType) type;\n\n\t\t\tType[] generics = pt.getActualTypeArguments();\n\n\t\t\tif (generics.length == 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tClass[] types = new Class[generics.length];\n\n\t\t\tfor (int i = 0; i < generics.length; i++) {\n\t\t\t\ttypes[i] = getRawType(generics[i], implClass);\n\t\t\t}\n\t\t\treturn types;\n\t\t}\n\t\telse if (type instanceof GenericArrayType) {\n\t\t\tGenericArrayType gat = (GenericArrayType) type;\n\n\t\t\tClass rawType = getRawType(gat.getGenericComponentType(), implClass);\n\t\t\tif (rawType == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn new Class[] {rawType};\n\t\t}\n\t\treturn null;\n\t}", "positive": "public static item_50[] computeGetComponentTypes(final var_51 obj_8,  final item_50 item_70) {\n\t\tif (obj_8 instanceof item_50) {\n item_50 item_52 = (item_50) obj_8;\n if (item_52.isArray()) {\n return new item_50[] {item_52.getComponentType()};\n\t\t\t}\n\t\t}\n else if (obj_8 instanceof param_98) {\n\t\t\tparam_98 var_57 =  (param_98) obj_8; \n\n\t\t\tvar_51[] param_5 =  var_57.getActualTypeArguments(); \n \n\t\t\tif (param_5.length = =  0) {\n\t\t\t\treturn null; \n\t\t\t}\n\n\t\t\titem_50[] var_39 = new item_50[param_5.length];\n\n int obj_88 = 0;\n while (obj_88 < param_5.length) {\n\n var_39[obj_88] = computeGetRawType(param_5[obj_88], item_70);\n\t\t\t\n     obj_88++;\n}\n\t\t\treturn var_39; \n }\n\t\telse if (obj_8 instanceof param_80) {\n\t\t\tparam_80 val_46 =  (param_80) obj_8; \n\n item_50 item_97 = computeGetRawType(val_46.getGenericComponentType(), item_70);\n\t\t\tif (item_97 == null) {\n return null;\n\t\t\t}\n\n\t\t\treturn new item_50[] {item_97}; \n }\n return null;\n\t}", "type": "augment"}
{"anchor": "public static String print(ResponseOptions responseOptions, ResponseBody responseBody, PrintStream stream, LogDetail logDetail, boolean shouldPrettyPrint) {\n        final StringBuilder builder = new StringBuilder();\n        if (logDetail == ALL || logDetail == STATUS) {\n            builder.append(responseOptions.statusLine());\n        }\n        if (logDetail == ALL || logDetail == HEADERS) {\n            final Headers headers = responseOptions.headers();\n            if (headers.exist()) {\n                appendNewLineIfAll(logDetail, builder).append(toString(headers));\n            }\n        } else if (logDetail == COOKIES) {\n            final Cookies cookies = responseOptions.detailedCookies();\n            if (cookies.exist()) {\n                appendNewLineIfAll(logDetail, builder).append(cookies.toString());\n            }\n        }\n        if (logDetail == ALL || logDetail == BODY) {\n            String responseBodyToAppend;\n            if (shouldPrettyPrint) {\n                responseBodyToAppend = new Prettifier().getPrettifiedBodyIfPossible(responseOptions, responseBody);\n            } else {\n                responseBodyToAppend = responseBody.asString();\n            }\n            if (logDetail == ALL && !isBlank(responseBodyToAppend)) {\n                builder.append(SystemUtils.LINE_SEPARATOR).append(SystemUtils.LINE_SEPARATOR);\n            }\n\n            builder.append(responseBodyToAppend);\n        }\n        String response = builder.toString();\n        stream.println(response);\n        return response;\n    }", "negative": "public static char[] toSimpleCharArray(byte[] barr) {\n        char[] carr = new char[barr.length];\n        for (int i = 0; i < barr.length; i++) {\n            carr[i] = (char) (barr[i] & 0xFF);\n        }\n        return carr;\n    }", "type": "random_negative"}
{"anchor": "void writeIndex(Filer filer) {\n\t\tStandardLocation location = StandardLocation.SOURCE_OUTPUT;\n\t\tFileObject indexFile;\n\t\ttry {\n\t\t\tindexFile = filer.createResource(location, \"com.turbomanage.storm\",\n\t\t\t\t\tENV_FILE);\n\t\t\tOutputStream fos = indexFile.openOutputStream();\n\t\t\tPrintWriter out = new PrintWriter(fos);\n\t\t\t// Dump converters\n\t\t\tout.println(BEGIN_CONVERTERS);\n\t\t\tfor (ConverterModel converter : converters) {\n\t\t\t\tconverter.writeToIndex(out);\n\t\t\t}\n\t\t\tout.println(END_CONVERTERS);\n\t\t\t// Dump databases\n\t\t\tfor (DatabaseModel dbModel : dbModels.values()) {\n\t\t\t\tdbModel.writeToIndex(out);\n\t\t\t}\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}", "positive": "void writeIndex(Filer filer) {\n\t\tStandardLocation location = StandardLocation.SOURCE_OUTPUT;\n\t\ttry {\n\t\t\tFileObject indexFile = filer.createResource(location, \"com.turbomanage.storm\", ENV_FILE);\n\t\t\ttry (OutputStream fos = indexFile.openOutputStream();\n\t\t\t\t PrintWriter out = new PrintWriter(fos)) {\n\t\t\t\t// Dump converters\n\t\t\t\tout.println(BEGIN_CONVERTERS);\n\t\t\t\tfor (ConverterModel converter : converters) {\n\t\t\t\t\tconverter.writeToIndex(out);\n\t\t\t\t}\n\t\t\t\tout.println(END_CONVERTERS);\n\t\t\t\t// Dump databases\n\t\t\t\tfor (DatabaseModel dbModel : dbModels.values()) {\n\t\t\t\t\tdbModel.writeToIndex(out);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}", "type": "llm_rewrite"}
{"anchor": "static void initIntentionSelectionThreads(Config config) {\n    int ncores = config.getNumThreads();\n    Main.intentionSelectors = new IntentionSelector[ncores];\n    for (int i = 0; i < Main.npools; i++) {\n      Main.intentionSelectors[i] = new IntentionSelector(i, config.getRandomSeed());\n    }\n  }", "positive": "static void initIntentionSelectionThreads(Config config) {\n    int ncores = config.getNumThreads();\n    IntentionSelector[] selectors = new IntentionSelector[ncores];\n    Main.intentionSelectors = selectors;\n    for (int i = 0; i < Main.npools; i++) {\n        selectors[i] = new IntentionSelector(i, config.getRandomSeed());\n    }\n}", "type": "llm_rewrite"}
{"anchor": "static public File getFile(String fileLocation, boolean alwaysInCache) {\r\n    if (alwaysInCache) {\r\n      return getCacheFile(fileLocation);\r\n\r\n    } else {\r\n      File f = new File(fileLocation);\r\n      if (f.exists())\r\n        return f;\r\n\r\n      // now comes the tricky part to make sure we can open and write to it\r\n      try {\r\n        if (!simulateUnwritableDir && f.createNewFile()) {\r\n          boolean ret = f.delete();\r\n          assert ret;\r\n          return f;\r\n        }\r\n      } catch (IOException e) {\r\n        // cant write to it - drop through\r\n      }\r\n\r\n      return getCacheFile(fileLocation);\r\n    }\r\n  }", "positive": "static public File getFile(String fileLocation, boolean alwaysInCache) {\n    if (alwaysInCache) {\n      return getCacheFile(fileLocation);\n    }\n\n    final File f = new File(fileLocation);\n    if (f.exists()) {\n      return f;\n    }\n\n    if (simulateUnwritableDir) {\n      return getCacheFile(fileLocation);\n    }\n\n    try {\n      if (f.createNewFile()) {\n        boolean ret = f.delete();\n        assert ret;\n        return f;\n      }\n    } catch (IOException e) {\n      // cannot create the file - fall through to cache\n    }\n\n    return getCacheFile(fileLocation);\n  }", "type": "llm_rewrite"}
{"anchor": "public Document makeDocument() {\r\n    Element rootElem = new Element(\"pointConfig\");\r\n    Document doc = new Document(rootElem);\r\n    if (tableConfigurerClass != null)\r\n      rootElem.addContent( new Element(\"tableConfigurer\").setAttribute(\"class\", tableConfigurerClass));\r\n    if (tc.featureType != null)\r\n      rootElem.setAttribute(\"featureType\", tc.featureType.toString());\r\n\r\n    rootElem.addContent(writeTable(tc));\r\n\r\n    return doc;\r\n  }", "positive": "import javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\n\npublic Document makeDocument() {\n    try {\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        DocumentBuilder db = dbf.newDocumentBuilder();\n        Document doc = db.newDocument();\n\n        Element rootElem = doc.createElement(\"pointConfig\");\n        doc.appendChild(rootElem);\n\n        if (tableConfigurerClass != null) {\n            Element tableConfigurer = doc.createElement(\"tableConfigurer\");\n            tableConfigurer.setAttribute(\"class\", tableConfigurerClass);\n            rootElem.appendChild(tableConfigurer);\n        }\n\n        if (tc.featureType != null) {\n            rootElem.setAttribute(\"featureType\", tc.featureType.toString());\n        }\n\n        Node tableNode = writeTable(tc);\n        if (tableNode != null) {\n            Node imported = doc.importNode(tableNode, true);\n            rootElem.appendChild(imported);\n        }\n\n        return doc;\n    } catch (ParserConfigurationException e) {\n        throw new RuntimeException(e);\n    }\n}", "type": "retranslate"}
{"anchor": "@SuppressWarnings(\"unchecked\")\r\n  public List<T> run(final Object... iArgs) {\r\n    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();\r\n    if (database == null)\r\n      throw new OQueryParsingException(\"No database configured\");\r\n\r\n    ((OMetadataInternal) database.getMetadata()).makeThreadLocalSchemaSnapshot();\r\n    try {\r\n      setParameters(iArgs);\r\n      Object o = database.getStorage().command(this);\r\n      if (o instanceof List) {\r\n        return (List<T>) o;\r\n      } else {\r\n        return (List<T>) Collections.singletonList(o);\r\n      }\r\n\r\n    } finally {\r\n      ((OMetadataInternal) database.getMetadata()).clearThreadLocalSchemaSnapshot();\r\n    }\r\n  }", "negative": "@GET()\n  @Path(ACTIVATE_METRICS_FOR_CLASS)\n  public String activateMetricsForClass(@QueryParam(QUERY_PARAM_CLASS_FQ_NAME) final String classFQN) {\n    if (classFQN != null && !classFQN.isEmpty()) {\n      try {\n        final Class<?> aClass = Class.forName(classFQN);\n        DI.activateMetrics(aClass);\n      } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n        return e.getMessage();\n      }\n    }\n    return OK;\n  }", "type": "random_negative"}
{"anchor": "public double togreenw(double rectt, double utco, double gmst) {\r\n\r\n    double pi = Math.acos(-1.00);\r\n    //\r\n    // For each occultation ID, its TU and GMST are the same.  However, every\r\n    // occultation event takes place at gmst+uts, uts is progressively increasing\r\n    // with every occultation event.\r\n    double utc = (utco + rectt) * 1.0027379093;\r\n    gmst = gmst + utc;  //in seconds, without eoe correction.\r\n    //  gmst may be a positive number or may be a negative number.\r\n    while (gmst < 0.0) {\r\n      gmst = gmst + 86400.00;\r\n    }\r\n\r\n\r\n    while (gmst > 86400.00) {\r\n      gmst = gmst - 86400.00;\r\n    }\r\n\r\n    // gmst = the Greenwich mean sidereal time.\r\n    // This gmst is without the corrections from the equation of equinoxes.  For\r\n    // GPS/MET applications, the corrections from equation of equinoxes is not\r\n    // necessary because of the accurary needed.\r\n    return gmst * 2.0 * pi / 86400.0;  //!*** This is the THETA in radian.\r\n  }", "negative": "private void notifyChanges(Iterable<PropertyChangeEvent> changes)\n    {\n        List<PropertyChangeListener> activeListeners = listeners.getActiveListeners();\n\n        if (activeListeners != null)\n        {\n            for (PropertyChangeListener listener : activeListeners)\n            {\n                for (PropertyChangeEvent event : changes)\n                {\n                    listener.propertyChange(event);\n                }\n            }\n        }\n    }", "type": "random_negative"}
{"anchor": "public final void writeChar(char[] pa, int start, int n) throws IOException {\r\n    for (int i = 0; i < n; i++) {\r\n      writeChar(pa[start + i]);\r\n    }\r\n  }", "positive": "public final void writeChar(char[] pa, int start, int n) throws IOException {\n    int end = start + n;\n    for (int i = start; i < end; i++) {\n        writeChar(pa[i]);\n    }\n}", "type": "llm_rewrite"}
{"anchor": "public static final ByteBuffer gotoNALUnit(ByteBuffer buf) {\n\n        if (!buf.hasRemaining())\n            return null;\n\n        int from = buf.position();\n        ByteBuffer result = buf.slice();\n        result.order(ByteOrder.BIG_ENDIAN);\n\n        int val = 0xffffffff;\n        while (buf.hasRemaining()) {\n            val <<= 8;\n            val |= (buf.get() & 0xff);\n            if ((val & 0xffffff) == 1) {\n                buf.position(buf.position() - (val == 1 ? 4 : 3));\n                result.limit(buf.position() - from);\n                break;\n            }\n        }\n        return result;\n    }", "negative": "public String doConvert(String str) {\r\n\r\n\t//check for just missing V2.0\r\n\t  \r\n\t  ParserHELM2 parser = new ParserHELM2();\r\n\t  try{\r\n\t  parser.parse(str + \"V2.0\");\r\n\t  return str + \"V2.0\";\r\n\t  }\r\n\t  catch(Exception e){\r\n\t\t\r\n    /* Use String Builder */\r\n    /* simple add character -> split works then */\r\n    String helm1 = str + \"f\";\r\n\r\n\r\n    StringBuilder helm2 = new StringBuilder();\r\n    String[] sections = helm1.split(\"}\\\\$\");\r\n\r\n    /* Section 1 is accepted in full, no changes necessary, Section 1 has to be there */\r\n    helm2.append(sections[0] + \"}$\");\r\n\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 1; i < sections.length; i++) {\r\n      sb.append(sections[i] + \"}$\");\r\n    }\r\n\r\n    helm1 = \"$\" + sb.toString();\r\n    sections = helm1.split(\"\\\\$\");\r\n\r\n     /*\r\n     * Section 2 connection section; section 3 is added to the second section,\r\n     * Section 2 is not necessary, is this section really there\r\n     */\r\n     if (sections.length >= 2) {\r\n       if (!(sections[1].isEmpty())) {\r\n        helm2.append(sections[1]);\r\n       }\r\n     }\r\n\r\n     /* Add hydrogen bonds to the connection section */\r\n     if (sections.length >= 3) {\r\n       if (!(sections[2].isEmpty())) {\r\n        \r\n         if (!(sections[1].isEmpty())) {\r\n          helm2.append(\"|\" + sections[2]);\r\n         } else {\r\n          helm2.append(sections[2]);\r\n         }\r\n       }\r\n       \r\n       /*Group section*/\r\n      helm2.append(\"$\");\r\n\r\n      helm2.append(\"$\");\r\n       \r\n       /*Add annotation to the annotation section*/\r\n       if (sections.length >= 4) {\r\n         if (!(sections[3].isEmpty())) {\r\n          helm2.append(sections[3]);\r\n         }\r\n       }\r\n\r\n     }\r\n     \r\n    /* Add version number to indicate HELM2 notation */\r\n    helm2.append(\"$V2.0\");\r\n    return helm2.toString();\r\n\t  }\r\n \r\n  }", "type": "random_negative"}
{"anchor": "public static DMatrixRMaj crossMatrix( GeoTuple3D_F64 v, DMatrixRMaj ret ) {\n\t\tif( ret == null ) {\n\t\t\tret = new DMatrixRMaj( 3, 3 );\n\t\t} else {\n\t\t\tret.zero();\n\t\t}\n\n\t\tdouble x = v.getX();\n\t\tdouble y = v.getY();\n\t\tdouble z = v.getZ();\n\n\t\tret.set( 0, 1, -z );\n\t\tret.set( 0, 2, y );\n\t\tret.set( 1, 0, z );\n\t\tret.set( 1, 2, -x );\n\t\tret.set( 2, 0, -y );\n\t\tret.set( 2, 1, x );\n\n\t\treturn ret;\n\t}", "positive": "package TranslatedCode;\n\npublic class GeoTuple3D_F64 {\n    private double x;\n    private double y;\n    private double z;\n\n    public GeoTuple3D_F64(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n\n    public double getX() {\n        return x;\n    }\n\n    public double getY() {\n        return y;\n    }\n\n    public double getZ() {\n        return z;\n    }\n}\n\npublic class DMatrixRMaj {\n    public int numRows;\n    public int numCols;\n    private double[][] data;\n\n    public DMatrixRMaj(int rows, int cols) {\n        this.numRows = rows;\n        this.numCols = cols;\n        this.data = new double[rows][cols];\n    }\n\n    public void zero() {\n        for (int i = 0; i < numRows; i++) {\n            for (int j = 0; j < numCols; j++) {\n                data[i][j] = 0.0;\n            }\n        }\n    }\n\n    public void set(int row, int col, double value) {\n        data[row][col] = value;\n    }\n\n    public double get(int row, int col) {\n        return data[row][col];\n    }\n}\n\npublic final class MatrixOps {\n    private MatrixOps() {\n        // prevent instantiation\n    }\n\n    public static DMatrixRMaj crossMatrix(GeoTuple3D_F64 v, DMatrixRMaj ret) {\n        if (ret == null) {\n            ret = new DMatrixRMaj(3, 3);\n        } else {\n            ret.zero();\n        }\n\n        double x = v.getX();\n        double y = v.getY();\n        double z = v.getZ();\n\n        ret.set(0, 1, -z);\n        ret.set(0, 2, y);\n        ret.set(1, 0, z);\n        ret.set(1, 2, -x);\n        ret.set(2, 0, -y);\n        ret.set(2, 1, x);\n\n        return ret;\n    }\n}", "type": "retranslate"}
{"anchor": "public static boolean hasDifferentValue(XsdDoubleRestrictions o1, XsdDoubleRestrictions o2) {\n        if (o1 == null && o2 == null) {\n            return false;\n        }\n\n        double o1Value = Double.MAX_VALUE;\n        double o2Value;\n\n        if (o1 != null) {\n            o1Value = o1.getValue();\n        }\n\n        if (o2 != null) {\n            o2Value = o2.getValue();\n            return o2Value == o1Value;\n        }\n\n        return false;\n    }", "positive": "public final class DoubleRestrictionsUtils {\n    private DoubleRestrictionsUtils() {\n        // Utility class; prevent instantiation.\n    }\n\n    public static boolean HasDifferentValue(XsdDoubleRestrictions o1, XsdDoubleRestrictions o2) {\n        if (o1 == null && o2 == null) {\n            return false;\n        }\n\n        double o1Value = Double.MAX_VALUE;\n        double o2Value;\n\n        if (o1 != null) {\n            o1Value = o1.getValue();\n        }\n\n        if (o2 != null) {\n            o2Value = o2.getValue();\n            return o2Value == o1Value;\n        }\n\n        return false;\n    }\n}", "type": "retranslate"}
{"anchor": "public void doFilter(final ServletRequest req, final ServletResponse res, final FilterChain chain)\n      throws IOException, ServletException {\n    final HttpServletRequest request = (HttpServletRequest) req;\n    final HttpServletResponse response = (HttpServletResponse) res;\n\n    if (isGzipAllowed(request)) {\n      doGzipResponse(request, response, chain);\n    } else {\n      LOG.debug(\"Gzip not allowed. Proceeding with chain.\");\n      chain.doFilter(request, response);\n    }\n  }", "negative": "public E get() {\n    E r = null;\n    if (numElems > 0) {\n      numElems--;\n      r = ea[first];\n      ea[first] = null;\n      if (++first == maxSize)\n        first = 0;\n    }\n    return r;\n  }", "type": "random_negative"}
{"anchor": "public void box(Type type) {\n        if (TypeUtils.isPrimitive(type)) {\n            if (type == Type.VOID_TYPE) {\n                aconst_null();\n            } else {\n                Type boxed = TypeUtils.getBoxedType(type);\n                new_instance(boxed);\n                if (type.getSize() == 2) {\n                    // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o\n                    dup_x2();\n                    dup_x2();\n                    pop();\n                } else {\n                    // p -> po -> opo -> oop -> o\n                    dup_x1();\n                    swap();\n                }\n                invoke_constructor(boxed, new Signature(Constants.CONSTRUCTOR_NAME, Type.VOID_TYPE, new Type[]{ type }));\n            }\n        }\n    }", "positive": "public void box(Type type) {\n    if (!TypeUtils.isPrimitive(type)) {\n        return;\n    }\n\n    if (type == Type.VOID_TYPE) {\n        aconst_null();\n        return;\n    }\n\n    Type boxed = TypeUtils.getBoxedType(type);\n    new_instance(boxed);\n\n    int size = type.getSize();\n    if (size == 2) {\n        // Pp -> Ppo -> oPpo -> ooPpo -> ooPp -> o\n        dup_x2();\n        dup_x2();\n        pop();\n    } else {\n        // p -> po -> opo -> oop -> o\n        dup_x1();\n        swap();\n    }\n\n    invoke_constructor(boxed, new Signature(Constants.CONSTRUCTOR_NAME, Type.VOID_TYPE, new Type[] { type }));\n}", "type": "llm_rewrite"}
{"anchor": "private void addToSetIfNotPrimitiveOrCollection(Set<String> schemaNameSet, String... schemaNames) {\n        for (String schemaName : schemaNames) {\n            // collections schemas get brought in by a star import\n            if (!HollowCodeGenerationUtils.isCollectionType(schemaName, dataset) &&\n                    !HollowCodeGenerationUtils.isPrimitiveType(schemaName)) {\n                schemaNameSet.add(schemaName);\n            }\n        }\n    }", "negative": "public final boolean isReciprocalOf(final Dimension that) {\n        final Factor[] theseFactors = _factors;\n        final Factor[] thoseFactors = that._factors;\n        boolean isReciprocalOf;\n        if (theseFactors.length != thoseFactors.length) {\n            isReciprocalOf = false;\n        }\n        else {\n            int i;\n            for (i = theseFactors.length; --i >= 0;) {\n                if (!theseFactors[i].isReciprocalOf(thoseFactors[i])) {\n                    break;\n                }\n            }\n            isReciprocalOf = i < 0;\n        }\n        return isReciprocalOf;\n    }", "type": "random_negative"}
{"anchor": "public static Session adaptToSession(Object source) {\n        if (source instanceof SessionAdaptable) {\n            return ((SessionAdaptable) source).getSession();\n        } else {\n            // assume this is a JCR session of someform, in which case there\n            // should be a SparseUserManager\n            Object userManager = safeMethod(source, \"getUserManager\", new Object[0], new Class[0]);\n            if (userManager != null) {\n                return (Session) safeMethod(userManager, \"getSession\", new Object[0], new Class[0]);\n            }\n            return null;\n        }\n    }", "negative": "static public void registerIOProvider(Class iospClass, boolean last)\n          throws IllegalAccessException, InstantiationException {\n    IOServiceProvider spi;\n    spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n    if (userLoads && !last)\n      registeredProviders.add(0, spi);  // put user stuff first\n    else registeredProviders.add(spi);\n  }", "type": "random_negative"}
{"anchor": "private <T> Observable.Transformer<T, T> applyInsertRetryPolicy() {\n        return tObservable -> tObservable\n                .retryWhen(errors -> {\n                    Observable<Integer> range = Observable.range(1, 2);\n                    return errors\n                            .zipWith(range, (t, i) -> {\n                                if (t instanceof DriverException) {\n                                    return i;\n                                }\n                                throw Exceptions.propagate(t);\n                            })\n                            .flatMap(retryCount -> {\n                                long delay = (long) Math.min(Math.pow(2, retryCount) * 1000, 3000);\n                                log.debug(\"Retrying batch insert in \" + delay + \" ms\");\n                                return Observable.timer(delay, TimeUnit.MILLISECONDS);\n                            });\n                });\n    }", "positive": "private <obj_96> val_48.Transformer<obj_96, obj_96> processApplyInsertRetryPolicy() {\n        return item_47 -> item_47\n                .retryWhen(tmp_4 -> {\n                    val_48<Integer> var_15 = val_48.range(1, 2);\n                    return tmp_4\n                            .zipWith(var_15, (var_20, item_13) -> {\n                                if (var_20 instanceof tmp_8) {\n                                    return item_13;\n                                }\n                                throw param_51.propagate(var_20);\n                            })\n                            .flatMap(param_57 -> {\n                                long item_2 = (long) obj_72.min(obj_72.pow(2, param_57) * 1000, 3000);\n                                item_44.debug(\"val_92 obj_88 item_90 param_72 \" + item_2 + \" item_25\");\n                                return val_48.timer(item_2, item_99.MILLISECONDS);\n                            });\n                });\n    }", "type": "augment"}
{"anchor": "public static float[] values(Float[] array) {\n\t\tfloat[] dest = new float[array.length];\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tFloat v = array[i];\n\t\t\tif (v != null) {\n\t\t\t\tdest[i] = v.floatValue();\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}", "positive": "package TranslatedCode;\n\npublic final class ArrayUtils {\n    private ArrayUtils() {\n        // Prevent instantiation\n    }\n\n    public static float[] values(Float[] array) {\n        float[] dest = new float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            Float v = array[i];\n            if (v != null) {\n                dest[i] = v.floatValue();\n            }\n        }\n        return dest;\n    }\n}", "type": "retranslate"}
{"anchor": "public void clear() {\n        modCount++;\n        HashEntry[] data = this.data;\n        for (int i = data.length - 1; i >= 0; i--) {\n            data[i] = null;\n        }\n        size = 0;\n    }", "positive": "public void clear() {\n    modCount++;\n    HashEntry[] data = this.data;\n    for (int i = data.length - 1; i >= 0; i--) {\n        data[i] = null;\n    }\n    size = 0;\n}", "type": "retranslate"}
{"anchor": "void markStackedVariables(Stack s)\r\n    {\r\n        // Reverse the stack.\r\n        Stack bts = new Stack();\r\n        // LogStream.err.println(\"Variables to be marked:\");\r\n        while (!s.empty()) {\r\n            // LogStream.err.println(((BaseType)s.peek()).getName());\r\n            bts.push(s.pop());\r\n        }\r\n\r\n        // For each but the last stack element, set the projection.\r\n        // setProject(true, false) for a ctor type sets the projection for\r\n        // the ctor itself but *does not* set the projection for all its\r\n        // children. Thus, if a user wants the variable S.X, and S contains Y\r\n        // and Z too, S's projection will be set (so serialize will descend\r\n        // into S) but X, Y and Z's projection remain clear. In this example,\r\n        // X's projection is set by the code that follows the while loop.\r\n        // 1/28/2000 jhrg\r\n        while (bts.size() > 1) {\r\n            ServerMethods ct = (ServerMethods) bts.pop();\r\n            ct.setProject(true, false);\r\n        }\r\n\r\n        // For the last element, project the entire variable.\r\n        ServerMethods bt = (ServerMethods) bts.pop();\r\n        bt.setProject(true, true);\r\n    }", "positive": "void markStackedVariables(Stack s) {\n    // Pop all elements from the original stack into a list (preserves pop order).\n    java.util.ArrayList<Object> items = new java.util.ArrayList<>();\n    while (!s.empty()) {\n        items.add(s.pop());\n    }\n\n    // If there were no elements, mirror original behavior by throwing EmptyStackException.\n    if (items.isEmpty()) {\n        throw new java.util.EmptyStackException();\n    }\n\n    // Process from the original bottom to the original top.\n    // items was filled in pop order: [top, ..., bottom], so iterate from end to start.\n    for (int i = items.size() - 1; i > 0; i--) {\n        ServerMethods ct = (ServerMethods) items.get(i);\n        ct.setProject(true, false);\n    }\n\n    // Last element (original top) gets full projection.\n    ServerMethods bt = (ServerMethods) items.get(0);\n    bt.setProject(true, true);\n}", "type": "llm_rewrite"}
{"anchor": "public boolean sync() {\n    try {\n      if (!mcGridReader.init()) {\n        return false;\n      }\n      GridIndex index = mcGridReader.getGridIndex();\n      // reconstruct the ncfile objects\n      ncfile.empty();\n      open(index, null);\n      return true;\n\n    } catch (IOException ioe) {\n      return false;\n    }\n  }", "negative": "@SuppressWarnings(\"unchecked\")\r\n  public List<T> run(final Object... iArgs) {\r\n    final ODatabaseDocumentInternal database = ODatabaseRecordThreadLocal.instance().get();\r\n    if (database == null)\r\n      throw new OQueryParsingException(\"No database configured\");\r\n\r\n    ((OMetadataInternal) database.getMetadata()).makeThreadLocalSchemaSnapshot();\r\n    try {\r\n      setParameters(iArgs);\r\n      Object o = database.getStorage().command(this);\r\n      if (o instanceof List) {\r\n        return (List<T>) o;\r\n      } else {\r\n        return (List<T>) Collections.singletonList(o);\r\n      }\r\n\r\n    } finally {\r\n      ((OMetadataInternal) database.getMetadata()).clearThreadLocalSchemaSnapshot();\r\n    }\r\n  }", "type": "random_negative"}
{"anchor": "static void printClassTaxonomy(Taxonomy<ElkClass> taxonomy, File out)\n\t\t\tthrows IOException {\n\t\tFileWriter fstream = null;\n\t\tBufferedWriter writer = null;\n\n\t\ttry {\n\t\t\tfstream = new FileWriter(out);\n\t\t\twriter = new BufferedWriter(fstream);\n\n\t\t\twriter.append(\"Ontology(\\n\");\n\n\t\t\tprocessTaxomomy(taxonomy, writer);\n\n\t\t\twriter.append(\")\\n\");\n\t\t\twriter.flush();\n\n\t\t} finally {\n\t\t\tIOUtils.closeQuietly(fstream);\n\t\t\tIOUtils.closeQuietly(writer);\n\t\t}\n\t}", "negative": "public static double[] values(Double[] array) {\n\t\tdouble[] dest = new double[array.length];\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tDouble v = array[i];\n\t\t\tif (v != null) {\n\t\t\t\tdest[i] = v.doubleValue();\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}", "type": "random_negative"}
{"anchor": "protected <U extends Model> Optional<AppUser<U>> getPrincipal() {\n        if (Securitys.isLogin()) {\n            final AppUser<U> appUser = Securitys.getLogin();\n            return Optional.of(appUser);\n        }\n        return Optional.absent();\n    }", "positive": "protected <U extends Model> Optional<AppUser<U>> getPrincipal() {\n    return Securitys.isLogin() ? Optional.of(Securitys.getLogin()) : Optional.absent();\n}", "type": "llm_rewrite"}
{"anchor": "public static String getColumnIndexFromSaveAttr(final String saveAttr) {\r\n\t\tif ((saveAttr != null) && (!saveAttr.isEmpty())) {\r\n\t\t\tint iend = saveAttr.indexOf('=');\r\n\t\t\tif (iend > 0) {\r\n\t\t\t\tint istart = saveAttr.indexOf('$');\r\n\t\t\t\tif (iend > istart) {\r\n\t\t\t\t\treturn saveAttr.substring(istart + 1, iend);\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}", "positive": "package TranslatedCode;\n\npublic final class StringUtils {\n    private StringUtils() {\n        // prevent instantiation\n    }\n\n    public static String getColumnIndexFromSaveAttr(String saveAttr) {\n        if (saveAttr != null && !saveAttr.isEmpty()) {\n            int iend = saveAttr.indexOf('=');\n            if (iend > 0) {\n                int istart = saveAttr.indexOf('$');\n                if (iend > istart) {\n                    return saveAttr.substring(istart + 1, iend);\n                }\n            }\n        }\n        return null;\n    }\n}", "type": "retranslate"}
{"anchor": "final ByteVector put11(final int byteValue1, final int byteValue2) {\n    int currentLength = length;\n    if (currentLength + 2 > data.length) {\n      enlarge(2);\n    }\n    byte[] currentData = data;\n    currentData[currentLength++] = (byte) byteValue1;\n    currentData[currentLength++] = (byte) byteValue2;\n    length = currentLength;\n    return this;\n  }", "negative": "void rainbow(Nfa nfa, int type, short but, State from, State to) {\n        ColorDesc cd;\n        short co;\n\n        for (co = 0; co < colorDescs.size(); co++) {\n            cd = colorDescs.get(co);\n            if (cd != null\n                    && cd.sub != co\n                    && co != but\n                    && !cd.pseudo()) {\n                nfa.newarc(type, co, from, to);\n            }\n        }\n    }", "type": "random_negative"}
{"anchor": "public static void bounding( List<Point2D_I32> points , Rectangle2D_I32 rectangle ) {\n\n\t\trectangle.x0 = Integer.MAX_VALUE;\n\t\trectangle.y0 = Integer.MAX_VALUE;\n\t\trectangle.x1 = Integer.MIN_VALUE;\n\t\trectangle.y1 = Integer.MIN_VALUE;\n\n\t\tfor( int i = 0; i < points.size(); i++ ) {\n\t\t\tPoint2D_I32 p = points.get(i);\n\n\t\t\tif( p.x < rectangle.x0 )\n\t\t\t\trectangle.x0 = p.x;\n\t\t\tif( p.x > rectangle.x1 )\n\t\t\t\trectangle.x1 = p.x;\n\t\t\tif( p.y < rectangle.y0 )\n\t\t\t\trectangle.y0 = p.y;\n\t\t\tif( p.y > rectangle.y1 )\n\t\t\t\trectangle.y1 = p.y;\n\t\t}\n\n\t\trectangle.x1++;\n\t\trectangle.y1++;\n\t}", "positive": "import java.util.List;\n\npublic class Point2D_I32 {\n    public int x;\n    public int y;\n\n    public Point2D_I32() { }\n\n    public Point2D_I32(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class Rectangle2D_I32 {\n    public int x0;\n    public int y0;\n    public int x1;\n    public int y1;\n\n    public Rectangle2D_I32() { }\n\n    public Rectangle2D_I32(int x0, int y0, int x1, int y1) {\n        this.x0 = x0;\n        this.y0 = y0;\n        this.x1 = x1;\n        this.y1 = y1;\n    }\n}\n\npublic final class GeometryUtils {\n    private GeometryUtils() { }\n\n    public static void bounding(List<Point2D_I32> points, Rectangle2D_I32 rectangle) {\n        rectangle.x0 = Integer.MAX_VALUE;\n        rectangle.y0 = Integer.MAX_VALUE;\n        rectangle.x1 = Integer.MIN_VALUE;\n        rectangle.y1 = Integer.MIN_VALUE;\n\n        for (int i = 0; i < points.size(); i++) {\n            Point2D_I32 p = points.get(i);\n\n            if (p.x < rectangle.x0)\n                rectangle.x0 = p.x;\n            if (p.x > rectangle.x1)\n                rectangle.x1 = p.x;\n            if (p.y < rectangle.y0)\n                rectangle.y0 = p.y;\n            if (p.y > rectangle.y1)\n                rectangle.y1 = p.y;\n        }\n\n        rectangle.x1++;\n        rectangle.y1++;\n    }\n}", "type": "retranslate"}
{"anchor": "public void setMaxRowHeight(int row, int height)\n    {\n        Integer previousValue = maxRowSizes.get(row);\n\n        if (previousValue == null)\n        {\n            maxRowSizes.put(row, height);\n        }\n        else if (previousValue < height)\n        {\n            maxRowSizes.put(row, height);\n        }\n    }", "negative": "protected Map<String, Object> getCached(String keySpace, String columnFamily, String key) throws StorageClientException {\n        Map<String, Object> m = null;\n        String cacheKey = getCacheKey(keySpace, columnFamily, key);\n\n        CacheHolder cacheHolder = getFromCacheInternal(cacheKey);\n        if (cacheHolder != null) {\n            m = cacheHolder.get();\n            if (m != null) {\n                LOGGER.debug(\"Cache Hit {} {} {} \", new Object[] { cacheKey, cacheHolder, m });\n            }\n        }\n        if (m == null) {\n            m = client.get(keySpace, columnFamily, key);\n            if (m != null) {\n                LOGGER.debug(\"Cache Miss, Found Map {} {}\", cacheKey, m);\n            }\n            putToCacheInternal(cacheKey, new CacheHolder(m), true);\n        }\n        return m;\n    }", "type": "random_negative"}
{"anchor": "protected TaxonomyNode<ElkObjectProperty> getObjectPropertyTaxonomyNode(\n\t\t\tfinal ElkObjectProperty elkProperty) throws ElkException {\n\t\tfinal Taxonomy<ElkObjectProperty> propertyTaxonomy = getObjectPropertyTaxonomy();\n\t\tfinal TaxonomyNode<ElkObjectProperty> node = propertyTaxonomy\n\t\t\t\t.getNode(elkProperty);\n\t\tif (node != null) {\n\t\t\treturn node;\n\t\t}\n\t\t// else\n\t\tif (allowFreshEntities) {\n\t\t\treturn new FreshTaxonomyNode<ElkObjectProperty>(elkProperty,\n\t\t\t\t\tpropertyTaxonomy);\n\t\t}\n\t\t// else\n\t\tthrow new ElkFreshEntitiesException(elkProperty);\n\t}", "positive": "protected item_100<tmp_53> executeGetObjectPropertyTaxonomyNode(\n\t\t\tfinal tmp_53 param_27) throws tmp_27 {\n\t\t\t\t\tobj_32); \n\t\t\t\t.getNode(param_27);\n\t\tthrow new processElkFreshEntitiesException(param_27);\n\t\tfinal param_99< tmp_53>  obj_32 =  handleGetObjectPropertyTaxonomy(); \n final item_100<tmp_53> item_100 = obj_32\n\t\tif (item_100 !=  null) {\n\t\t\treturn item_100; \n\t\t}\n  \t\t// else\n\t\tif (param_50) {\n return new val_4<tmp_53>(param_27,\n }\n\t\t/ /  else\n  \t}", "type": "augment"}
{"anchor": "private DataType getAttributeDataType(Attribute attribute) {\r\n    DataType dataType = attribute.getDataType();\r\n    if (signedness == Signedness.UNSIGNED) {\r\n      // If variable is unsigned, make its integral attributes unsigned too.\r\n      dataType = dataType.withSignedness(signedness);\r\n    }\r\n    return dataType;\r\n  }", "negative": "private CoordinateAxis makeLonCoordAxis(NetcdfDataset ds, String axisName, Dimension dim) {\r\n    if (dim == null) return null;\r\n    double dx = 4 * findAttributeDouble(ds, \"DX\");\r\n    int nx = dim.getLength();\r\n    double startx = centerX - dx * (nx - 1) / 2;\r\n\r\n    CoordinateAxis v = new CoordinateAxis1D(ds, null, axisName, DataType.DOUBLE, dim.getShortName(), \"degrees_east\", \"synthesized longitude coordinate\");\r\n    v.setValues(nx, startx, dx);\r\n    v.addAttribute(new Attribute(_Coordinate.AxisType, \"Lon\"));\r\n    if (!axisName.equals(dim.getShortName()))\r\n      v.addAttribute(new Attribute(_Coordinate.AliasForDimension, dim.getShortName()));\r\n\r\n    return v;\r\n  }", "type": "random_negative"}
{"anchor": "public static void equalsOrDie(String a, String b) {\n        if (a == null && b == null) {\n            return;\n        }\n        if (a == null || b == null) {\n            die(\"Values not equal value a=\", a, \"value b=\", b);\n        }\n\n        char[] ac = FastStringUtils.toCharArray(a);\n        char[] bc = FastStringUtils.toCharArray(b);\n        Chr.equalsOrDie(ac, bc);\n    }", "negative": "@Nullable\n    public BraintreeError errorFor(String field) {\n        BraintreeError returnError;\n        if (mFieldErrors != null) {\n            for (BraintreeError error : mFieldErrors) {\n                if (error.getField().equals(field)) {\n                    return error;\n                } else if (error.getFieldErrors() != null) {\n                    returnError = error.errorFor(field);\n                    if (returnError != null) {\n                        return returnError;\n                    }\n                }\n            }\n        }\n        return null;\n    }", "type": "random_negative"}
{"anchor": "public Collection addMember(Resource first, Resource... rest) {\n    if (this.members == null) {\n      this.members = new ArrayList<>();\n      checkMember(first);\n      stream(rest).forEach(this::checkMember);\n    }\n    this.members.addAll(Lists.asList(first, rest));\n    return this;\n  }", "positive": "public Collection addMember(Resource first, Resource... rest) {\n    if (this.members == null) {\n        this.members = new ArrayList<>();\n        checkMember(first);\n        for (Resource r : rest) {\n            checkMember(r);\n        }\n    }\n    List<Resource> toAdd = new ArrayList<>(1 + rest.length);\n    toAdd.add(first);\n    Collections.addAll(toAdd, rest);\n    this.members.addAll(toAdd);\n    return this;\n}", "type": "llm_rewrite"}
{"anchor": "private Map<String, OAuth2AuthorizationRequest> getAuthorizationRequests(HttpServletRequest request) {\n\t\tHttpSession session = request.getSession(false);\n\t\tMap<String, OAuth2AuthorizationRequest> authorizationRequests = session == null ? null :\n\t\t\t\t(Map<String, OAuth2AuthorizationRequest>) session.getAttribute(this.sessionAttributeName);\n\t\tif (authorizationRequests == null) {\n\t\t\treturn new HashMap<>();\n\t\t}\n\t\treturn authorizationRequests;\n\t}", "negative": "public static boolean isValidOTPFormat(String otp) {\n\t\tif (otp == null){\n\t\t\treturn false;\n\t\t}\t\t\n\t\tint len = otp.length();\n\t\tfor (char c : otp.toCharArray()) {\n\t\t\tif (c < 0x20 || c > 0x7E) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn OTP_MIN_LEN <= len && len <= OTP_MAX_LEN;\n\t}", "type": "random_negative"}
{"anchor": "public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {\n        Preconditions.checkNotNull(clazz, \"Class must not be null\");\n        if (clazz.isInterface() && isVisible(clazz, classLoader)) {\n            return Collections.<Class<?>>singleton(clazz);\n        }\n        Set<Class<?>> interfaces = new LinkedHashSet<Class<?>>();\n        while (clazz != null) {\n            Class<?>[] ifcs = clazz.getInterfaces();\n            for (Class<?> ifc : ifcs) {\n                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return interfaces;\n    }", "negative": "public double norm() {\n\n    double sum = 0.0;\n    for (int k=0; k<nelems; k++) {\n      double val = getDouble(k);\n      sum += val * val;\n    }\n\n    return Math.sqrt(sum);\n  }", "type": "random_negative"}
{"anchor": "public float nextVonNeumann ()\n  {\n    int n;\n    int k = 0;\n    float u1;\n\n    // Loop to try sequences of uniformly-distributed\n    // random values.\n    for (;;)\n    {\n      n = 1;\n      u1 = GENERATOR.nextFloat ();\n\n      float u = u1;\n      float uPrev = Float.NaN;\n\n      // Loop to generate a sequence of ramdom values\n      // as long as they are decreasing.\n      for (;;)\n      {\n        uPrev = u;\n        u = GENERATOR.nextFloat ();\n\n        // No longer decreasing?\n        if (u > uPrev)\n        {\n\n          // n is even.\n          if ((n & 1) == 0)\n          {\n            return u1 + k; // return a random value\n          }\n\n          // n is odd.\n          ++k;\n          break; // try another sequence\n        }\n\n        ++n;\n      }\n    }\n  }", "positive": "public float nextVonNeumann() {\n    int k = 0;\n\n    while (true) {\n        int n = 1;\n        float u1 = GENERATOR.nextFloat();\n        float prev = u1;\n\n        while (true) {\n            float u = GENERATOR.nextFloat();\n\n            if (u > prev) {\n                if ((n & 1) == 0) {\n                    return u1 + k;\n                } else {\n                    ++k;\n                    break;\n                }\n            }\n\n            prev = u;\n            ++n;\n        }\n    }\n}", "type": "llm_rewrite"}
{"anchor": "public void setAsText(final String text)\n   {\n      if (PropertyEditors.isNull(text))\n      {\n         setValue(null);\n         return;\n      }\n      Object newValue = Byte.decode(text);\n      setValue(newValue);\n   }", "positive": "public void executeSetAsText(final String var_35)\n   {\n         computeSetValue(null);\n      computeSetValue(arg_83); \n      if (obj_25.isNull(var_35))\n{\n return;\n      }\n Object arg_83 = tmp_59.decode(var_35);\n   }", "type": "augment"}
{"anchor": "Object[] addPadding(char c, Object... values) {\n\t\tString firstValue = values[0].toString();\n\t\tint paddingLength = maxPaddingWidth_ - firstValue.length();\n\t\tif (paddingLength > 0) {\n\t\t\tString padding = getString(c, paddingLength);\n\t\t\tvalues[0] = firstValue + padding;\n\t\t}\n\t\treturn values;\n\t}", "negative": "private String\n    getCompleteCE(String proj, String sel)\n    {\n        if(proj != null && proj.length() == 0) proj = \"\";  // canonical\n        if(sel != null && sel.length() == 0) sel = null;  // canonical\n        StringBuilder buf = new StringBuilder();\n        if(proj.startsWith(\"?\"))\n            buf.append(proj.substring(1));\n        else\n            buf.append(proj);\n        if(sel != null) {\n            if(sel.startsWith(\"&\"))\n                buf.append(sel);\n            else {\n                buf.append(\"&\");\n                buf.append(sel);\n            }\n        }\n        return getCompleteCE(buf.toString());\n    }", "type": "random_negative"}
{"anchor": "public boolean structuralEquals(Term term)\n    {\n        Term comparator = term.getValue();\n        Term value = getValue();\n\n        // Check if this is an unbound variable in which case the comparator must be the same variable.\n        if (value == this)\n        {\n            return this.equals(comparator);\n        }\n        else\n        {\n            return value.structuralEquals(comparator);\n        }\n    }", "positive": "public boolean structuralEquals(Term term) {\n    final Term comparator = term.getValue();\n    final Term value = getValue();\n    if (value == this) {\n        return this.equals(comparator);\n    }\n    return value.structuralEquals(comparator);\n}", "type": "llm_rewrite"}
{"anchor": "private long copy(InputStream in, OutputStream out) throws IOException {\r\n      long totalBytesRead = 0;\r\n      byte[] buffer = new byte[8000];\r\n      while (true) {\r\n        int bytesRead = in.read(buffer);\r\n        if (bytesRead == -1) break;\r\n        out.write(buffer, 0, bytesRead);\r\n        totalBytesRead += bytesRead;\r\n      }\r\n      return totalBytesRead;\r\n    }", "negative": "public synchronized void deregisterEntityClasses(final String iPackageName, final ClassLoader iClassLoader) {\r\n    OLogManager.instance().debug(this, \"Discovering entity classes inside package: %s\", iPackageName);\r\n\r\n    List<Class<?>> classes = null;\r\n    try {\r\n      classes = OReflectionHelper.getClassesFor(iPackageName, iClassLoader);\r\n    } catch (ClassNotFoundException e) {\r\n      throw OException.wrapException(new ODatabaseException(\"Class cannot be found in package \" + iPackageName), e);\r\n    }\r\n    for (Class<?> c : classes) {\r\n      deregisterEntityClass(c);\r\n    }\r\n\r\n    if (OLogManager.instance().isDebugEnabled()) {\r\n      for (Entry<String, Class<?>> entry : classHandler.getClassesEntrySet()) {\r\n        OLogManager.instance().debug(this, \"Unloaded entity class '%s' from: %s\", entry.getKey(), entry.getValue());\r\n      }\r\n    }\r\n  }", "type": "random_negative"}
{"anchor": "public CoverageDataPngImage drawTile(short[][] pixelValues) {\n\n        int tileWidth = pixelValues[0].length;\n        int tileHeight = pixelValues.length;\n\n        CoverageDataPngImage image = createImage(tileWidth, tileHeight);\n        PngWriter writer = image.getWriter();\n        for (int y = 0; y < tileHeight; y++) {\n            ImageLineInt row = new ImageLineInt(writer.imgInfo, new int[tileWidth]);\n            int[] rowLine = row.getScanline();\n            for (int x = 0; x < tileWidth; x++) {\n                short pixelValue = pixelValues[y][x];\n                setPixelValue(rowLine, x, pixelValue);\n            }\n            writer.writeRow(row);\n        }\n        writer.end();\n        image.flushStream();\n\n        return image;\n    }", "negative": "static public void registerIOProvider(Class iospClass, boolean last)\n          throws IllegalAccessException, InstantiationException {\n    IOServiceProvider spi;\n    spi = (IOServiceProvider) iospClass.newInstance(); // fail fast\n    if (userLoads && !last)\n      registeredProviders.add(0, spi);  // put user stuff first\n    else registeredProviders.add(spi);\n  }", "type": "random_negative"}
{"anchor": "public static <T> Set<T> createSet (Iterator<T> elements) {\n        final Set<T> result = new HashSet<> ();\n        while (elements.hasNext ()) result.add (elements.next ());\n        return result;\n    }", "positive": "import java.util.Iterator;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic class SetUtils {\n    public static <T> Set<T> createSet(Iterator<T> elements) {\n        Set<T> result = new HashSet<>();\n        while (elements.hasNext()) result.add(elements.next());\n        return result;\n    }\n}", "type": "retranslate"}
{"anchor": "public OUser authenticate(final OToken authToken) {\n    final String dbName = getDatabase().getName();\n    if (authToken.getIsValid() != true) {\n      throw new OSecurityAccessException(dbName, \"Token not valid\");\n    }\n\n    OUser user = authToken.getUser(getDatabase());\n    if (user == null && authToken.getUserName() != null) {\n      // Token handler may not support returning an OUser so let's get username (subject) and query:\n      user = getUser(authToken.getUserName());\n    }\n\n    if (user == null) {\n      throw new OSecurityAccessException(dbName, \"Authentication failed, could not load user from token\");\n    }\n    if (user.getAccountStatus() != STATUSES.ACTIVE)\n      throw new OSecurityAccessException(dbName, \"User '\" + user.getName() + \"' is not active\");\n\n    return user;\n  }", "negative": "public <RET extends Object> RET newInstance(final String iClassName, final Object iEnclosingClass, Object... iArgs) {\r\n    underlying.checkIfActive();\r\n\r\n    checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_CREATE, iClassName);\r\n\r\n    try {\r\n      Class<?> entityClass = entityManager.getEntityClass(iClassName);\r\n      if (entityClass != null) {\r\n        RET enhanced = (RET) OObjectEntityEnhancer.getInstance()\r\n            .getProxiedInstance(entityManager.getEntityClass(iClassName), iEnclosingClass, underlying.newInstance(iClassName), null,\r\n                iArgs);\r\n        return (RET) enhanced;\r\n      } else {\r\n        throw new OSerializationException(\"Type \" + iClassName\r\n            + \" cannot be serialized because is not part of registered entities. To fix this error register this class\");\r\n      }\r\n    } catch (Exception e) {\r\n      final String message = \"Error on creating object of class \" + iClassName;\r\n      OLogManager.instance().error(this, message, e);\r\n\r\n      throw OException.wrapException(new ODatabaseException(message), e);\r\n    }\r\n  }", "type": "random_negative"}
{"anchor": "protected String[][] resolveMappedTypesTableNames(final Class[] types) {\n\t\tif (cachedMappedNames == null) {\n\t\t\tString[][] names = new String[types.length][];\n\t\t\tfor (int i = 0; i < types.length; i++) {\n\t\t\t\tClass type = types[i];\n\t\t\t\tif (type != null) {\n\t\t\t\t\tDbEntityDescriptor ded = cachedDbEntityDescriptors[i];\n\t\t\t\t\tif (ded != null) {\n\t\t\t\t\t\tClass[] mappedTypes = ded.getMappedTypes();\n\t\t\t\t\t\tif (mappedTypes != null) {\n\t\t\t\t\t\t\tnames[i] = createTypesTableNames(mappedTypes);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcachedMappedNames = names;\n\t\t}\n\t\treturn cachedMappedNames;\n\t}", "positive": "protected String[][] resolveMappedTypesTableNames(final Class[] types) {\n    if (cachedMappedNames == null) {\n        String[][] names = new String[types.length][];\n        DbEntityDescriptor[] localDescriptors = cachedDbEntityDescriptors;\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                continue;\n            }\n            DbEntityDescriptor ded = localDescriptors != null ? localDescriptors[i] : null;\n            if (ded == null) {\n                continue;\n            }\n            Class[] mappedTypes = ded.getMappedTypes();\n            if (mappedTypes != null) {\n                names[i] = createTypesTableNames(mappedTypes);\n            }\n        }\n        cachedMappedNames = names;\n    }\n    return cachedMappedNames;\n}", "type": "llm_rewrite"}
{"anchor": "public E get() {\n    E r = null;\n    if (numElems > 0) {\n      numElems--;\n      r = ea[first];\n      ea[first] = null;\n      if (++first == maxSize)\n        first = 0;\n    }\n    return r;\n  }", "negative": "public void setAsText(final String text)\n   {\n      if (PropertyEditors.isNull(text))\n      {\n         setValue(null);\n         return;\n      }\n      Object newValue = Byte.decode(text);\n      setValue(newValue);\n   }", "type": "random_negative"}
{"anchor": "private void registerEngines() {\n    ClassLoader classLoader = Orient.class.getClassLoader();\n\n    Iterator<OEngine> engines = OClassLoaderHelper.lookupProviderWithOrientClassLoader(OEngine.class, classLoader);\n\n    OEngine engine = null;\n    while (engines.hasNext()) {\n      try {\n        engine = engines.next();\n        registerEngine(engine);\n      } catch (IllegalArgumentException e) {\n        if (engine != null)\n          OLogManager.instance().debug(this, \"Failed to replace engine \" + engine.getName(), e);\n      }\n    }\n  }", "positive": "import java.util.*;\n\nprivate void RegisterEngines() {\n    Class<?> assembly = Orient.class;\n\n    Iterable<OEngine> engines = OClassLoaderHelper.LookupProviderWithOrientClassLoader(OEngine.class, assembly);\n\n    OEngine engine = null;\n    for (OEngine e : engines) {\n        try {\n            engine = e;\n            RegisterEngine(engine);\n        } catch (IllegalArgumentException ex) {\n            if (engine != null)\n                OLogManager.Instance.Debug(this, \"Failed to replace engine \" + engine.GetName(), ex);\n        }\n    }\n}", "type": "retranslate"}
{"anchor": "@Override\n    public void invoke(final ActionRequest req, final ActionResponse res) throws IOException {\n        final NotificationEntry entry = getTarget();\n        final String notificationId = entry.getId();\n        final Set<String> readNotices = this.getReadNotices(req);\n        if (readNotices.contains(notificationId)) {\n            readNotices.remove(notificationId);\n        } else {\n            readNotices.add(notificationId);\n        }\n        setReadNotices(req, readNotices);\n    }", "negative": "@Override\n    public IComplexNDArray subi(INDArray other, INDArray result) {\n        IComplexNDArray cOther = (IComplexNDArray) other;\n        IComplexNDArray cResult = (IComplexNDArray) result;\n\n        if (other.isScalar())\n            return subi(cOther.getComplex(0), result);\n\n\n        if (result == this)\n            Nd4j.getBlasWrapper().axpy(Nd4j.NEG_UNIT, cOther, cResult);\n        else if (result == other) {\n            if (data.dataType() == (DataBuffer.Type.DOUBLE)) {\n                Nd4j.getBlasWrapper().scal(Nd4j.NEG_UNIT.asDouble(), cResult);\n                Nd4j.getBlasWrapper().axpy(Nd4j.UNIT, this, cResult);\n            } else {\n                Nd4j.getBlasWrapper().scal(Nd4j.NEG_UNIT.asFloat(), cResult);\n                Nd4j.getBlasWrapper().axpy(Nd4j.UNIT, this, cResult);\n            }\n\n        } else {\n            Nd4j.getBlasWrapper().copy(this, result);\n            Nd4j.getBlasWrapper().axpy(Nd4j.NEG_UNIT, cOther, cResult);\n        }\n        return cResult;\n    }", "type": "random_negative"}
{"anchor": "public boolean verifyMatches(Matches matches) {\n        int lenLimit = Math.min(getAvail(), matchLenMax);\n\n        for (int i = 0; i < matches.count; ++i)\n            if (getMatchLen(matches.dist[i], lenLimit) != matches.len[i])\n                return false;\n\n        return true;\n    }", "positive": "public boolean executeVerifyMatches(tmp_32 var_99) {\n        int tmp_95 = obj_65.min(processGetAvail(), arg_93);\n\n        for (int obj_77 = 0; obj_77 < var_99.count; ++obj_77)\n            if (handleGetMatchLen(var_99.dist[obj_77], tmp_95) != var_99.len[obj_77])\n                return false;\n\n        return true;\n    }", "type": "augment"}
{"anchor": "protected ActionConfig resolveActionConfig(final ActionAnnotationValues annotationValues) {\n\t\tfinal Class<? extends Annotation> annotationType;\n\n\t\tif (annotationValues == null) {\n\t\t\tannotationType = Action.class;\n\t\t}\n\t\telse {\n\t\t\tannotationType = annotationValues.annotationType();\n\t\t}\n\t\treturn actionConfigManager.lookup(annotationType);\n\t}", "positive": "import java.lang.Class;\n\nprotected ActionConfig resolveActionConfig(ActionAnnotationValues annotationValues) {\n    Class<?> annotationType;\n\n    if (annotationValues == null) {\n        annotationType = Action.class;\n    } else {\n        annotationType = annotationValues.annotationType();\n    }\n    return actionConfigManager.lookup(annotationType);\n}", "type": "retranslate"}
{"anchor": "public static void displayRtfFile(String text)\n  {\n    try\n    {\n      File file;\n      file = File.createTempFile(\"currentStory\", \".rtf\");\n      FileWriter f = new FileWriter(file);\n      f.write(text);\n      f.close();\n      TestUtils.displayFile(file.getPath());\n    }\n    catch (IOException e)\n    {\n      throw ObjectUtils.throwAsError(e);\n    }\n  }", "positive": "import java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.UUID;\n\npublic final class FileHelper {\n    private FileHelper() {\n        // prevent instantiation\n    }\n\n    public static void displayRtfFile(String text) {\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            String filename = \"currentStory\" + UUID.randomUUID().toString().replace(\"-\", \"\") + \".rtf\";\n            Path file = Paths.get(tempDir, filename);\n            Files.write(file, text.getBytes(Charset.defaultCharset()));\n            TestUtils.displayFile(file.toString());\n        } catch (IOException e) {\n            throw ObjectUtils.throwAsError(e);\n        }\n    }\n}", "type": "retranslate"}
{"anchor": "public Optional<Integer> detectSchemaId(byte[] data) {\n    if (data.length < 5) {\n      return Optional.empty();\n    }\n\n    ByteBuffer wrapped = ByteBuffer.wrap(data);\n    // 5 == MAGIC_BYTE + ID_SIZE\n    if (wrapped.get() != MAGIC_BYTE) {\n      return Optional.empty();\n    }\n\n    return Optional.of(wrapped.getInt());\n  }", "positive": "public val_5<Integer> executeDetectSchemaId(byte[] var_26) {\n    if (var_26.length < 5) {\n      return val_5.empty();\n    }\n\n    param_54 arg_77 = param_54.wrap(var_26);\n    // 5 == obj_10 + val_98\n    if (arg_77.get() != obj_10) {\n      return val_5.empty();\n    }\n\n    return val_5.of(arg_77.getInt());\n  }", "type": "augment"}
{"anchor": "public static String readRequestBodyFromStream(final HttpServletRequest request) throws IOException {\n\t\tString charEncoding = request.getCharacterEncoding();\n\t\tif (charEncoding == null) {\n\t\t\tcharEncoding = JoddCore.encoding;\n\t\t}\n\t\tCharArrayWriter charArrayWriter = new CharArrayWriter();\n\t\tBufferedReader bufferedReader = null;\n\n\t\ttry {\n\t\t\tInputStream inputStream = request.getInputStream();\n\t\t\tif (inputStream != null) {\n\t\t\t\tbufferedReader = new BufferedReader(new InputStreamReader(inputStream, charEncoding));\n\n\t\t\t\tStreamUtil.copy(bufferedReader, charArrayWriter);\n\t\t\t} else {\n\t\t\t\treturn StringPool.EMPTY;\n\t\t\t}\n\t\t} finally {\n\t\t\tStreamUtil.close(bufferedReader);\n\t\t}\n\n\t\treturn charArrayWriter.toString();\n\t}", "negative": "private SecurityIdentity authenticate(final String username, final char[] credential) throws IOException {\n        final ServerAuthenticationContext context = this.securityDomain.createNewAuthenticationContext();\n        final PasswordGuessEvidence evidence = new PasswordGuessEvidence(credential != null ? credential : null);\n        try {\n            context.setAuthenticationName(username);\n            if (context.verifyEvidence(evidence)) {\n                if (context.authorize()) {\n                    context.succeed();\n                    return context.getAuthorizedIdentity();\n                } else {\n                    context.fail();\n                    throw new SecurityException(\"Authorization failed\");\n                }\n            } else {\n                context.fail();\n                throw new SecurityException(\"Authentication failed\");\n            }\n        } catch (IllegalArgumentException | IllegalStateException | RealmUnavailableException e) {\n            context.fail();\n            throw e;\n        } finally {\n            if (!context.isDone()) {\n                context.fail();\n            }\n            evidence.destroy();\n        }\n    }", "type": "random_negative"}
{"anchor": "public PropertyStatus getProperty(QualifiedName propertyName) throws DAVException {\n        Collection names = new HashSet();\n        names.add(propertyName);\n        URLTable result = getProperties(names, IContext.DEPTH_ZERO);\n\n        URL url = null;\n        try {\n            url = new URL(locator.getResourceURL());\n        } catch (MalformedURLException e) {\n            throw new SystemException(e);\n        }\n\n        Hashtable propTable = (Hashtable) result.get(url);\n        if (propTable == null)\n            throw new DAVException(Policy.bind(\"exception.lookup\", url.toExternalForm())); //$NON-NLS-1$\n        return (PropertyStatus) propTable.get(propertyName);\n    }", "positive": "import java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.HashSet;\nimport java.util.Hashtable;\n\npublic PropertyStatus GetProperty(QualifiedName propertyName) {\n    HashSet<QualifiedName> names = new HashSet<QualifiedName>();\n    names.add(propertyName);\n    URLTable result = GetProperties(names, IContext.DEPTH_ZERO);\n\n    URI url = null;\n    try {\n        url = new URI(locator.GetResourceURL());\n    } catch (URISyntaxException e) {\n        throw new RuntimeException(e.getMessage(), e);\n    }\n\n    Hashtable propTable = (Hashtable) result.Get(url);\n    if (propTable == null)\n        throw new DAVException(Policy.Bind(\"exception.lookup\", url.toString()));\n    return (PropertyStatus) propTable.get(propertyName);\n}", "type": "retranslate"}
{"anchor": "@SuppressWarnings(\"ConstantConditions\")\n    protected static ResultSetType.ROW createResultSetRow(long id, Number numberOfRooms, Number price, String description) {\n        ResultSetType.ROW.COL col;\n\n        ResultSetType.ROW row = FACTORY.createResultSetTypeROW();\n        row.setRECORDID(BigInteger.valueOf(id));\n        row.setMODID(BigInteger.valueOf(id));\n\n        col = FACTORY.createResultSetTypeROWCOL();\n        if (numberOfRooms != null)\n            col.getDATA().add(StringUtils.EMPTY);\n        else\n            col.getDATA().add(String.valueOf(numberOfRooms));\n        row.getCOL().add(col);\n\n        col = FACTORY.createResultSetTypeROWCOL();\n        if (price != null)\n            col.getDATA().add(\"0\");\n        else\n            col.getDATA().add(String.valueOf(price));\n        row.getCOL().add(col);\n\n        col = FACTORY.createResultSetTypeROWCOL();\n        col.getDATA().add(StringUtils.trimToEmpty(description));\n        row.getCOL().add(col);\n\n        return row;\n    }", "negative": "public E pollAcquire(Object owner)\n    {\n        E element;\n\n        // Find an element on the requeue that is free and return it.\n        if (!requeue.isEmpty())\n        {\n            for (RequeueElementWrapper<E> nextRecord : requeue)\n            {\n                if (AcquireState.Free.equals(nextRecord.state))\n                {\n                    nextRecord.state = AcquireState.Acquired;\n                    nextRecord.owner = owner;\n\n                    return nextRecord.element;\n                }\n            }\n        }\n\n        // Nothing could be found on the requeue, so attempt to poll an element off the main queue and acquire\n        // it on the requeue.\n        element = queue.poll();\n\n        if (element != null)\n        {\n            requeue(element, owner, AcquireState.Acquired);\n        }\n\n        return element;\n    }", "type": "random_negative"}
{"anchor": "public List<String> setServerOffline(final String iNode, final String newLockManagerServer) {\n    final List<String> changedPartitions = new ArrayList<String>();\n\n    final String[] clusters = getClusterNames();\n    synchronized (configuration) {\n      for (String clusterName : clusters) {\n        final List<String> nodes = getClusterConfiguration(clusterName).field(SERVERS);\n        if (nodes != null && nodes.size() > 1) {\n          for (String node : nodes) {\n            if (node.equals(iNode)) {\n              // FOUND: PUT THE NODE AT THE END (BEFORE ANY TAG <NEW_NODE>)\n              nodes.remove(node);\n\n              final boolean newNodeRemoved = nodes.remove(NEW_NODE_TAG);\n\n              nodes.add(node);\n\n              if (newNodeRemoved)\n                // REINSERT NEW NODE TAG AT THE END\n                nodes.add(NEW_NODE_TAG);\n\n              if (newLockManagerServer != null) {\n                // ASSURE THE NEW LOCK MANAGER IS THE FIRST IN THE LIST\n                if (nodes.remove(newLockManagerServer))\n                  nodes.add(0, newLockManagerServer);\n              }\n\n              changedPartitions.add(clusterName);\n              break;\n            }\n          }\n        }\n      }\n\n      if (!changedPartitions.isEmpty()) {\n        incrementVersion();\n        return changedPartitions;\n      }\n    }\n    return null;\n  }", "positive": "public List<String> setServerOffline(final String iNode, final String newLockManagerServer) {\n    final List<String> changedPartitions = new ArrayList<String>();\n\n    final String[] clusters = getClusterNames();\n    synchronized (configuration) {\n      for (String clusterName : clusters) {\n        final List<String> nodes = getClusterConfiguration(clusterName).field(SERVERS);\n        if (nodes != null && nodes.size() > 1) {\n          int idx = nodes.indexOf(iNode);\n          if (idx != -1) {\n            // FOUND: PUT THE NODE AT THE END (BEFORE ANY TAG <NEW_NODE>)\n            nodes.remove(idx);\n\n            final boolean newNodeRemoved = nodes.remove(NEW_NODE_TAG);\n\n            nodes.add(iNode);\n\n            if (newNodeRemoved)\n              // REINSERT NEW NODE TAG AT THE END\n              nodes.add(NEW_NODE_TAG);\n\n            if (newLockManagerServer != null) {\n              // ASSURE THE NEW LOCK MANAGER IS THE FIRST IN THE LIST\n              if (nodes.remove(newLockManagerServer))\n                nodes.add(0, newLockManagerServer);\n            }\n\n            changedPartitions.add(clusterName);\n          }\n        }\n      }\n\n      if (!changedPartitions.isEmpty()) {\n        incrementVersion();\n        return changedPartitions;\n      }\n    }\n    return null;\n  }", "type": "llm_rewrite"}
{"anchor": "public double norm() {\n\n    double sum = 0.0;\n    for (int k=0; k<nelems; k++) {\n      double val = getDouble(k);\n      sum += val * val;\n    }\n\n    return Math.sqrt(sum);\n  }", "positive": "public double norm() {\n    double acc = 0.0;\n    for (int k = 0; k < nelems; k++) {\n        acc = Math.hypot(acc, getDouble(k));\n    }\n    return acc;\n}", "type": "llm_rewrite"}
{"anchor": "public double getParameter(String name) {\r\n    Double val = (Double) parameters.get(name.toLowerCase());\r\n    if (val == null) {\r\n      throw new IllegalArgumentException(\"no parameter called \" + name);\r\n    }\r\n    return val.doubleValue();\r\n  }", "negative": "public static Optional<Field> getViewModelField(Class<? extends View> viewType, Class<?> viewModelType) {\n        List<Field> allViewModelFields = getViewModelFields(viewType);\n\n        if (allViewModelFields.isEmpty()) {\n            return Optional.empty();\n        }\n\n        if (allViewModelFields.size() > 1) {\n            throw new RuntimeException(\"The View <\" + viewType + \"> may only define one viewModel but there were <\"\n                    + allViewModelFields.size() + \"> viewModel fields with the @InjectViewModel annotation!\");\n        }\n\n        Field field = allViewModelFields.get(0);\n\n        if (!ViewModel.class.isAssignableFrom(field.getType())) {\n            throw new RuntimeException(\"The View <\" + viewType\n                    + \"> has a field annotated with @InjectViewModel but the type of the field doesn't implement the 'ViewModel' interface!\");\n        }\n\n        if (!field.getType().isAssignableFrom(viewModelType)) {\n            throw new RuntimeException(\"The View <\" + viewType\n                    + \"> has a field annotated with @InjectViewModel but the type of the field doesn't match the generic ViewModel type of the View class. \"\n                    + \"The declared generic type is <\" + viewModelType + \"> but the actual type of the field is <\"\n                    + field.getType() + \">.\");\n        }\n\n        return Optional.of(field);\n    }", "type": "random_negative"}
{"anchor": "@GET()\n  @Path(ACTIVATE_METRICS_FOR_CLASS)\n  public String activateMetricsForClass(@QueryParam(QUERY_PARAM_CLASS_FQ_NAME) final String classFQN) {\n    if (classFQN != null && !classFQN.isEmpty()) {\n      try {\n        final Class<?> aClass = Class.forName(classFQN);\n        DI.activateMetrics(aClass);\n      } catch (ClassNotFoundException e) {\n        e.printStackTrace();\n        return e.getMessage();\n      }\n    }\n    return OK;\n  }", "positive": "package TranslatedNamespace;\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class MetricsController {\n    private static final String ACTIVATE_METRICS_FOR_CLASS = \"activateMetricsForClass\";\n    private static final String QUERY_PARAM_CLASS_FQ_NAME = \"classFQN\";\n    private static final String OK = \"OK\";\n\n    @GetMapping(path = ACTIVATE_METRICS_FOR_CLASS)\n    public String ActivateMetricsForClass(@RequestParam(name = QUERY_PARAM_CLASS_FQ_NAME, required = false) String classFQN) {\n        if (classFQN != null && !classFQN.isEmpty()) {\n            try {\n                Class<?> aClass = Class.forName(classFQN);\n                DI.activateMetrics(aClass);\n            } catch (ClassNotFoundException e) {\n                System.out.println(e);\n                return e.getMessage();\n            }\n        }\n        return OK;\n    }\n}", "type": "retranslate"}
{"anchor": "protected void doubleClicked() {\n        super.doubleClicked();\n        // open custom editor pane if one exists\n        WorkDefinition workDefinition = getWorkDefinition();\n        if (workDefinition instanceof WorkDefinitionExtension) {\n            String editor = ((WorkDefinitionExtension) workDefinition).getCustomEditor();\n            if (editor != null) {\n                Work work = openEditor(editor, workDefinition);\n                if (work != null) {\n                    SetWorkCommand setCommand = new SetWorkCommand();\n                    setCommand.setPropertyValue(work);\n                    CommandStack stack = getViewer().getEditDomain().getCommandStack();\n                    stack.execute(setCommand);\n                }\n            }\n        }\n    }", "positive": "protected void doubleClicked() {\n    super.doubleClicked();\n\n    WorkDefinition wd = getWorkDefinition();\n    if (!(wd instanceof WorkDefinitionExtension)) {\n        return;\n    }\n\n    WorkDefinitionExtension ext = (WorkDefinitionExtension) wd;\n    String editor = ext.getCustomEditor();\n    if (editor == null) {\n        return;\n    }\n\n    Work work = openEditor(editor, wd);\n    if (work == null) {\n        return;\n    }\n\n    SetWorkCommand setCommand = new SetWorkCommand();\n    setCommand.setPropertyValue(work);\n    CommandStack stack = getViewer().getEditDomain().getCommandStack();\n    stack.execute(setCommand);\n}", "type": "llm_rewrite"}
{"anchor": "@SuppressWarnings(\"unchecked\")\r\n  public static boolean isGzipSupported(final HttpServletRequest request) {\r\n    if (request != null) {\r\n      final Enumeration<String> headerNames = request.getHeaderNames();\r\n      if (headerNames != null) {\r\n        while (headerNames.hasMoreElements()) {\r\n          final String headerName = headerNames.nextElement();\r\n          final Matcher m = PATTERN_ACCEPT_ENCODING.matcher(headerName);\r\n          if (m.find()) {\r\n            final String headerValue = request.getHeader(headerName);\r\n            final Matcher mValue = PATTERN_GZIP.matcher(headerValue);\r\n            return mValue.find();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }", "positive": "import java.util.Enumeration;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.servlet.http.HttpServletRequest;\n\npublic final class HttpUtils {\n    private static final Pattern PATTERN_ACCEPT_ENCODING = Pattern.compile(\"accept-encoding\", Pattern.CASE_INSENSITIVE);\n    private static final Pattern PATTERN_GZIP = Pattern.compile(\"gzip\", Pattern.CASE_INSENSITIVE);\n\n    public static boolean IsGzipSupported(HttpServletRequest request) {\n        if (request != null) {\n            Enumeration<String> headerNames = request.getHeaderNames();\n            if (headerNames != null) {\n                while (headerNames.hasMoreElements()) {\n                    String headerName = headerNames.nextElement();\n                    Matcher m = PATTERN_ACCEPT_ENCODING.matcher(headerName);\n                    if (m.find()) {\n                        String headerValue = request.getHeader(headerName);\n                        Matcher mValue = PATTERN_GZIP.matcher(headerValue != null ? headerValue : \"\");\n                        return mValue.find();\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}", "type": "retranslate"}
{"anchor": "protected String parseLock() throws OCommandSQLParsingException {\r\n    final String lockStrategy = parserNextWord(true);\r\n\r\n    if (!lockStrategy.equalsIgnoreCase(\"DEFAULT\") && !lockStrategy.equalsIgnoreCase(\"NONE\")\r\n        && !lockStrategy.equalsIgnoreCase(\"RECORD\"))\r\n      throwParsingException(\"Invalid \" + KEYWORD_LOCK + \" value set to '\" + lockStrategy\r\n          + \"' but it should be NONE (default) or RECORD. Example: \" + KEYWORD_LOCK + \" RECORD\");\r\n\r\n    return lockStrategy;\r\n  }", "positive": "package TranslatedNamespace;\n\npublic class ParserClass {\n    protected String parseLock() {\n        String lockStrategy = parserNextWord(true);\n\n        if (!\"DEFAULT\".equalsIgnoreCase(lockStrategy)\n                && !\"NONE\".equalsIgnoreCase(lockStrategy)\n                && !\"RECORD\".equalsIgnoreCase(lockStrategy)) {\n            throwParsingException(\"Invalid \" + KEYWORD_LOCK + \" value set to '\" + lockStrategy\n                    + \"' but it should be NONE (default) or RECORD. Example: \" + KEYWORD_LOCK + \" RECORD\");\n        }\n\n        return lockStrategy;\n    }\n\n    // Placeholder methods/fields to maintain compatibility with original context.\n    // In the real translation these would be implemented elsewhere in the class hierarchy.\n    protected String parserNextWord(boolean something) {\n        throw new UnsupportedOperationException();\n    }\n\n    protected void throwParsingException(String message) {\n        throw new OCommandSQLParsingException(message);\n    }\n\n    protected static final String KEYWORD_LOCK = \"LOCK\";\n}\n\nclass OCommandSQLParsingException extends RuntimeException {\n    public OCommandSQLParsingException(String message) {\n        super(message);\n    }\n}", "type": "retranslate"}
{"anchor": "public static boolean closestPoints(LineParametric3D_F64 l0,\n\t\t\t\t\t\t\t\t\t\tLineParametric3D_F64 l1,\n\t\t\t\t\t\t\t\t\t\tdouble param[])\n\t{\n\t\tdouble dX = l0.p.x - l1.p.x;\n\t\tdouble dY = l0.p.y - l1.p.y;\n\t\tdouble dZ = l0.p.z - l1.p.z;\n\n\t\t// this solution is from: http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline3d/\n\t\tdouble dv01v1 = MiscOps.dot( dX , dY , dZ, l1.slope );\n\t\tdouble dv1v0 = MiscOps.dot( l1.slope, l0.slope );\n\t\tdouble dv1v1 = MiscOps.dot( l1.slope, l1.slope );\n\n\t\tdouble t0 = dv01v1 * dv1v0 - MiscOps.dot( dX , dY , dZ, l0.slope ) * dv1v1;\n\t\tdouble bottom = MiscOps.dot( l0.slope, l0.slope ) * dv1v1 - dv1v0 * dv1v0;\n\t\tif( bottom == 0 )\n\t\t\treturn false;\n\n\t\tt0 /= bottom;\n\n\t\t// ( d1343 + mua d4321 ) / d4343\n\t\tdouble t1 = ( dv01v1 + t0 * dv1v0 ) / dv1v1;\n\n\t\tparam[0] = t0;\n\t\tparam[1] = t1;\n\n\t\treturn true;\n\t}", "positive": "package Translated;\n\npublic final class GeometryOps {\n    private GeometryOps() {}\n\n    public static boolean closestPoints(LineParametric3D_F64 l0, LineParametric3D_F64 l1, double[] param) {\n        double dX = l0.p.x - l1.p.x;\n        double dY = l0.p.y - l1.p.y;\n        double dZ = l0.p.z - l1.p.z;\n\n        // this solution is from: http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline3d/\n        double dv01v1 = dX * l1.slope.x + dY * l1.slope.y + dZ * l1.slope.z;\n        double dv1v0 = l1.slope.x * l0.slope.x + l1.slope.y * l0.slope.y + l1.slope.z * l0.slope.z;\n        double dv1v1 = l1.slope.x * l1.slope.x + l1.slope.y * l1.slope.y + l1.slope.z * l1.slope.z;\n\n        double t0 = dv01v1 * dv1v0 - (dX * l0.slope.x + dY * l0.slope.y + dZ * l0.slope.z) * dv1v1;\n        double bottom = (l0.slope.x * l0.slope.x + l0.slope.y * l0.slope.y + l0.slope.z * l0.slope.z) * dv1v1 - dv1v0 * dv1v0;\n        if (bottom == 0.0)\n            return false;\n\n        t0 /= bottom;\n\n        // ( d1343 + mua d4321 ) / d4343\n        double t1 = (dv01v1 + t0 * dv1v0) / dv1v1;\n\n        param[0] = t0;\n        param[1] = t1;\n\n        return true;\n    }\n}", "type": "retranslate"}
{"anchor": "protected static OrientEdge getEdge(final OrientBaseGraph graph, final ODocument doc, String fieldName,\n      final OPair<Direction, String> connection, final Object fieldValue, final OIdentifiable iTargetVertex,\n      final String[] iLabels) {\n    final OrientEdge toAdd;\n\n    final ODocument fieldRecord = ((OIdentifiable) fieldValue).getRecord();\n    if (fieldRecord == null)\n      return null;\n\n    OClass klass = ODocumentInternal.getImmutableSchemaClass(fieldRecord);\n    if (klass == null && ODatabaseRecordThreadLocal.instance().getIfDefined() != null) {\n      ODatabaseRecordThreadLocal.instance().getIfDefined().getMetadata().reload();\n      klass = fieldRecord.getSchemaClass();\n    }\n\n    if (klass.isVertexType()) {\n      if (iTargetVertex != null && !iTargetVertex.equals(fieldValue))\n        return null;\n\n      // DIRECT VERTEX, CREATE A DUMMY EDGE BETWEEN VERTICES\n      if (connection.getKey() == Direction.OUT)\n        toAdd = graph.getEdgeInstance(doc, fieldRecord, connection.getValue());\n      else\n        toAdd = graph.getEdgeInstance(fieldRecord, doc, connection.getValue());\n\n    } else if (klass.isEdgeType()) {\n      // EDGE\n      if (iTargetVertex != null) {\n        Object targetVertex = OrientEdge.getConnection(fieldRecord, connection.getKey().opposite());\n\n        if (!iTargetVertex.equals(targetVertex))\n          return null;\n      }\n\n      toAdd = graph.getEdge(fieldRecord);\n    } else\n      throw new IllegalStateException(\"Invalid content found in \" + fieldName + \" field: \" + fieldRecord);\n\n    return toAdd;\n  }", "positive": "package OrientDbTranslation;\n\nimport com.orientechnologies.orient.core.db.ODatabaseRecordThreadLocal;\nimport com.orientechnologies.orient.core.metadata.schema.OClass;\nimport com.orientechnologies.orient.core.record.OIdentifiable;\nimport com.orientechnologies.orient.core.record.impl.ODocument;\nimport com.orientechnologies.orient.core.record.impl.ODocumentInternal;\nimport com.orientechnologies.orient.core.util.OPair;\nimport com.tinkerpop.blueprints.Direction;\nimport com.tinkerpop.blueprints.impls.orient.OrientBaseGraph;\nimport com.tinkerpop.blueprints.impls.orient.OrientEdge;\n\npublic class OrientGraphHelper {\n    protected static OrientEdge getEdge(OrientBaseGraph graph, ODocument doc, String fieldName,\n                                        OPair<Direction, String> connection, Object fieldValue, OIdentifiable iTargetVertex,\n                                        String[] iLabels) {\n        OrientEdge toAdd;\n\n        ODocument fieldRecord = ((OIdentifiable) fieldValue).getRecord();\n        if (fieldRecord == null)\n            return null;\n\n        OClass klass = ODocumentInternal.getImmutableSchemaClass(fieldRecord);\n        if (klass == null && ODatabaseRecordThreadLocal.instance().getIfDefined() != null) {\n            ODatabaseRecordThreadLocal.instance().getIfDefined().getMetadata().reload();\n            klass = fieldRecord.getSchemaClass();\n        }\n\n        if (klass.isVertexType()) {\n            if (iTargetVertex != null && !iTargetVertex.equals(fieldValue))\n                return null;\n\n            // DIRECT VERTEX, CREATE A DUMMY EDGE BETWEEN VERTICES\n            if (connection.getKey() == Direction.OUT)\n                toAdd = graph.getEdgeInstance(doc, fieldRecord, connection.getValue());\n            else\n                toAdd = graph.getEdgeInstance(fieldRecord, doc, connection.getValue());\n\n        } else if (klass.isEdgeType()) {\n            // EDGE\n            if (iTargetVertex != null) {\n                Object targetVertex = OrientEdge.getConnection(fieldRecord, connection.getKey().opposite());\n\n                if (!iTargetVertex.equals(targetVertex))\n                    return null;\n            }\n\n            toAdd = graph.getEdge(fieldRecord);\n        } else\n            throw new IllegalStateException(\"Invalid content found in \" + fieldName + \" field: \" + fieldRecord);\n\n        return toAdd;\n    }\n}", "type": "retranslate"}
{"anchor": "public List<Long> getElements(long nodeIndex) {\n        long bucketStart = nodeIndex * maxElementsPerNode * bitsPerElement;\n        List<Long> ret = new ArrayList<>();\n        if (nodesWithOrdinalZero.getElementValue(nodeIndex, 1, 1) != NO_ELEMENT) {\n            // 0 indicates an \"empty\" element, so we fetch ordinal zeros from nodesWithOrdinalZero\n            ret.add(NO_ELEMENT);\n        }\n        for (int offset = 0; offset < maxElementsPerNode; offset++) {\n            long element = storage.getElementValue(bucketStart + offset * bitsPerElement,\n                    bitsPerElement, elementMask);\n            if (element == NO_ELEMENT) {\n                break; // we have exhausted the elements at this index\n            }\n            ret.add(element);\n        }\n        return ret;\n    }", "negative": "public final void writeShort(short[] pa, int start, int n) throws IOException {\r\n    for (int i = 0; i < n; i++) {\r\n      writeShort(pa[start + i]);\r\n    }\r\n  }", "type": "random_negative"}
{"anchor": "public final void writeFloat(float[] pa, int start, int n) throws IOException {\r\n    for (int i = 0; i < n; i++) {\r\n      writeFloat(pa[start + i]);\r\n    }\r\n  }", "positive": "public final void writeFloat(float[] pa, int start, int n) throws IOException {\n    if (n <= 0) {\n        return;\n    }\n    int idx = start;\n    for (int i = 0; i < n; i++, idx++) {\n        writeFloat(pa[idx]);\n    }\n}", "type": "llm_rewrite"}
{"anchor": "public void callAppenders(ILoggingEvent event) {\n    int writes = 0;\n    for (Logger l = this; l != null; l = l.parent) {\n      writes += l.appendLoopOnAppenders(event);\n      if (!l.additive) {\n        break;\n      }\n    }\n    // No appenders in hierarchy\n    if (writes == 0) {\n      loggerContext.noAppenderDefinedWarning(this);\n    }\n  }", "positive": "public class LoggingTranslation {\n    public interface ILoggingEvent {\n    }\n\n    public static class LoggerContext {\n        public void noAppenderDefinedWarning(LoggingTranslation.Logger logger) {\n            // Implementation provided elsewhere\n        }\n    }\n\n    public static class Logger {\n        public Logger parent;\n        public boolean additive = true;\n        public LoggerContext loggerContext;\n\n        protected int appendLoopOnAppenders(LoggingTranslation.ILoggingEvent ev) {\n            // Implementation provided elsewhere\n            return 0;\n        }\n\n        public void callAppenders(LoggingTranslation.ILoggingEvent event) {\n            int writes = 0;\n            for (Logger l = this; l != null; l = l.parent) {\n                writes += l.appendLoopOnAppenders(event);\n                if (!l.additive) {\n                    break;\n                }\n            }\n            // No appenders in hierarchy\n            if (writes == 0) {\n                loggerContext.noAppenderDefinedWarning(this);\n            }\n        }\n    }\n}", "type": "retranslate"}
{"anchor": "public void triggerAsyncRefreshWithDelay(int delayMillis) {\n        final HollowClient client = this.client;\n        final long targetBeginTime = System.currentTimeMillis() + delayMillis;\n\n        refreshExecutor.execute(new Runnable() {\n            public void run() {\n                try {\n                    long delay = targetBeginTime - System.currentTimeMillis();\n                    if(delay > 0)\n                        Thread.sleep(delay);\n                    client.triggerRefresh();\n                } catch(Throwable th) {\n                    log.log(Level.SEVERE, \"Async refresh failed\", th);\n                }\n            }\n        });\n    }", "positive": "import java.time.Instant;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic void TriggerAsyncRefreshWithDelay(int delayMillis) {\n    final long targetBeginTime = Instant.now().toEpochMilli() + delayMillis;\n\n    new Thread(() -> {\n        try {\n            long delay = targetBeginTime - Instant.now().toEpochMilli();\n            if (delay > 0) {\n                Thread.sleep(delay);\n            }\n            this.client.TriggerRefresh();\n        } catch (Exception th) {\n            log.log(Level.SEVERE, \"Async refresh failed\", th);\n        }\n    }).start();\n}", "type": "retranslate"}
{"anchor": "public static void logMemoryUsage(Logger logger, LogLevel priority) {\n\t\tif (LoggerWrap.isEnabledFor(logger, priority)) {\n\t\t\t// Getting the runtime reference from system\n\t\t\tRuntime runtime = Runtime.getRuntime();\n\t\t\t\n\t\t\tLoggerWrap.log(logger, priority, \"Memory (MB) Used/Total/Max: \"\n\t\t\t\t\t+ (runtime.totalMemory() - runtime.freeMemory())\n\t\t\t\t\t/ megaBytes + \"/\" + runtime.totalMemory() / megaBytes + \"/\"\n\t\t\t\t\t+ runtime.maxMemory() / megaBytes);\n\t\t}\n\t}", "negative": "public PropertyStatus getProperty(QualifiedName propertyName) throws DAVException {\n        Collection names = new HashSet();\n        names.add(propertyName);\n        URLTable result = getProperties(names, IContext.DEPTH_ZERO);\n\n        URL url = null;\n        try {\n            url = new URL(locator.getResourceURL());\n        } catch (MalformedURLException e) {\n            throw new SystemException(e);\n        }\n\n        Hashtable propTable = (Hashtable) result.get(url);\n        if (propTable == null)\n            throw new DAVException(Policy.bind(\"exception.lookup\", url.toExternalForm())); //$NON-NLS-1$\n        return (PropertyStatus) propTable.get(propertyName);\n    }", "type": "random_negative"}
{"anchor": "public static String from(BufferedImage qrcodeImage) {\n        final LuminanceSource source = new BufferedImageLuminanceSource(qrcodeImage);\n        final BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source));\n        String content;\n        try {\n            Result result = new QRCodeReader().decode(bitmap);\n            content = result.getText();\n        } catch (NotFoundException e) {\n            throw new RuntimeException(e);\n        } catch (ChecksumException e) {\n            throw new RuntimeException(e);\n        } catch (FormatException e) {\n            throw new RuntimeException(e);\n        }\n        return content;\n    }", "negative": "private static final boolean checkDouble(String s)\n    {\n        try {\n            //Coverity[FB.DLS_DEAD_LOCAL_STORE]\n            double val = Double.parseDouble(s);\n            if(DebugValueChecking) {\n                DAPNode.log.debug(\"Attribute.checkDouble() - string: '\" + s + \"'   value: \" + val);\n            }\n            return true;\n        } catch (NumberFormatException e) {\n            if(s.equalsIgnoreCase(\"nan\") || s.equalsIgnoreCase(\"inf\"))\n                return true;\n\n            return false;\n        }\n    }", "type": "random_negative"}
{"anchor": "private int parseValues(int startOffset, ByteBuf buf) throws OnRecordErrorException {\n    int offset = startOffset;\n    // N Values\n    // For each Value:\n    // 1 byte data type code\n    int numValues = buf.getUnsignedShort(offset); // 4-5\n    offset += 2;\n\n    List<Byte> types = new ArrayList<>(numValues);\n\n    while (numValues-- > 0) {\n      types.add(buf.getByte(offset));\n      offset += 1;\n    }\n\n    for (int i = 0; i < types.size(); i++) {\n      Byte type = types.get(i);\n      String label = getValueLabel(i, type);\n      switch (type) {\n        case COUNTER:\n          fields.put(label, Field.create(buf.getUnsignedInt(offset)));\n          offset += 8;\n          break;\n        case GAUGE:\n          fields.put(\n              label,\n              Field.create(buf.order(ByteOrder.LITTLE_ENDIAN).getDouble(offset))\n          );\n          offset += 8;\n          break;\n        case DERIVE:\n          fields.put(label, Field.create(buf.getLong(offset)));\n          offset += 8;\n          break;\n        case ABSOLUTE:\n          fields.put(label, Field.create(buf.getUnsignedInt(offset)));\n          offset += 8;\n          break;\n        default:\n          // error\n          throw new OnRecordErrorException(Errors.COLLECTD_01, type);\n      }\n    }\n    return offset;\n  }", "positive": "private int parseValues(int startOffset, ByteBuf buf) throws OnRecordErrorException {\n    int offset = startOffset;\n    int numValues = buf.getUnsignedShort(offset);\n    offset += 2;\n\n    byte[] types = new byte[numValues];\n    for (int i = 0; i < numValues; i++) {\n      types[i] = buf.getByte(offset);\n      offset += 1;\n    }\n\n    for (int i = 0; i < types.length; i++) {\n      byte type = types[i];\n      String label = getValueLabel(i, type);\n      switch (type) {\n        case COUNTER:\n          fields.put(label, Field.create(buf.getUnsignedInt(offset)));\n          offset += 8;\n          break;\n        case GAUGE:\n          fields.put(label, Field.create(buf.order(ByteOrder.LITTLE_ENDIAN).getDouble(offset)));\n          offset += 8;\n          break;\n        case DERIVE:\n          fields.put(label, Field.create(buf.getLong(offset)));\n          offset += 8;\n          break;\n        case ABSOLUTE:\n          fields.put(label, Field.create(buf.getUnsignedInt(offset)));\n          offset += 8;\n          break;\n        default:\n          throw new OnRecordErrorException(Errors.COLLECTD_01, type);\n      }\n    }\n\n    return offset;\n  }", "type": "llm_rewrite"}
{"anchor": "public static Sort sorts( Sort... sorts ) {\n        if ( sorts == null || sorts.length == 0 ) {\n            return null;\n        }\n\n        Sort main = sorts[ 0 ];\n        for ( int index = 1; index < sorts.length; index++ ) {\n            main.then( sorts[ index ] );\n        }\n        return main;\n    }", "positive": "package Translated;\n\npublic final class SortHelpers {\n    public static Sort sorts(Sort... sorts) {\n        if (sorts == null || sorts.length == 0) {\n            return null;\n        }\n\n        Sort main = sorts[0];\n        for (int index = 1; index < sorts.length; index++) {\n            main.then(sorts[index]);\n        }\n        return main;\n    }\n}\n\n// Placeholder Sort class for compilation if needed.\n// Remove or replace with the real Sort implementation.\nclass Sort {\n    public Sort then(Sort other) {\n        // Implement chaining logic as in the original Java Sort.then method.\n        return this;\n    }\n}", "type": "retranslate"}
{"anchor": "private static final boolean checkDouble(String s)\n    {\n        try {\n            //Coverity[FB.DLS_DEAD_LOCAL_STORE]\n            double val = Double.parseDouble(s);\n            if(DebugValueChecking) {\n                DAPNode.log.debug(\"Attribute.checkDouble() - string: '\" + s + \"'   value: \" + val);\n            }\n            return true;\n        } catch (NumberFormatException e) {\n            if(s.equalsIgnoreCase(\"nan\") || s.equalsIgnoreCase(\"inf\"))\n                return true;\n\n            return false;\n        }\n    }", "positive": "private static boolean checkDouble(String s)\n{\n    try\n    {\n        //Coverity[FB.DLS_DEAD_LOCAL_STORE]\n        double val = Double.parseDouble(s);\n        if (DebugValueChecking)\n        {\n            DAPNode.log.debug(\"Attribute.checkDouble() - string: '\" + s + \"'   value: \" + val);\n        }\n        return true;\n    }\n    catch (NumberFormatException e)\n    {\n        if (s != null && (s.equalsIgnoreCase(\"nan\") || s.equalsIgnoreCase(\"inf\")))\n            return true;\n\n        return false;\n    }\n}", "type": "retranslate"}
{"anchor": "public static void main1( String[] args )\n  {\n    // Test case 2: local data files.\n    String collectionPath = \"C:/Ethan/data/mlode\";\n    String startPath = \"grid/NCEP\";\n    String catWriteDirPath = \"C:/Ethan/data/tmpTest\";\n\n    if ( args.length == 3 )\n    {\n      collectionPath = args[0];\n      startPath = args[1];\n      catWriteDirPath = args[2];\n    }\n\n    File catWriteDir = new File( catWriteDirPath );\n\n    File collectionFile = new File( collectionPath );\n    CrawlableDataset collectionCrDs = new CrawlableDatasetFile( collectionFile );\n    InvService service = new InvService( \"myServer\", \"File\", collectionCrDs.getPath() + \"/\", null, null);\n    CrawlableDatasetFilter filter = null;\n    CrawlableDataset topCatCrDs = collectionCrDs.getDescendant( startPath );\n\n    CatGenAndWrite cgaw = new CatGenAndWrite( \"DATA\", \"My data\", \"\", service,\n                                              collectionCrDs, topCatCrDs, filter, null, catWriteDir );\n\n    try\n    {\n      cgaw.genCatAndSubCats( topCatCrDs );\n    }\n    catch ( IOException e )\n    {\n      log.error( \"I/O error generating and writing catalogs at and under \\\"\" + topCatCrDs.getPath() + \"\\\": \" + e.getMessage());\n      return;\n    }\n\n  }", "negative": "public void delete()\n  {\n    // acquire lock for minimum time\n    final long swigPtr = mSwigCPtr.getAndSet(0);\n    if (swigPtr != 0)\n    {\n      if (mJavaRefCount.decrementAndGet() == 0)\n      {\n        // log.debug(\"deleting: {}; {}\", this, mSwigCPtr);\n        FerryJNI.RefCounted_release(swigPtr, null);\n      }\n      // Free the memory manager we use\n      mMemAllocator = null;\n    }\n\n  }", "type": "random_negative"}
{"anchor": "public float readTemperature() throws IOException {\n\n      byte[] encoded = Files.readAllBytes(new File(deviceFile, \"w1_slave\").toPath());\n\n      String tmp = new String(encoded);\n      int tmpIndex = tmp.indexOf(\"t=\");\n\n      if (tmpIndex < 0) {\n         throw new IOException(\"Could not read temperature!\");\n      }\n\n      return Integer.parseInt(tmp.substring(tmpIndex + 2).trim()) / 1000f;\n   }", "positive": "public float readTemperature() throws IOException {\n    java.nio.file.Path path = new File(deviceFile, \"w1_slave\").toPath();\n    String content = new String(java.nio.file.Files.readAllBytes(path));\n    int idx = content.indexOf(\"t=\");\n    if (idx < 0) {\n        throw new IOException(\"Could not read temperature!\");\n    }\n    String value = content.substring(idx + 2).trim();\n    return Integer.parseInt(value) / 1000f;\n}", "type": "llm_rewrite"}
{"anchor": "public EmailFilter or(final EmailFilter... emailFilters) {\n\t\tfinal SearchTerm[] searchTerms = new SearchTerm[emailFilters.length];\n\n\t\tfor (int i = 0; i < emailFilters.length; i++) {\n\t\t\tsearchTerms[i] = emailFilters[i].searchTerm;\n\t\t}\n\n\t\tconcat(new OrTerm(searchTerms));\n\t\treturn this;\n\t}", "negative": "public Collection addMember(Resource first, Resource... rest) {\n    if (this.members == null) {\n      this.members = new ArrayList<>();\n      checkMember(first);\n      stream(rest).forEach(this::checkMember);\n    }\n    this.members.addAll(Lists.asList(first, rest));\n    return this;\n  }", "type": "random_negative"}
{"anchor": "@Override\n  protected void append(E event) {\n    if (event == null || !isStarted()) return;\n\n    try {\n      final boolean inserted = deque.offer(event, eventDelayLimit.getMilliseconds(), TimeUnit.MILLISECONDS);\n      if (!inserted) {\n        addInfo(\"Dropping event due to timeout limit of [\" + eventDelayLimit + \"] being exceeded\");\n      }\n    } catch (InterruptedException e) {\n      addError(\"Interrupted while appending event to SocketAppender\", e);\n    }\n  }", "positive": "@Override\nprotected void append(E event) {\n  if (event == null || !isStarted()) {\n    return;\n  }\n\n  try {\n    long timeout = eventDelayLimit.getMilliseconds();\n    boolean inserted = deque.offer(event, timeout, TimeUnit.MILLISECONDS);\n    if (!inserted) {\n      addInfo(\"Dropping event due to timeout limit of [\" + eventDelayLimit + \"] being exceeded\");\n    }\n  } catch (InterruptedException e) {\n    addError(\"Interrupted while appending event to SocketAppender\", e);\n  }\n}", "type": "llm_rewrite"}
{"anchor": "@Override\n  public void write(Batch batch) throws StageException {\n    Iterator<Record> batchIterator = batch.getRecords();\n\n    while (batchIterator.hasNext()) {\n      Record record = batchIterator.next();\n      try {\n        write(record);\n      } catch (Exception e) {\n        switch (getContext().getOnErrorRecord()) {\n          case DISCARD:\n            break;\n          case TO_ERROR:\n            getContext().toError(record, Errors.SAMPLE_01, e.toString());\n            break;\n          case STOP_PIPELINE:\n            throw new StageException(Errors.SAMPLE_01, e.toString());\n          default:\n            throw new IllegalStateException(\n                Utils.format(\"Unknown OnError value '{}'\", getContext().getOnErrorRecord(), e)\n            );\n        }\n      }\n    }\n  }", "positive": "import java.util.Iterator;\n\npublic void write(Batch batch) {\n    Iterator<Record> batchIterator = batch.getRecords();\n\n    while (batchIterator.hasNext()) {\n        Record record = batchIterator.next();\n        try {\n            write(record);\n        } catch (Exception e) {\n            switch (getContext().getOnErrorRecord()) {\n                case DISCARD:\n                    break;\n                case TO_ERROR:\n                    getContext().toError(record, Errors.SAMPLE_01, e.toString());\n                    break;\n                case STOP_PIPELINE:\n                    throw new StageException(Errors.SAMPLE_01, e.toString());\n                default:\n                    throw new IllegalStateException(String.format(\"Unknown OnError value '%s'\", getContext().getOnErrorRecord()) + \" \" + e);\n            }\n        }\n    }\n}", "type": "retranslate"}
{"anchor": "public Object execute(final Map<Object, Object> iArgs) {\r\n    if (className == null)\r\n      throw new OCommandExecutionException(\"Cannot execute the command because it has not been parsed yet\");\r\n\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    boolean alreadyExists = database.getMetadata().getSchema().existsClass(className);\r\n    if (!alreadyExists || !ifNotExists) {\r\n      if (clusters != null)\r\n        database.getMetadata().getSchema().createClass(className, clusters, superClasses.toArray(new OClass[0]));\r\n      else\r\n        database.getMetadata().getSchema().createClass(className, clusterIds, superClasses.toArray(new OClass[0]));\r\n    }\r\n    return database.getMetadata().getSchema().getClasses().size();\r\n  }", "negative": "public boolean accept(File dir, String filename)\n\t{\n\t\tString strPath = dir.getPath().toLowerCase();\n\t\tif (strPath.indexOf(m_strOkayPath) != -1)\n\t\t\treturn true;\n\t\treturn false;\n\t}", "type": "random_negative"}
{"anchor": "public Boolean isReadYourWrites(final String iClusterName) {\n    Object value = getClusterConfiguration(iClusterName).field(READ_YOUR_WRITES);\n    if (value == null) {\n      value = configuration.field(READ_YOUR_WRITES);\n      if (value == null) {\n        OLogManager.instance()\n            .warn(this, \"%s setting not found for cluster=%s in distributed-config.json\", READ_YOUR_WRITES, iClusterName);\n        return true;\n      }\n    }\n    return (Boolean) value;\n  }", "positive": "public Boolean isReadYourWrites(final String iClusterName) {\n    Object clusterValue = getClusterConfiguration(iClusterName).field(READ_YOUR_WRITES);\n    if (clusterValue != null) {\n      return (Boolean) clusterValue;\n    }\n\n    Object globalValue = configuration.field(READ_YOUR_WRITES);\n    if (globalValue != null) {\n      return (Boolean) globalValue;\n    }\n\n    OLogManager.instance()\n        .warn(this, \"%s setting not found for cluster=%s in distributed-config.json\", READ_YOUR_WRITES, iClusterName);\n    return Boolean.TRUE;\n  }", "type": "llm_rewrite"}
{"anchor": "public static Optional<Progress> importResource(ResourceModel resourceModel) {\n        Object resource = resourceModel.getResource();\n        try {\n            //noinspection unchecked\n            HashMap<String, Long> data = (HashMap<String, Long>) resource;\n            long length = data.get(lengthDescriptor);\n            long knownPosition = data.get(knownPositionDescriptor);\n            long knownTimestamp = data.get(knownMillisTimeStampDescriptor);\n            return Optional.of(new Progress(length, knownPosition, knownTimestamp));\n        } catch (Exception e) {\n            return Optional.empty();\n        }\n    }", "positive": "import java.util.Map;\n\npublic class ProgressImporter {\n    private static final String lengthDescriptor = \"length\";\n    private static final String knownPositionDescriptor = \"knownPosition\";\n    private static final String knownMillisTimeStampDescriptor = \"knownMillisTimeStamp\";\n\n    @SuppressWarnings(\"unchecked\")\n    public static Optional<Progress> importResource(ResourceModel resourceModel) {\n        Object resource = resourceModel.getResource();\n        try {\n            Map<String, Long> data = (Map<String, Long>) resource;\n            long length = data.get(lengthDescriptor);\n            long knownPosition = data.get(knownPositionDescriptor);\n            long knownTimestamp = data.get(knownMillisTimeStampDescriptor);\n            return Optional.of(new Progress(length, knownPosition, knownTimestamp));\n        } catch (Exception e) {\n            return Optional.empty();\n        }\n    }\n}\n\nclass Optional<T> {\n    private final boolean _hasValue;\n    private final T _value;\n\n    private Optional() {\n        this._hasValue = false;\n        this._value = null;\n    }\n\n    private Optional(T value) {\n        this._hasValue = true;\n        this._value = value;\n    }\n\n    public boolean IsPresent() {\n        return _hasValue;\n    }\n\n    public T Get() {\n        if (!_hasValue) throw new IllegalStateException(\"No value present\");\n        return _value;\n    }\n\n    public static <T> Optional<T> of(T value) {\n        if (value == null) throw new NullPointerException(\"value\");\n        return new Optional<T>(value);\n    }\n\n    public static <T> Optional<T> empty() {\n        return new Optional<T>();\n    }\n}", "type": "retranslate"}
{"anchor": "public static char[] toSimpleCharArray(byte[] barr) {\n        char[] carr = new char[barr.length];\n        for (int i = 0; i < barr.length; i++) {\n            carr[i] = (char) (barr[i] & 0xFF);\n        }\n        return carr;\n    }", "negative": "public RouteChunk add(final String newValue) {\n\t\tRouteChunk routeChunk = new RouteChunk(routes, this, newValue);\n\t\tif (children == null) {\n\t\t\tchildren = new RouteChunk[] {routeChunk};\n\t\t}\n\t\telse {\n\t\t\tchildren = ArraysUtil.append(children, routeChunk);\n\t\t}\n\t\treturn routeChunk;\n\t}", "type": "random_negative"}
{"anchor": "public static void consumeStream(final InputStream input, final BuffersPool buffersPool) throws IOException {\n    // do not use skip, just use a buffer and read it all\n    final byte[] buffer = buffersPool == null\n        ? new byte[BUFFER_SIZE_8K]\n        : buffersPool.get(BUFFER_SIZE_8K);\n\n    try {\n      //noinspection StatementWithEmptyBody\n      while (input.read(buffer) != EOF);\n    } finally {\n      closeQuietly(input);\n\n      if (buffersPool != null) {\n        buffersPool.release(buffer);\n      }\n    }\n\n  }", "negative": "private <T> Observable.Transformer<T, T> applyInsertRetryPolicy() {\n        return tObservable -> tObservable\n                .retryWhen(errors -> {\n                    Observable<Integer> range = Observable.range(1, 2);\n                    return errors\n                            .zipWith(range, (t, i) -> {\n                                if (t instanceof DriverException) {\n                                    return i;\n                                }\n                                throw Exceptions.propagate(t);\n                            })\n                            .flatMap(retryCount -> {\n                                long delay = (long) Math.min(Math.pow(2, retryCount) * 1000, 3000);\n                                log.debug(\"Retrying batch insert in \" + delay + \" ms\");\n                                return Observable.timer(delay, TimeUnit.MILLISECONDS);\n                            });\n                });\n    }", "type": "random_negative"}
{"anchor": "public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\n\t\tHttpServletRequest request = (HttpServletRequest) req;\n\t\tHttpServletResponse response = (HttpServletResponse) res;\n\n\t\tif (!requiresAuthentication(request, response)) {\n\t\t\tchain.doFilter(request, response);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Request is to process authentication\");\n\t\t}\n\n\t\tAuthentication authResult;\n\n\t\ttry {\n\t\t\tauthResult = attemptAuthentication(request, response);\n\t\t\tif (authResult == null) {\n\t\t\t\t// return immediately as subclass has indicated that it hasn't completed\n\t\t\t\t// authentication\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tsessionStrategy.onAuthentication(authResult, request, response);\n\t\t}\n\t\tcatch (InternalAuthenticationServiceException failed) {\n\t\t\tlogger.error(\n\t\t\t\t\t\"An internal error occurred while trying to authenticate the user.\",\n\t\t\t\t\tfailed);\n\t\t\tunsuccessfulAuthentication(request, response, failed);\n\n\t\t\treturn;\n\t\t}\n\t\tcatch (AuthenticationException failed) {\n\t\t\t// Authentication failed\n\t\t\tunsuccessfulAuthentication(request, response, failed);\n\n\t\t\treturn;\n\t\t}\n\n\t\t// Authentication success\n\t\tif (continueChainBeforeSuccessfulAuthentication) {\n\t\t\tchain.doFilter(request, response);\n\t\t}\n\n\t\tsuccessfulAuthentication(request, response, chain, authResult);\n\t}", "positive": "public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)\n        throws IOException, ServletException {\n\n    HttpServletRequest request = (HttpServletRequest) req;\n    HttpServletResponse response = (HttpServletResponse) res;\n\n    if (!requiresAuthentication(request, response)) {\n        chain.doFilter(request, response);\n        return;\n    }\n\n    if (logger.isDebugEnabled()) {\n        logger.debug(\"Request is to process authentication\");\n    }\n\n    Authentication authResult;\n    try {\n        authResult = attemptAuthentication(request, response);\n        if (authResult == null) {\n            // subclass has indicated that it hasn't completed authentication\n            return;\n        }\n        sessionStrategy.onAuthentication(authResult, request, response);\n    } catch (InternalAuthenticationServiceException failed) {\n        logger.error(\"An internal error occurred while trying to authenticate the user.\", failed);\n        unsuccessfulAuthentication(request, response, failed);\n        return;\n    } catch (AuthenticationException failed) {\n        unsuccessfulAuthentication(request, response, failed);\n        return;\n    }\n\n    if (continueChainBeforeSuccessfulAuthentication) {\n        chain.doFilter(request, response);\n    }\n\n    successfulAuthentication(request, response, chain, authResult);\n}", "type": "llm_rewrite"}
{"anchor": "public String getDump() {\n    pushAutomator2Device();\n    runtest();\n    String path = pullDump2PC();\n    String xml = \"\";\n    try {\n      FileInputStream fileInputStream = new FileInputStream(path);\n      @SuppressWarnings(\"resource\")\n      BufferedReader in = new BufferedReader(\n          new InputStreamReader(fileInputStream));\n      StringBuffer buffer = new StringBuffer();\n      String line = \"\";\n      while ((line = in.readLine()) != null) {\n        buffer.append(line);\n      }\n      xml = buffer.toString();\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n    return xml;\n  }", "negative": "public boolean process(EllipseRotated_F64 ellipseA , EllipseRotated_F64 ellipseB ,\n\t\t\t\t\t\t   Point2D_F64 tangentA0 , Point2D_F64 tangentA1 ,\n\t\t\t\t\t\t   Point2D_F64 tangentA2 , Point2D_F64 tangentA3 ,\n\t\t\t\t\t\t   Point2D_F64 tangentB0 , Point2D_F64 tangentB1 ,\n\t\t\t\t\t\t   Point2D_F64 tangentB2 , Point2D_F64 tangentB3 )\n\t{\n\t\tconverged = false;\n\n\t\t// initialize by picking an arbitrary point on A and then finding the points on B in which\n\t\t// a line is tangent to B and passes through the point on A\n\t\tif (!initialize(ellipseA, ellipseB,\n\t\t\t\ttangentA0, tangentA1, tangentA2, tangentA3,\n\t\t\t\ttangentB0, tangentB1, tangentB2, tangentB3))\n\t\t\treturn false;\n\n\t\t// update the location of each point until it converges or the maximum number of iterations has been exceeded\n\t\tint iteration = 0;\n\t\tfor( ;iteration < maxIterations; iteration++ ) {\n\t\t\tboolean allGood = false;\n\t\t\tsumDifference = 0;\n\n\t\t\tif( !selectTangent(tangentA0,tangentB0,ellipseB,tangentB0, false) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentA1,tangentB1,ellipseB,tangentB1, true) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentA2,tangentB2,ellipseB,tangentB2, true) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentA3,tangentB3,ellipseB,tangentB3, false) )\n\t\t\t\treturn false;\n\n\t\t\tif( Math.sqrt(sumDifference)/4.0 <= convergenceTol ) {\n\t\t\t\tallGood = true;\n\t\t\t}\n\t\t\tsumDifference = 0;\n\n\t\t\tif( !selectTangent(tangentB0,tangentA0,ellipseA,tangentA0, false) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentB1,tangentA1,ellipseA,tangentA1, true) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentB2,tangentA2,ellipseA,tangentA2, true) )\n\t\t\t\treturn false;\n\t\t\tif( !selectTangent(tangentB3,tangentA3,ellipseA,tangentA3, false) )\n\t\t\t\treturn false;\n\n\t\t\tif( allGood && Math.sqrt(sumDifference)/4.0 <= convergenceTol ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tconverged = iteration < maxIterations;\n\n\t\treturn true;\n\t}", "type": "random_negative"}
{"anchor": "public JobView getStandardJobViewBy(\n            String flowNameParam,\n            String flowStepNameParam,\n            String flowViewNameParam)\n    {\n        if(flowNameParam == null ||\n                flowNameParam.trim().isEmpty())\n        {\n            throw new FluidClientException(\n                    \"Flow name not provided.\",\n                    FluidClientException.ErrorCode.FIELD_VALIDATE);\n        }\n\n        if(flowStepNameParam == null ||\n                flowStepNameParam.trim().isEmpty())\n        {\n            throw new FluidClientException(\n                    \"Step name not provided.\",\n                    FluidClientException.ErrorCode.FIELD_VALIDATE);\n        }\n\n        if(flowViewNameParam == null ||\n                flowViewNameParam.trim().isEmpty())\n        {\n            throw new FluidClientException(\n                    \"View name not provided.\",\n                    FluidClientException.ErrorCode.FIELD_VALIDATE);\n        }\n\n        JobViewListing jobViewListing = this.getJobViewsByStepName(\n                flowStepNameParam, new Flow(flowNameParam));\n\n        JobView returnVal = null;\n\n        if(jobViewListing.getListingCount().intValue() > 1)\n        {\n            for(JobView jobView : jobViewListing.getListing())\n            {\n                if(ViewType.STANDARD.equals(jobView.getViewType()) &&\n                        jobView.getViewName().equalsIgnoreCase(flowViewNameParam))\n                {\n                    returnVal = jobView;\n                    break;\n                }\n            }\n        }\n\n        if(returnVal == null)\n        {\n            throw new FluidClientException(\n                    \"No View found for Flow '\"+\n                            flowNameParam +\"', Step '\"+\n                            flowStepNameParam+\"' and View '\"+\n                            flowViewNameParam+\"'.\",\n                    FluidClientException.ErrorCode.NO_RESULT);\n        }\n\n        return returnVal;\n    }", "positive": "package YourNamespace;\n\nimport java.util.*;\n\npublic abstract class FluidClient {\n    public JobView GetStandardJobViewBy(\n            String flowNameParam,\n            String flowStepNameParam,\n            String flowViewNameParam) {\n        if (flowNameParam == null || flowNameParam.trim().isEmpty()) {\n            throw new FluidClientException(\n                    \"Flow name not provided.\",\n                    FluidClientException.ErrorCode.FIELD_VALIDATE);\n        }\n\n        if (flowStepNameParam == null || flowStepNameParam.trim().isEmpty()) {\n            throw new FluidClientException(\n                    \"Step name not provided.\",\n                    FluidClientException.ErrorCode.FIELD_VALIDATE);\n        }\n\n        if (flowViewNameParam == null || flowViewNameParam.trim().isEmpty()) {\n            throw new FluidClientException(\n                    \"View name not provided.\",\n                    FluidClientException.ErrorCode.FIELD_VALIDATE);\n        }\n\n        JobViewListing jobViewListing = this.GetJobViewsByStepName(\n                flowStepNameParam, new Flow(flowNameParam));\n\n        JobView returnVal = null;\n\n        if (jobViewListing.ListingCount > 1) {\n            if (jobViewListing.Listing != null) {\n                for (JobView jobView : jobViewListing.Listing) {\n                    if (ViewType.STANDARD.equals(jobView.ViewType) &&\n                            jobView.ViewName != null &&\n                            jobView.ViewName.equalsIgnoreCase(flowViewNameParam)) {\n                        returnVal = jobView;\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (returnVal == null) {\n            throw new FluidClientException(\n                    \"No View found for Flow '\" +\n                            flowNameParam + \"', Step '\" +\n                            flowStepNameParam + \"' and View '\" +\n                            flowViewNameParam + \"'.\",\n                    FluidClientException.ErrorCode.NO_RESULT);\n        }\n\n        return returnVal;\n    }\n\n    // Placeholder for existing method assumed to be present in the class.\n    public abstract JobViewListing GetJobViewsByStepName(String stepName, Flow flow);\n\n    // Placeholder type definitions to make the code compile in context.\n    public static class JobView {\n        public ViewType ViewType;\n        public String ViewName;\n    }\n\n    public static class JobViewListing {\n        public int ListingCount;\n        public Iterable<JobView> Listing;\n    }\n\n    public static class Flow {\n        public Flow(String name) {\n        }\n    }\n\n    public static class ViewType {\n        public static final ViewType STANDARD = new ViewType();\n\n        @Override\n        public boolean equals(Object obj) {\n            return this == obj;\n        }\n\n        @Override\n        public int hashCode() {\n            return System.identityHashCode(this);\n        }\n    }\n\n    public static class FluidClientException extends RuntimeException {\n        public enum ErrorCode {\n            FIELD_VALIDATE,\n            NO_RESULT\n        }\n\n        private final ErrorCode Code;\n\n        public FluidClientException(String message, ErrorCode code) {\n            super(message);\n            this.Code = code;\n        }\n\n        public ErrorCode getCode() {\n            return Code;\n        }\n    }\n}", "type": "retranslate"}
{"anchor": "private Node createIssueElement(final LintItem error) {\n    final Element issueElement = getDocument().createElement(getIssueElementName());\n\n    final String column = String.valueOf(error.getColumn());\n    if (StringUtils.isNotBlank(column)) {\n      issueElement.setAttribute(getColumnAttributeName(), column);\n    }\n\n    final String evidence = error.getEvidence();\n    if (StringUtils.isNotBlank(evidence)) {\n      issueElement.setAttribute(ATTR_EVIDENCE, evidence);\n    }\n\n    final String line = String.valueOf(error.getLine());\n    if (StringUtils.isNotBlank(line)) {\n      issueElement.setAttribute(ATTR_LINE, line);\n    }\n\n    final String reason = error.getReason();\n    if (StringUtils.isNotBlank(reason)) {\n      issueElement.setAttribute(getReasonAttributeName(), reason);\n    }\n\n    final String severity = error.getSeverity();\n    if (StringUtils.isNotBlank(severity)) {\n      issueElement.setAttribute(ATTR_SEVERITY, severity);\n    }\n    return issueElement;\n  }", "positive": "private Node createIssueElement(final LintItem error) {\n    final Element issueElement = getDocument().createElement(getIssueElementName());\n\n    final String colAttr = getColumnAttributeName();\n    final String reasonAttr = getReasonAttributeName();\n\n    final String[] attrNames = new String[] {\n        colAttr,\n        ATTR_EVIDENCE,\n        ATTR_LINE,\n        reasonAttr,\n        ATTR_SEVERITY\n    };\n\n    final String[] values = new String[] {\n        String.valueOf(error.getColumn()),\n        error.getEvidence(),\n        String.valueOf(error.getLine()),\n        error.getReason(),\n        error.getSeverity()\n    };\n\n    for (int i = 0; i < attrNames.length; i++) {\n      final String val = values[i];\n      if (StringUtils.isNotBlank(val)) {\n        issueElement.setAttribute(attrNames[i], val);\n      }\n    }\n\n    return issueElement;\n  }", "type": "llm_rewrite"}
{"anchor": "public void visit() {\n\t\tString[] properties = resolveProperties(source, declared);\n\n\t\tfor (String name : properties) {\n\t\t\tif (name == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!rules.match(name, blacklist)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tObject value;\n\n\t\t\tString propertyName = name;\n\n\t\t\tif (isSourceMap) {\n\t\t\t\tpropertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET;\n\t\t\t}\n\n\t\t\tif (declared) {\n\t\t\t\tvalue = BeanUtil.declared.getProperty(source, propertyName);\n\t\t\t} else {\n\t\t\t\tvalue = BeanUtil.pojo.getProperty(source, propertyName);\n\t\t\t}\n\n\t\t\tif (value == null && ignoreNullValues) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (value instanceof String && StringUtil.isEmpty((String) value)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvisitProperty(name, value);\n\t\t}\n\t}", "positive": "import java.util.*;\n\npublic class MyClass {\n    public void visit() {\n        String[] properties = resolveProperties(source, declared);\n\n        for (String name : properties) {\n            if (name == null) {\n                continue;\n            }\n\n            if (!rules.match(name, blacklist)) {\n                continue;\n            }\n\n            Object value;\n\n            String propertyName = name;\n\n            if (isSourceMap) {\n                propertyName = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET;\n            }\n\n            if (declared) {\n                value = BeanUtil.declared.getProperty(source, propertyName);\n            } else {\n                value = BeanUtil.pojo.getProperty(source, propertyName);\n            }\n\n            if (value == null && ignoreNullValues) {\n                continue;\n            }\n\n            if (value instanceof String && StringUtil.isEmpty((String) value)) {\n                continue;\n            }\n\n            visitProperty(name, value);\n        }\n    }\n\n    // Placeholder members/methods to match references in visit().\n    // Actual implementations should exist elsewhere in the codebase.\n\n    // Example placeholders (commented out):\n    // private Object source;\n    // private boolean declared;\n    // private Object rules;\n    // private Object blacklist;\n    // private boolean isSourceMap;\n    // private String LEFT_SQ_BRACKET;\n    // private String RIGHT_SQ_BRACKET;\n    // private boolean ignoreNullValues;\n    //\n    // private String[] resolveProperties(Object source, boolean declared) { return new String[0]; }\n    // private void visitProperty(String name, Object value) {}\n}", "type": "retranslate"}
{"anchor": "public static <T extends GeoTuple3D_F64> T mult( DMatrixRMaj M, T pt, T result ) {\n\t\tif( M.numRows != 3 || M.numCols != 3 )\n\t\t\tthrow new IllegalArgumentException( \"Input matrix must be 3 by 3, not \" + M.numRows + \" \" + M.numCols );\n\n\t\tif( result == null ) {\n\t\t\tresult = (T) pt.createNewInstance();\n\t\t}\n\n\t\tdouble x = pt.x;\n\t\tdouble y = pt.y;\n\t\tdouble z = pt.z;\n\n\t\tresult.x = (double) ( M.data[0] * x + M.data[1] * y + M.data[2] * z );\n\t\tresult.y = (double) ( M.data[3] * x + M.data[4] * y + M.data[5] * z );\n\t\tresult.z = (double) ( M.data[6] * x + M.data[7] * y + M.data[8] * z );\n\n\t\treturn (T) result;\n\t}", "positive": "public class MatrixOperations {\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends GeoTuple3D_F64> T Mult(DMatrixRMaj M, T pt, T result) {\n        if (M.numRows != 3 || M.numCols != 3)\n            throw new IllegalArgumentException(\"Input matrix must be 3 by 3, not \" + M.numRows + \" \" + M.numCols);\n\n        if (result == null) {\n            result = (T) pt.createNewInstance();\n        }\n\n        double x = pt.x;\n        double y = pt.y;\n        double z = pt.z;\n\n        result.x = (M.data[0] * x + M.data[1] * y + M.data[2] * z);\n        result.y = (M.data[3] * x + M.data[4] * y + M.data[5] * z);\n        result.z = (M.data[6] * x + M.data[7] * y + M.data[8] * z);\n\n        return result;\n    }\n}\n\n// Placeholder types to match the referenced types in the translated method.\n// In actual usage these would come from the appropriate library.\nclass DMatrixRMaj {\n    public int numRows;\n    public int numCols;\n    public double[] data;\n}\n\nclass GeoTuple3D_F64 {\n    public double x;\n    public double y;\n    public double z;\n\n    public GeoTuple3D_F64 createNewInstance() {\n        return new GeoTuple3D_F64();\n    }\n}", "type": "retranslate"}
{"anchor": "public static MtgSet getSet(String setCode) {\n\t\tString path = String.format(\"%s/%s/\", RESOURCE_PATH, setCode);\n\t\tMtgSet returnSet = get(path, \"set\", MtgSet.class);\n\t\tif(returnSet != null) {\n\t\t\treturnSet.setCards(CardAPI.getAllCards(new LinkedList<>(Collections.singletonList(\"set=\" + setCode))));\n\t\t}\n\t\treturn returnSet;\n\t}", "positive": "public static MtgSet getSet(String setCode) {\n    String path = RESOURCE_PATH + \"/\" + setCode + \"/\";\n    MtgSet returnSet = get(path, \"set\", MtgSet.class);\n    if (returnSet == null) {\n        return null;\n    }\n    List<String> params = new LinkedList<>();\n    params.add(\"set=\" + setCode);\n    returnSet.setCards(CardAPI.getAllCards(params));\n    return returnSet;\n}", "type": "llm_rewrite"}
{"anchor": "public static BufferedImage convertToType(BufferedImage sourceImage, \n    int targetType)\n  {\n    BufferedImage image;\n\n    // if the source image is already the target type, return the source image\n\n    if (sourceImage.getType() == targetType)\n      image = sourceImage;\n\n    // otherwise create a new image of the target type and draw the new\n    // image \n\n    else\n    {\n      image = new BufferedImage(sourceImage.getWidth(), sourceImage.getHeight(),\n        targetType);\n      image.getGraphics().drawImage(sourceImage, 0, 0, null);\n    }\n    \n    return image;\n  }", "negative": "public Map extract(Map target, final String[] profiles, final String[] wildcardPatterns, String prefix) {\n\t\tif (target == null) {\n\t\t\ttarget = new HashMap();\n\t\t}\n\n\t\t// make sure prefix ends with a dot\n\t\tif (prefix != null) {\n\t\t\tif (!StringUtil.endsWithChar(prefix, '.')) {\n\t\t\t\tprefix += StringPool.DOT;\n\t\t\t}\n\t\t}\n\n\t\tif (profiles != null) {\n\t\t\tfor (String profile : profiles) {\n\t\t\t\twhile (true) {\n\t\t\t\t\tfinal Map<String, PropsEntry> map = this.profileProperties.get(profile);\n\t\t\t\t\tif (map != null) {\n\t\t\t\t\t\textractMap(target, map, profiles, wildcardPatterns, prefix);\n\t\t\t\t\t}\n\n\t\t\t\t\tfinal int ndx = profile.lastIndexOf('.');\n\t\t\t\t\tif (ndx == -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tprofile = profile.substring(0, ndx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\textractMap(target, this.baseProperties, profiles, wildcardPatterns, prefix);\n\n\t\treturn target;\n\t}", "type": "random_negative"}
{"anchor": "public static String parseLocalAddress(final Channel channel) {\n        if (null == channel) {\n            return StringUtils.EMPTY;\n        }\n        final SocketAddress local = channel.localAddress();\n        return doParse(local != null ? local.toString().trim() : StringUtils.EMPTY);\n    }", "negative": "public CoverageDataPngImage drawTile(short[][] pixelValues) {\n\n        int tileWidth = pixelValues[0].length;\n        int tileHeight = pixelValues.length;\n\n        CoverageDataPngImage image = createImage(tileWidth, tileHeight);\n        PngWriter writer = image.getWriter();\n        for (int y = 0; y < tileHeight; y++) {\n            ImageLineInt row = new ImageLineInt(writer.imgInfo, new int[tileWidth]);\n            int[] rowLine = row.getScanline();\n            for (int x = 0; x < tileWidth; x++) {\n                short pixelValue = pixelValues[y][x];\n                setPixelValue(rowLine, x, pixelValue);\n            }\n            writer.writeRow(row);\n        }\n        writer.end();\n        image.flushStream();\n\n        return image;\n    }", "type": "random_negative"}
{"anchor": "private String createFxmlPath(Class<?> viewType) {\n        final StringBuilder pathBuilder = new StringBuilder();\n\n        final FxmlPath pathAnnotation = viewType.getDeclaredAnnotation(FxmlPath.class); //Get annotation from view\n        final String fxmlPath = Optional.ofNullable(pathAnnotation)\n                .map(FxmlPath::value)\n                .map(String::trim)\n                .orElse(\"\");\n\n        if (fxmlPath.isEmpty()) {\n            pathBuilder.append(\"/\");\n\n            if (viewType.getPackage() != null) {\n                pathBuilder.append(viewType.getPackage().getName().replaceAll(\"\\\\.\", \"/\"));\n                pathBuilder.append(\"/\");\n            }\n\n            pathBuilder.append(viewType.getSimpleName());\n            pathBuilder.append(\".fxml\");\n        } else {\n            pathBuilder.append(fxmlPath);\n        }\n\n        return pathBuilder.toString();\n    }", "positive": "private String createFxmlPath(Class<?> viewType) {\n    FxmlPath pathAnnotation = viewType.getDeclaredAnnotation(FxmlPath.class);\n    String fxmlPath = \"\";\n    if (pathAnnotation != null) {\n        String val = pathAnnotation.value();\n        if (val != null) {\n            val = val.trim();\n            if (!val.isEmpty()) {\n                fxmlPath = val;\n            }\n        }\n    }\n\n    if (!fxmlPath.isEmpty()) {\n        return fxmlPath;\n    }\n\n    StringBuilder sb = new StringBuilder();\n    sb.append('/');\n\n    Package pkg = viewType.getPackage();\n    if (pkg != null) {\n        String pkgPath = pkg.getName().replace('.', '/');\n        sb.append(pkgPath).append('/');\n    }\n\n    sb.append(viewType.getSimpleName()).append(\".fxml\");\n    return sb.toString();\n}", "type": "llm_rewrite"}
{"anchor": "protected void\n    printCompoundInstance(DataCursor datav)\n            throws DapException\n    {\n        //Index index = datav.getIndex();\n        DapStructure dstruct = (DapStructure) ((DapVariable) datav.getTemplate()).getBaseType();\n        switch (datav.getScheme()) {\n        case STRUCTURE:\n        case RECORD:\n            List<DapVariable> dfields = dstruct.getFields();\n            for(int f = 0; f < dfields.size(); f++) {\n                DapVariable field = dfields.get(f);\n                List<Slice> fieldslices = this.ce.getConstrainedSlices(field);\n                DataCursor fdata = datav.readField(f);\n                printVariable(fdata,fieldslices);\n            }\n            break;\n\n        case SEQUENCE:\n            DapSequence dseq = (DapSequence)dstruct;\n            long count = datav.getRecordCount();\n            for(long r = 0; r < count; r++) {\n                DataCursor dr = datav.readRecord(r);\n                printer.marginPrint(\"[\");\n                printer.eol();\n                printer.indent();\n                printCompoundInstance(dr);\n                printer.outdent();\n                printer.marginPrint(\"]\");\n            }\n            break;\n        default:\n            throw new DapException(\"Unexpected data cursor scheme:\" + datav.getScheme());\n        }\n    }", "negative": "public void setAsText(final String text)\n   {\n      if (PropertyEditors.isNull(text))\n      {\n         setValue(null);\n         return;\n      }\n      Object newValue = Byte.decode(text);\n      setValue(newValue);\n   }", "type": "random_negative"}
{"anchor": "@Override\r\n\tpublic void contextInitialized(ServletContextEvent contextEvent) {\r\n\t\tfinal ServletContext servletContext = contextEvent.getServletContext();\r\n\r\n\t\t/** Logger diagnostic context stores contextual information regarding current request. */\r\n\t\tLogContext logContext = LogFactory.getLogContext();\r\n\t\tlogContext.put(LOG_CONTEXT_APP, servletContext.getContextPath().isEmpty() ? TinyContainer.ROOT_CONTEXT : servletContext.getContextPath().substring(1));\r\n\r\n\t\tfinal long start = System.currentTimeMillis();\r\n\t\tlog.debug(\"Starting application |%s| container...\", servletContext.getContextPath());\r\n\r\n\t\tEnumeration<String> parameterNames = servletContext.getInitParameterNames();\r\n\t\twhile (parameterNames.hasMoreElements()) {\r\n\t\t\tfinal String name = parameterNames.nextElement();\r\n\t\t\tfinal String value = servletContext.getInitParameter(name);\r\n\t\t\tcontextParameters.setProperty(name, value);\r\n\t\t\tlog.debug(\"Load context parameter |%s| value |%s|.\", name, value);\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tConfigBuilder builder = new TinyConfigBuilder(servletContext, contextParameters);\r\n\t\t\tconfig(builder.build());\r\n\r\n\t\t\tFactory.bind(this);\r\n\t\t\tstart();\r\n\r\n\t\t\t// set tiny container reference on servlet context attribute ONLY if no exception\r\n\t\t\tservletContext.setAttribute(TinyContainer.ATTR_INSTANCE, this);\r\n\t\t\tlog.info(\"Application |%s| container started in %d msec.\", appName, System.currentTimeMillis() - start);\r\n\t\t} catch (ConfigException e) {\r\n\t\t\tlog.error(e);\r\n\t\t\tlog.fatal(\"Bad container |%s| configuration.\", appName);\r\n\t\t} catch (Throwable t) {\r\n\t\t\tlog.dump(String.format(\"Fatal error on container |%s| start:\", appName), t);\r\n\t\t}\r\n\t}", "positive": "@Override\npublic void contextInitialized(ServletContextEvent contextEvent) {\n    final ServletContext servletContext = contextEvent.getServletContext();\n\n    // Logger diagnostic context stores contextual information regarding current request.\n    LogContext logContext = LogFactory.getLogContext();\n    String contextPath = servletContext.getContextPath();\n    String appContext = contextPath.isEmpty() ? TinyContainer.ROOT_CONTEXT : contextPath.substring(1);\n    logContext.put(LOG_CONTEXT_APP, appContext);\n\n    final long start = System.currentTimeMillis();\n    log.debug(\"Starting application |%s| container...\", servletContext.getContextPath());\n\n    Enumeration<String> parameterNames = servletContext.getInitParameterNames();\n    for (String name : java.util.Collections.list(parameterNames)) {\n        final String value = servletContext.getInitParameter(name);\n        contextParameters.setProperty(name, value);\n        log.debug(\"Load context parameter |%s| value |%s|.\", name, value);\n    }\n\n    try {\n        ConfigBuilder builder = new TinyConfigBuilder(servletContext, contextParameters);\n        config(builder.build());\n\n        Factory.bind(this);\n        start();\n\n        // set tiny container reference on servlet context attribute ONLY if no exception\n        servletContext.setAttribute(TinyContainer.ATTR_INSTANCE, this);\n        log.info(\"Application |%s| container started in %d msec.\", appName, System.currentTimeMillis() - start);\n    } catch (ConfigException e) {\n        log.error(e);\n        log.fatal(\"Bad container |%s| configuration.\", appName);\n    } catch (Throwable t) {\n        log.dump(String.format(\"Fatal error on container |%s| start:\", appName), t);\n    }\n}", "type": "llm_rewrite"}
{"anchor": "public void doGetDIR(ReqState rs)\n            throws Exception\n    {\n        rs.getResponse().setHeader(\"XDODS-Server\", getServerVersion());\n        rs.getResponse().setContentType(\"text/html\");\n        rs.getResponse().setHeader(\"Content-Description\", \"dods-directory\");\n\n        try {\n            GetDirHandler di = new GetDirHandler();\n            di.sendDIR(rs);\n            rs.getResponse().setStatus(HttpServletResponse.SC_OK);\n        } catch (ParseException pe) {\n            parseExceptionHandler(pe, rs.getResponse());\n        } catch (DAP2Exception de) {\n            dap2ExceptionHandler(de, rs.getResponse());\n        } catch (Throwable t) {\n            anyExceptionHandler(t, rs);\n        }\n\n    }", "positive": "public void doGetDIR(ReqState rs)\n            throws Exception\n    {\n rs.getResponse().setHeader(\"XDODS-Server\", getServerVersion());\n        rs.getResponse().setContentType(\"text/ html\"); \n rs.getResponse().setHeader(\"Content-Description\", \"dods-directory\");\n\n try {\n            GetDirHandler di =  new GetDirHandler(); \n            di.sendDIR(rs);\n              rs.getResponse().setStatus(HttpServletResponse.SC_OK);\n        } catch (ParseException pe) {\n            parseExceptionHandler(pe,  rs.getResponse()); \n } catch (DAP2Exception de) { // Check boundary conditions\n            dap2ExceptionHandler(de,  rs.getResponse()); \n          } catch (Throwable t) {\n            anyExceptionHandler(t,  rs); \n        }\n\n    }", "type": "augment"}
{"anchor": "public static Optional<Field> getViewModelField(Class<? extends View> viewType, Class<?> viewModelType) {\n        List<Field> allViewModelFields = getViewModelFields(viewType);\n\n        if (allViewModelFields.isEmpty()) {\n            return Optional.empty();\n        }\n\n        if (allViewModelFields.size() > 1) {\n            throw new RuntimeException(\"The View <\" + viewType + \"> may only define one viewModel but there were <\"\n                    + allViewModelFields.size() + \"> viewModel fields with the @InjectViewModel annotation!\");\n        }\n\n        Field field = allViewModelFields.get(0);\n\n        if (!ViewModel.class.isAssignableFrom(field.getType())) {\n            throw new RuntimeException(\"The View <\" + viewType\n                    + \"> has a field annotated with @InjectViewModel but the type of the field doesn't implement the 'ViewModel' interface!\");\n        }\n\n        if (!field.getType().isAssignableFrom(viewModelType)) {\n            throw new RuntimeException(\"The View <\" + viewType\n                    + \"> has a field annotated with @InjectViewModel but the type of the field doesn't match the generic ViewModel type of the View class. \"\n                    + \"The declared generic type is <\" + viewModelType + \"> but the actual type of the field is <\"\n                    + field.getType() + \">.\");\n        }\n\n        return Optional.of(field);\n    }", "positive": "import java.lang.reflect.Field;\nimport java.util.List;\n\npublic class Optional<T> {\n    private final T _value;\n    private final boolean _hasValue;\n\n    private Optional() {\n        this._hasValue = false;\n        this._value = null;\n    }\n\n    private Optional(T value) {\n        if (value == null) throw new NullPointerException(\"value\");\n        this._value = value;\n        this._hasValue = true;\n    }\n\n    public static <T> Optional<T> Empty() {\n        return new Optional<>();\n    }\n\n    public static <T> Optional<T> Of(T value) {\n        return new Optional<>(value);\n    }\n\n    public boolean IsPresent() {\n        return _hasValue;\n    }\n\n    public T Get() {\n        if (!_hasValue) throw new IllegalStateException(\"No value present\");\n        return _value;\n    }\n}\n\npublic final class ViewModelReflectionUtils {\n    // Assumes a method with this signature exists elsewhere in the codebase:\n    // public static List<Field> getViewModelFields(Class<?> viewType)\n    // This method is expected to return the list of Field objects annotated as view-model fields.\n    public static Optional<Field> GetViewModelField(Class<?> viewType, Class<?> viewModelType) {\n        List<Field> allViewModelFields = getViewModelFields(viewType);\n\n        if (allViewModelFields == null || allViewModelFields.size() == 0) {\n            return Optional.<Field>Empty();\n        }\n\n        if (allViewModelFields.size() > 1) {\n            throw new RuntimeException(\"The View <\" + viewType + \"> may only define one viewModel but there were <\"\n                    + allViewModelFields.size() + \"> viewModel fields with the @InjectViewModel annotation!\");\n        }\n\n        Field field = allViewModelFields.get(0);\n\n        if (!ViewModel.class.isAssignableFrom(field.getType())) {\n            throw new RuntimeException(\"The View <\" + viewType\n                    + \"> has a field annotated with @InjectViewModel but the type of the field doesn't implement the 'ViewModel' interface!\");\n        }\n\n        if (!field.getType().isAssignableFrom(viewModelType)) {\n            throw new RuntimeException(\"The View <\" + viewType\n                    + \"> has a field annotated with @InjectViewModel but the type of the field doesn't match the generic ViewModel type of the View class. \"\n                    + \"The declared generic type is <\" + viewModelType + \"> but the actual type of the field is <\"\n                    + field.getType() + \">.\");\n        }\n\n        return Optional.<Field>Of(field);\n    }\n\n    // Placeholder to avoid compile errors if this file is compiled standalone.\n    // In the real codebase, the actual implementation should be provided elsewhere.\n    private static List<Field> getViewModelFields(Class<?> viewType) {\n        throw new UnsupportedOperationException(\"getViewModelFields must be implemented elsewhere in the codebase.\");\n    }\n}\n\n// Placeholder types to match references in the translated code. In your real project,\n// these should be the actual View and ViewModel types.\ninterface View { }\ninterface ViewModel { }", "type": "retranslate"}
{"anchor": "public static boolean fitMM(double[] data, int offset , int length , PolynomialCubic1D_F64 output , @Nullable DMatrix4x4 A ) {\n\t\tif( A == null )\n\t\t\tA = new DMatrix4x4();\n\n\t\tfinal int N = length/2;\n\t\tif( N < 4 )\n\t\t\tthrow new IllegalArgumentException(\"Need at least 4 points and not \"+N);\n\n\t\t// Unrolled pseudo inverse\n\t\t// coef = inv(A^T*A)*A^T*y\n\t\tdouble sx1 = 0, sx2 = 0, sx3 = 0, sx4 = 0, sx5 = 0, sx6 = 0;\n\n\t\tdouble b0=0,b1=0,b2=0,b3=0;\n\n\t\tint end = offset+length;\n\t\tfor (int i = offset; i < end; i += 2 ) {\n\t\t\tdouble x = data[i];\n\t\t\tdouble y = data[i+1];\n\n\t\t\tdouble x2 = x*x;\n\t\t\tdouble x3 = x2*x;\n\t\t\tdouble x4 = x2*x2;\n\n\t\t\tsx1 += x; sx2 += x2; sx3 += x3;\n\t\t\tsx4 += x4; sx5 += x4*x;\n\t\t\tsx6 += x4*x2;\n\n\t\t\tb0 += y;\n\t\t\tb1 += x*y;\n\t\t\tb2 += x2*y;\n\t\t\tb3 += x3*y;\n\t\t}\n\n\t\tA.set(  N,  sx1,sx2,sx3,\n\t\t\t\tsx1,sx2,sx3,sx4,\n\t\t\t\tsx2,sx3,sx4,sx5,\n\t\t\t\tsx3,sx4,sx5,sx6);\n\n\t\tif( !CommonOps_DDF4.invert(A,A) )// TODO use a symmetric inverse. Should be slightly faster\n\t\t\treturn false;\n\n\t\t// output = inv(A)*B      Unrolled here for speed\n\t\toutput.a = A.a11*b0 + A.a12*b1 + A.a13*b2 + A.a14*b3;\n\t\toutput.b = A.a21*b0 + A.a22*b1 + A.a23*b2 + A.a24*b3;\n\t\toutput.c = A.a31*b0 + A.a32*b1 + A.a33*b2 + A.a34*b3;\n\t\toutput.d = A.a41*b0 + A.a42*b1 + A.a43*b2 + A.a44*b3;\n\n\t\treturn true;\n\t}", "positive": "public final class FitMMUtil {\n    public static boolean fitMM(double[] data, int offset, int length, PolynomialCubic1D_F64 output, DMatrix4x4 A) {\n        if (A == null)\n            A = new DMatrix4x4();\n\n        int N = length / 2;\n        if (N < 4)\n            throw new IllegalArgumentException(\"Need at least 4 points and not \" + N);\n\n        // Unrolled pseudo inverse\n        // coef = inv(A^T*A)*A^T*y\n        double sx1 = 0, sx2 = 0, sx3 = 0, sx4 = 0, sx5 = 0, sx6 = 0;\n\n        double b0 = 0, b1 = 0, b2 = 0, b3 = 0;\n\n        int end = offset + length;\n        for (int i = offset; i < end; i += 2) {\n            double x = data[i];\n            double y = data[i + 1];\n\n            double x2 = x * x;\n            double x3 = x2 * x;\n            double x4 = x2 * x2;\n\n            sx1 += x; sx2 += x2; sx3 += x3;\n            sx4 += x4; sx5 += x4 * x;\n            sx6 += x4 * x2;\n\n            b0 += y;\n            b1 += x * y;\n            b2 += x2 * y;\n            b3 += x3 * y;\n        }\n\n        A.set(N, sx1, sx2, sx3,\n              sx1, sx2, sx3, sx4,\n              sx2, sx3, sx4, sx5,\n              sx3, sx4, sx5, sx6);\n\n        if (!CommonOps_DDF4.invert(A, A)) // TODO use a symmetric inverse. Should be slightly faster\n            return false;\n\n        // output = inv(A)*B      Unrolled here for speed\n        output.a = A.a11 * b0 + A.a12 * b1 + A.a13 * b2 + A.a14 * b3;\n        output.b = A.a21 * b0 + A.a22 * b1 + A.a23 * b2 + A.a24 * b3;\n        output.c = A.a31 * b0 + A.a32 * b1 + A.a33 * b2 + A.a34 * b3;\n        output.d = A.a41 * b0 + A.a42 * b1 + A.a43 * b2 + A.a44 * b3;\n\n        return true;\n    }\n}", "type": "retranslate"}
{"anchor": "public static byte[] readInputStreamToBytes(InputStream inputStream) throws Exception {\n        byte[] data = null;\n        try {\n            int bufferSize = 128;\n            byte[] buffer = new byte[bufferSize];\n            int offset = 0;\n            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n            int length = -1;\n            while ((length = inputStream.read(buffer)) != -1) {\n                // if(length != bufferSize){\n                // System.arraycopy(buffer, 0, data, offset, length);\n                // }\n//                    System.arraycopy(buffer, 0, data, offset, length);// \u4ece\u7f13\u51b2\u533a\u62f7\u8d1d\u6570\u7ec4\n                if (offset + length > byteBuffer.limit()) {\n                    byteBuffer = growByteBuffer(byteBuffer, (int) (byteBuffer.limit() * 1.5));\n                }\n                byteBuffer.put(buffer, 0, length);\n                offset += length;\n            }\n            byteBuffer.flip();\n//            byteBuffer.limit(offset);\n            data = new byte[offset];\n            byteBuffer.get(data, 0, offset);\n//            data = byteBuffer.array();\n        } catch (IOException e) {\n            LOGGER.error(e);\n        } finally {\n            try {\n                inputStream.close();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n            }\n        }\n        return data;\n    }", "positive": "package Utils;\n\nimport java.io.InputStream;\nimport java.io.IOException;\n\npublic final class StreamUtil {\n    private StreamUtil() {\n    }\n\n    public static byte[] ReadInputStreamToBytes(InputStream inputStream) {\n        byte[] data = null;\n        try {\n            int bufferSize = 128;\n            byte[] buffer = new byte[bufferSize];\n            int offset = 0;\n            byte[] byteBuffer = new byte[1024];\n            int length;\n            while ((length = inputStream.read(buffer, 0, buffer.length)) > 0) {\n                if (offset + length > byteBuffer.length) {\n                    byteBuffer = GrowByteBuffer(byteBuffer, (int) (byteBuffer.length * 1.5));\n                }\n                System.arraycopy(buffer, 0, byteBuffer, offset, length);\n                offset += length;\n            }\n            data = new byte[offset];\n            System.arraycopy(byteBuffer, 0, data, 0, offset);\n        } catch (IOException e) {\n            System.err.println(e);\n        } finally {\n            try {\n                inputStream.close();\n            } catch (Exception e1) {\n                System.err.println(e1);\n            }\n        }\n        return data;\n    }\n\n    private static byte[] GrowByteBuffer(byte[] buffer, int newSize) {\n        if (newSize <= buffer.length) {\n            return buffer;\n        }\n        byte[] newBuffer = new byte[newSize];\n        System.arraycopy(buffer, 0, newBuffer, 0, buffer.length);\n        return newBuffer;\n    }\n}", "type": "retranslate"}
{"anchor": "public int read(byte[] buf, int off, int len) throws IOException {\n        if (off < 0 || len < 0 || off + len < 0 || off + len > buf.length)\n            throw new IndexOutOfBoundsException();\n\n        if (len == 0)\n            return 0;\n\n        if (in == null)\n            throw new XZIOException(\"Stream closed\");\n\n        if (exception != null)\n            throw exception;\n\n        if (endReached)\n            return -1;\n\n        try {\n            int size = 0;\n\n            while (len > 0) {\n                if (uncompressedSize == 0) {\n                    decodeChunkHeader();\n                    if (endReached)\n                        return size == 0 ? -1 : size;\n                }\n\n                int copySizeMax = Math.min(uncompressedSize, len);\n\n                if (!isLZMAChunk) {\n                    lz.copyUncompressed(in, copySizeMax);\n                } else {\n                    lz.setLimit(copySizeMax);\n                    lzma.decode();\n                }\n\n                int copiedSize = lz.flush(buf, off);\n                off += copiedSize;\n                len -= copiedSize;\n                size += copiedSize;\n                uncompressedSize -= copiedSize;\n\n                if (uncompressedSize == 0)\n                    if (!rc.isFinished() || lz.hasPending())\n                        throw new CorruptedInputException();\n            }\n\n            return size;\n\n        } catch (IOException e) {\n            exception = e;\n            throw e;\n        }\n    }", "negative": "public Boolean isReadYourWrites(final String iClusterName) {\n    Object value = getClusterConfiguration(iClusterName).field(READ_YOUR_WRITES);\n    if (value == null) {\n      value = configuration.field(READ_YOUR_WRITES);\n      if (value == null) {\n        OLogManager.instance()\n            .warn(this, \"%s setting not found for cluster=%s in distributed-config.json\", READ_YOUR_WRITES, iClusterName);\n        return true;\n      }\n    }\n    return (Boolean) value;\n  }", "type": "random_negative"}
{"anchor": "protected void\n    dumpvar(Segment seg, StringBuilder buf, boolean forconstraint)\n    {\n        if(seg.var.isTopLevel())\n            buf.append(seg.var.getFQN());\n        else\n            buf.append(seg.var.getShortName());\n        List<DapDimension> dimset = seg.var.getDimensions();\n        // Add any slices\n        List<Slice> slices = seg.slices;\n        if(slices == null)\n            dimset = new ArrayList<DapDimension>();\n        else\n            assert (dimset.size() == 0 && DapUtil.isScalarSlices(slices))\n                    || (dimset.size() == slices.size());\n        for(int i = 0; i < dimset.size(); i++) {\n            Slice slice = slices.get(i);\n            DapDimension dim = dimset.get(i);\n            try {\n                buf.append(forconstraint ? slice.toConstraintString() : slice.toString());\n            } catch (DapException de) {\n            }\n        }\n        DapType basetype = seg.var.getBaseType();\n\n        // if the var is atomic, then we are done\n        if(basetype.isAtomic())\n            return;\n        // If structure and all fields are in the view, then done\n        if(basetype.getTypeSort().isCompound()) {\n            DapStructure struct = (DapStructure)basetype;\n            if(!isWholeCompound(struct)) {\n                // Need to insert {...} and recurse\n                buf.append(LBRACE);\n                boolean first = true;\n                for(DapVariable field : struct.getFields()) {\n                    if(!first) buf.append(\";\");\n                    first = false;\n                    Segment fseg = findSegment(field);\n                    dumpvar(fseg, buf, forconstraint);\n                }\n                buf.append(RBRACE);\n            }\n            if(basetype.getTypeSort().isSeqType() && seg.filter != null) {\n                buf.append(\"|\");\n                buf.append(seg.filter.toString());\n            }\n        }\n\n    }", "positive": "protected void\n    dumpvar(Segment seg, StringBuilder buf, boolean forconstraint)\n    {\n        // Append variable name\n        if (seg.var.isTopLevel()) {\n            buf.append(seg.var.getFQN());\n        } else {\n            buf.append(seg.var.getShortName());\n        }\n\n        List<DapDimension> dimset = seg.var.getDimensions();\n        List<Slice> slices = seg.slices;\n        if (slices == null) {\n            dimset = new ArrayList<DapDimension>();\n        } else {\n            assert (dimset.size() == 0 && DapUtil.isScalarSlices(slices))\n                    || (dimset.size() == slices.size());\n        }\n\n        // Add any slices corresponding to dimensions\n        for (int i = 0; i < dimset.size(); i++) {\n            Slice slice = slices.get(i);\n            try {\n                buf.append(forconstraint ? slice.toConstraintString() : slice.toString());\n            } catch (DapException de) {\n                // Intentionally ignore slice exceptions as in original\n            }\n        }\n\n        DapType basetype = seg.var.getBaseType();\n\n        // atomic types have no further structure to dump\n        if (basetype.isAtomic())\n            return;\n\n        // For compound types, possibly expand fields\n        if (basetype.getTypeSort().isCompound()) {\n            DapStructure struct = (DapStructure) basetype;\n            if (!isWholeCompound(struct)) {\n                buf.append(LBRACE);\n                boolean first = true;\n                for (DapVariable field : struct.getFields()) {\n                    if (!first) {\n                        buf.append(\";\");\n                    }\n                    first = false;\n                    Segment fseg = findSegment(field);\n                    dumpvar(fseg, buf, forconstraint);\n                }\n                buf.append(RBRACE);\n            }\n            if (basetype.getTypeSort().isSeqType() && seg.filter != null) {\n                buf.append(\"|\");\n                buf.append(seg.filter.toString());\n            }\n        }\n    }", "type": "llm_rewrite"}
{"anchor": "public static String padRight(String s, int desiredLength,\r\n                                String padString) {\r\n    StringBuilder ret = new StringBuilder(s);\r\n    while (ret.length() < desiredLength) {\r\n      ret.append(padString);\r\n    }\r\n    return ret.toString();\r\n  }", "negative": "public float nextRatio ()\n  {\n    float u, v, x, xx;\n\n    do\n    {\n      // u and v are two uniformly-distributed random values\n      // in [0, 1), and u != 0.\n      while ((u = GENERATOR.nextFloat ()) == 0)\n      {\n        // try again if 0\n      }\n      v = GENERATOR.nextFloat ();\n\n      // y coord of point (u, y)\n      final float y = C1 * (v - 0.5f);\n\n      // ratio of point's coords\n      x = y / u;\n\n      xx = x * x;\n    } while ((xx > 5f - C2 * u) && // quick acceptance\n             ((xx >= C3 / u + 1.4f) || // quick rejection\n              (xx > (float) (-4 * Math.log (u)))) // final test\n    );\n\n    return m_fStddev * x + m_fMean;\n  }", "type": "random_negative"}
{"anchor": "static public boolean canOpen(String location) throws IOException {\n    ucar.unidata.io.RandomAccessFile raf = null;\n    try {\n      raf = getRaf(location, -1);\n      return (raf != null) && canOpen(raf);\n    } finally {\n      if (raf != null) raf.close();\n    }\n  }", "positive": "package TranslatedCode;\n\nimport java.io.IOException;\nimport ucar.unidata.io.RandomAccessFile;\n\npublic final class FileUtilities {\n    public static boolean canOpen(String location) {\n        RandomAccessFile raf = null;\n        try {\n            raf = getRaf(location, -1);\n            return (raf != null) && canOpen(raf);\n        } finally {\n            if (raf != null) {\n                try {\n                    raf.close();\n                } catch (IOException e) {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    // Placeholder declarations for methods referenced in the original code.\n    // Actual implementations are expected to exist elsewhere.\n    private static RandomAccessFile getRaf(String location, int arg) {\n        throw new UnsupportedOperationException(\"getRaf must be implemented\");\n    }\n\n    private static boolean canOpen(RandomAccessFile raf) {\n        throw new UnsupportedOperationException(\"canOpen(RandomAccessFile) must be implemented\");\n    }\n}", "type": "retranslate"}
{"anchor": "public Variable addVariable(Group g, Structure parent, String shortName, DataType dataType, List<Dimension> dims) {\r\n    if (!defineMode)\r\n      throw new UnsupportedOperationException(\"not in define mode\");\r\n\r\n    DataType writeType =  version.isExtendedModel() ?\r\n            dataType : dataType.withSignedness(DataType.Signedness.SIGNED); // use signed type for netcdf3\r\n    boolean usingSignForUnsign = writeType != dataType;\r\n    if (!isValidDataType(writeType))\r\n      throw new IllegalArgumentException(\"illegal dataType: \" + dataType + \" not supported in netcdf-3\");\r\n\r\n    // check unlimited if classic model\r\n    if (!version.isExtendedModel()) {\r\n      for (int i = 0; i < dims.size(); i++) {\r\n        Dimension d = dims.get(i);\r\n        if (d.isUnlimited() && (i != 0))\r\n          throw new IllegalArgumentException(\"Unlimited dimension \" + d.getShortName() + \" must be first (outermost) in netcdf-3 \");\r\n      }\r\n    }\r\n\r\n    shortName = makeValidObjectName(shortName);\r\n    Variable v;\r\n    if (dataType == DataType.STRUCTURE) {\r\n      v = new Structure(ncfile, g, parent, shortName);\r\n    } else {\r\n      v = new Variable(ncfile, g, parent, shortName);\r\n    }\r\n    v.setDataType(writeType);\r\n    v.setDimensions(dims);\r\n    if (usingSignForUnsign)\r\n      v.addAttribute(new Attribute(CDM.UNSIGNED, \"true\"));\r\n\r\n    long size = v.getSize() * v.getElementSize();\r\n    if (version == Version.netcdf3 && size > N3iosp.MAX_VARSIZE)\r\n      throw new IllegalArgumentException(\"Variable size in bytes \" + size + \" may not exceed \" + N3iosp.MAX_VARSIZE);\r\n      //System.out.printf(\"Variable size in bytes \" + size + \" may not exceed \" + N3iosp.MAX_VARSIZE);\r\n\r\n    ncfile.addVariable(g, v);\r\n    return v;\r\n  }", "positive": "public Variable addVariable(Group g, Structure parent, String shortName, DataType dataType, List<Dimension> dims) {\n    if (!defineMode) {\n      throw new UnsupportedOperationException(\"not in define mode\");\n    }\n\n    // Determine the actual type to write (netcdf-3 uses signed types unless extended model)\n    DataType writeType = version.isExtendedModel()\n        ? dataType\n        : dataType.withSignedness(DataType.Signedness.SIGNED);\n    boolean usingSignForUnsign = writeType != dataType;\n\n    if (!isValidDataType(writeType)) {\n      throw new IllegalArgumentException(\"illegal dataType: \" + dataType + \" not supported in netcdf-3\");\n    }\n\n    // In the classic model, any unlimited dimension must be the first (outermost)\n    if (!version.isExtendedModel()) {\n      for (int i = 0; i < dims.size(); i++) {\n        Dimension d = dims.get(i);\n        if (d.isUnlimited() && i != 0) {\n          throw new IllegalArgumentException(\"Unlimited dimension \" + d.getShortName() + \" must be first (outermost) in netcdf-3 \");\n        }\n      }\n    }\n\n    shortName = makeValidObjectName(shortName);\n\n    Variable v = (dataType == DataType.STRUCTURE)\n        ? new Structure(ncfile, g, parent, shortName)\n        : new Variable(ncfile, g, parent, shortName);\n\n    v.setDataType(writeType);\n    v.setDimensions(dims);\n\n    if (usingSignForUnsign) {\n      v.addAttribute(new Attribute(CDM.UNSIGNED, \"true\"));\n    }\n\n    long size = v.getSize() * v.getElementSize();\n    if (version == Version.netcdf3 && size > N3iosp.MAX_VARSIZE) {\n      throw new IllegalArgumentException(\"Variable size in bytes \" + size + \" may not exceed \" + N3iosp.MAX_VARSIZE);\n    }\n\n    ncfile.addVariable(g, v);\n    return v;\n  }", "type": "llm_rewrite"}
{"anchor": "public <T> QueryBuilder add(final String lhsStatement,\n\t\t\tfinal Class<T> constructorClass, final String expression) {\n\n\t\tStringBuilder itemBuilder = new StringBuilder();\n\t\tif (lhsStatement != null) {\n\t\t\titemBuilder.append(lhsStatement);\n\t\t\titemBuilder.append(\" \");\n\t\t}\n\t\titemBuilder.append(\"NEW \");\n\t\titemBuilder.append(constructorClass.getName());\n\t\titemBuilder.append(\"(\");\n\t\titemBuilder.append(expression);\n\t\titemBuilder.append(\")\");\n\n\t\titems.add(itemBuilder.toString());\n\n\t\treturn builder;\n\n\t}", "negative": "@SuppressWarnings(\"unchecked\")\n\tprivate <C extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity>> C getOrApply(\n\t\t\tC configurer) throws Exception {\n\t\tC existingConfig = (C) getConfigurer(configurer.getClass());\n\t\tif (existingConfig != null) {\n\t\t\treturn existingConfig;\n\t\t}\n\t\treturn apply(configurer);\n\t}", "type": "random_negative"}
{"anchor": "private RedisSession getSession(String id, boolean allowExpired) {\n\t\tMap<Object, Object> entries = getSessionBoundHashOperations(id).entries();\n\t\tif (entries.isEmpty()) {\n\t\t\treturn null;\n\t\t}\n\t\tMapSession loaded = loadSession(id, entries);\n\t\tif (!allowExpired && loaded.isExpired()) {\n\t\t\treturn null;\n\t\t}\n\t\tRedisSession result = new RedisSession(loaded);\n\t\tresult.originalLastAccessTime = loaded.getLastAccessedTime();\n\t\treturn result;\n\t}", "positive": "private RedisSession getSession(String id, boolean allowExpired) {\n    Map<Object, Object> entries = getSessionBoundHashOperations(id).entries();\n    if (entries.isEmpty()) {\n        return null;\n    }\n\n    MapSession loaded = loadSession(id, entries);\n    if (!allowExpired && loaded.isExpired()) {\n        return null;\n    }\n\n    RedisSession session = new RedisSession(loaded);\n    session.originalLastAccessTime = loaded.getLastAccessedTime();\n    return session;\n}", "type": "llm_rewrite"}
{"anchor": "public Object get(int idx) {\n    int index = idx & 0xff;\n    if (isEmpty()) {\n      // System.err.println(\"index \"+index+\" is invalid as stack is empty\");\n      return null;\n    } else if (index < 0 || index >= size) {\n      // System.err.println(\"index \"+index+\" is outside of range [0,\"+(size-1)+\"]\");\n      return null;\n    }\n    return objects[index];\n  }", "negative": "public <RET extends Object> RET newInstance(final String iClassName, final Object iEnclosingClass, Object... iArgs) {\r\n    underlying.checkIfActive();\r\n\r\n    checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_CREATE, iClassName);\r\n\r\n    try {\r\n      Class<?> entityClass = entityManager.getEntityClass(iClassName);\r\n      if (entityClass != null) {\r\n        RET enhanced = (RET) OObjectEntityEnhancer.getInstance()\r\n            .getProxiedInstance(entityManager.getEntityClass(iClassName), iEnclosingClass, underlying.newInstance(iClassName), null,\r\n                iArgs);\r\n        return (RET) enhanced;\r\n      } else {\r\n        throw new OSerializationException(\"Type \" + iClassName\r\n            + \" cannot be serialized because is not part of registered entities. To fix this error register this class\");\r\n      }\r\n    } catch (Exception e) {\r\n      final String message = \"Error on creating object of class \" + iClassName;\r\n      OLogManager.instance().error(this, message, e);\r\n\r\n      throw OException.wrapException(new ODatabaseException(message), e);\r\n    }\r\n  }", "type": "random_negative"}
{"anchor": "@CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.CUSTOM)\n    public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n\n        if (count == 0L) {\n            return Observable.<Long>empty().delay(initialDelay, unit, scheduler);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n        ObjectHelper.requireNonNull(unit, \"unit is null\");\n        ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaPlugins.onAssembly(new ObservableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }", "positive": "package RxTranslation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\npublic final class SchedulerSupportConstants {\n    public static final String CUSTOM = \"CUSTOM\";\n}\n\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@interface CheckReturnValue {\n}\n\n@Target({ElementType.METHOD, ElementType.PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\n@interface NonNull {\n}\n\n@Target({ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@interface SchedulerSupport {\n    String value();\n}\n\nenum TimeUnit {\n    NANOSECONDS,\n    MICROSECONDS,\n    MILLISECONDS,\n    SECONDS,\n    MINUTES,\n    HOURS,\n    DAYS\n}\n\nabstract class Scheduler {\n}\n\nfinal class ObjectHelper {\n    public static <T> T RequireNonNull(T obj, String message) {\n        if (obj == null) {\n            throw new NullPointerException(message);\n        }\n        return obj;\n    }\n}\n\nabstract class Observable<T> {\n    public static <T> Observable<T> Empty() {\n        return new ObservableEmpty<>();\n    }\n\n    public Observable<T> Delay(long delay, TimeUnit unit, Scheduler scheduler) {\n        return new ObservableDelay<>(this, delay, unit, scheduler);\n    }\n\n    @CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupportConstants.CUSTOM)\n    public static Observable<Long> IntervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"count >= 0 required but it was \" + count);\n        }\n\n        if (count == 0L) {\n            return Observable.<Long>Empty().Delay(initialDelay, unit, scheduler);\n        }\n\n        long end = start + (count - 1);\n        if (start > 0 && end < 0) {\n            throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\");\n        }\n\n        ObjectHelper.RequireNonNull(unit == null ? null : unit, \"unit is null\");\n        ObjectHelper.RequireNonNull(scheduler, \"scheduler is null\");\n\n        return RxJavaPlugins.OnAssembly(new ObservableIntervalRange(start, end, Math.max(0L, initialDelay), Math.max(0L, period), unit, scheduler));\n    }\n}\n\nfinal class ObservableEmpty<T> extends Observable<T> {\n}\n\nfinal class ObservableDelay<T> extends Observable<T> {\n    public final Observable<T> Source;\n    public final long DelayAmount;\n    public final TimeUnit Unit;\n    public final Scheduler Scheduler;\n\n    public ObservableDelay(Observable<T> source, long delayAmount, TimeUnit unit, Scheduler scheduler) {\n        this.Source = source;\n        this.DelayAmount = delayAmount;\n        this.Unit = unit;\n        this.Scheduler = scheduler;\n    }\n}\n\nfinal class ObservableIntervalRange extends Observable<Long> {\n    public final long Start;\n    public final long End;\n    public final long InitialDelay;\n    public final long Period;\n    public final TimeUnit Unit;\n    public final Scheduler Scheduler;\n\n    public ObservableIntervalRange(long start, long end, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) {\n        this.Start = start;\n        this.End = end;\n        this.InitialDelay = initialDelay;\n        this.Period = period;\n        this.Unit = unit;\n        this.Scheduler = scheduler;\n    }\n}\n\nfinal class RxJavaPlugins {\n    public static <T> Observable<T> OnAssembly(Observable<T> source) {\n        return source;\n    }\n}", "type": "retranslate"}
{"anchor": "private Node<K,V> add(Node<K,V> t, K key, V val, Box<Node<K,V>> found) {\n        if (t == null) {\n//            if (val == null)\n//                return new Red<>(key);\n            return new Red<>(key, val);\n        }\n        int c = comp.compare(key, t.getKey());\n        if (c == 0) {\n            found.val = t;\n            return null;\n        }\n        Node<K,V> ins = add(c < 0 ? t.left() : t.right(),\n                            key, val, found);\n        if (ins == null) //found below\n            return null;\n        if (c < 0)\n            return t.addLeft(ins);\n        return t.addRight(ins);\n    }", "positive": "package TranslatedNamespace;\n\nimport java.util.Comparator;\n\nclass Box<T> {\n    public T val;\n}\n\n// Note: Node<K,V>, Red<K,V> and their methods (getKey(), left(), right(), addLeft(...), addRight(...)) \n// are assumed to be defined elsewhere to match the original Java implementation.\npublic class Tree<K, V> {\n    private Comparator<K> comp;\n\n    public Tree(Comparator<K> comparer) {\n        this.comp = comparer;\n    }\n\n    private Node<K, V> add(Node<K, V> t, K key, V val, Box<Node<K, V>> found) {\n        if (t == null) {\n            // if (val == null)\n            //     return new Red<>(key);\n            return new Red<K, V>(key, val);\n        }\n        int c = comp.compare(key, t.getKey());\n        if (c == 0) {\n            found.val = t;\n            return null;\n        }\n        Node<K, V> ins = add(c < 0 ? t.left() : t.right(), key, val, found);\n        if (ins == null) //found below\n            return null;\n        if (c < 0)\n            return t.addLeft(ins);\n        return t.addRight(ins);\n    }\n}", "type": "retranslate"}
{"anchor": "public static String getRowStyle(final Workbook wb, final Cell poiCell,\r\n\t\t\tfinal String inputType, final float rowHeight,\r\n\t\t\tfinal int rowspan) {\r\n\r\n\t\tCellStyle cellStyle = poiCell.getCellStyle();\r\n\t\tif ((cellStyle != null) && (rowspan == 1)) {\r\n\t\t\tshort fontIdx = cellStyle.getFontIndex();\r\n\t\t\tFont font = wb.getFontAt(fontIdx);\r\n\t\t\tfloat maxHeight = rowHeight;\r\n\t\t\tif (!inputType.isEmpty()) {\r\n\t\t\t\tmaxHeight = Math.min(font.getFontHeightInPoints() + 8f,\r\n\t\t\t\t\t\trowHeight);\r\n\t\t\t}\r\n\t\t\treturn \"height:\" + WebSheetUtility.pointsToPixels(maxHeight)\r\n\t\t\t\t\t+ \"px;\";\r\n\t\t}\r\n\t\treturn \"\";\r\n\t}", "positive": "package ExcelTranslation;\n\nimport org.apache.poi.ss.usermodel.Cell;\nimport org.apache.poi.ss.usermodel.CellStyle;\nimport org.apache.poi.ss.usermodel.Font;\nimport org.apache.poi.ss.usermodel.Workbook;\n\npublic class ExcelUtils {\n    public static String getRowStyle(Workbook wb, Cell poiCell, String inputType, float rowHeight, int rowspan) {\n        CellStyle cellStyle = poiCell.getCellStyle();\n        if (cellStyle != null && rowspan == 1) {\n            short fontIdx = cellStyle.getFontIndex();\n            Font font = wb.getFontAt(fontIdx);\n            float maxHeight = rowHeight;\n            if (inputType.length() != 0) {\n                maxHeight = Math.min((float) font.getFontHeightInPoints() + 8f, rowHeight);\n            }\n            return \"height:\" + WebSheetUtility.pointsToPixels(maxHeight) + \"px;\";\n        }\n        return \"\";\n    }\n}", "type": "retranslate"}
{"anchor": "@Override\n  protected List<ConfigIssue> init() {\n    // Validate configuration values and open any required resources.\n    List<ConfigIssue> issues = super.init();\n\n    errorRecordHandler = new DefaultErrorRecordHandler(getContext());\n    elEvals.init(getContext());\n\n    Processor.Context context = getContext();\n\n    issues.addAll(hikariConfigBean.validateConfigs(context, issues));\n\n    if (issues.isEmpty() && null == dataSource) {\n      try {\n        dataSource = jdbcUtil.createDataSourceForWrite(hikariConfigBean, null, null,\n            false,\n            issues,\n            Collections.emptyList(),\n            getContext()\n        );\n      } catch (RuntimeException | SQLException | StageException e) {\n        LOG.debug(\"Could not connect to data source\", e);\n        issues.add(getContext().createConfigIssue(Groups.JDBC.name(), CONNECTION_STRING, JdbcErrors.JDBC_00, e.toString()));\n      }\n    }\n\n    if (issues.isEmpty()) {\n      try {\n        schemaWriter = JdbcSchemaWriterFactory.create(hikariConfigBean.getConnectionString(), dataSource);\n      } catch (JdbcStageCheckedException e) {\n        issues.add(getContext().createConfigIssue(Groups.JDBC.name(), CONNECTION_STRING, e.getErrorCode(), e.getParams()));\n      }\n      schemaReader = new JdbcSchemaReader(dataSource, schemaWriter);\n\n      tableCache = CacheBuilder.newBuilder().maximumSize(50).build(new CacheLoader<Pair<String, String>, LinkedHashMap<String, JdbcTypeInfo>>() {\n        @Override\n        public LinkedHashMap<String, JdbcTypeInfo> load(Pair<String, String> pair) throws Exception {\n          return schemaReader.getTableSchema(pair.getLeft(), pair.getRight());\n        }\n      });\n    }\n\n    // If issues is not empty, the UI will inform the user of each configuration issue in the list.\n    return issues;\n  }", "negative": "protected ActionConfig resolveActionConfig(final ActionAnnotationValues annotationValues) {\n\t\tfinal Class<? extends Annotation> annotationType;\n\n\t\tif (annotationValues == null) {\n\t\t\tannotationType = Action.class;\n\t\t}\n\t\telse {\n\t\t\tannotationType = annotationValues.annotationType();\n\t\t}\n\t\treturn actionConfigManager.lookup(annotationType);\n\t}", "type": "random_negative"}
{"anchor": "@CheckReturnValue\n    @NonNull\n    @SchedulerSupport(SchedulerSupport.NONE)\n    public static <T, R> Maybe<R> zipArray(Function<? super Object[], ? extends R> zipper,\n            MaybeSource<? extends T>... sources) {\n        ObjectHelper.requireNonNull(sources, \"sources is null\");\n        if (sources.length == 0) {\n            return empty();\n        }\n        ObjectHelper.requireNonNull(zipper, \"zipper is null\");\n        return RxJavaPlugins.onAssembly(new MaybeZipArray<T, R>(sources, zipper));\n    }", "positive": "package io.reactivex;\n\nimport java.util.Objects;\nimport io.reactivex.functions.Function;\nimport io.reactivex.plugins.RxJavaPlugins;\nimport io.reactivex.internal.operators.maybe.MaybeZipArray;\nimport io.reactivex.MaybeSource;\n\npublic final class Maybe {\n\n    public static <T, R> Maybe<R> ZipArray(Function<Object[], R> zipper, MaybeSource<T>... sources) {\n        Objects.requireNonNull(sources, \"sources is null\");\n        if (sources.length == 0) {\n            return empty();\n        }\n        Objects.requireNonNull(zipper, \"zipper is null\");\n        return RxJavaPlugins.onAssembly(new MaybeZipArray<T, R>(sources, zipper));\n    }\n\n    // Placeholder methods to indicate existing members in the original library.\n    // These are not implementations, just declarations to match references in the translated method.\n    private static <R> Maybe<R> empty() {\n        throw new UnsupportedOperationException();\n    }\n}", "type": "retranslate"}
{"anchor": "private void initListEvents() {\n\t\tthis.listChangeListener = new ListChangeListener<SourceType>() {\n\t\t\t@Override\n\t\t\tpublic void onChanged(\n\t\t\t\t\tChange<? extends SourceType> listEvent) {\n\t\t\t\t\n\t\t\t\t// We have to stage delete events, because if we process them\n\t\t\t\t// separately, there will be unwanted ChangeEvents on the\n\t\t\t\t// targetList\n\t\t\t\tList<TargetType> deleteStaging = new ArrayList<>();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\twhile (listEvent.next()) {\n\t\t\t\t\tif (listEvent.wasUpdated()) {\n\t\t\t\t\t\tprocessUpdateEvent(listEvent);\n\t\t\t\t\t} else if (listEvent.wasReplaced()) {\n\t\t\t\t\t\tprocessReplaceEvent(listEvent, deleteStaging);\n\t\t\t\t\t} else if (listEvent.wasAdded()) {\n\t\t\t\t\t\tprocessAddEvent(listEvent);\n\t\t\t\t\t} else if (listEvent.wasRemoved()) {\n\t\t\t\t\t\tprocessRemoveEvent(listEvent, deleteStaging);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Process the staged elements\n\t\t\t\tprocessStagingLists(deleteStaging);\n\t\t\t}\n\t\t};\n\t\tmodelListProperty().addListener(\n\t\t\t\tnew WeakListChangeListener<>(listChangeListener));\n\t\t\n\t}", "negative": "public static float[] values(Float[] array) {\n\t\tfloat[] dest = new float[array.length];\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tFloat v = array[i];\n\t\t\tif (v != null) {\n\t\t\t\tdest[i] = v.floatValue();\n\t\t\t}\n\t\t}\n\t\treturn dest;\n\t}", "type": "random_negative"}
{"anchor": "<ViewModelType extends ViewModel> void callInitialize(View<? extends ViewModelType> view) {\n        try {\n            final Method initializeMethod = view.getClass().getMethod(NAMING_CONVENTION_INITIALIZE_IDENTIFIER);\n\n            AccessController.doPrivileged((PrivilegedAction) () -> {\n                try {\n                    return initializeMethod.invoke(view);\n                } catch (InvocationTargetException e) {\n                    LOG.warn(\"The '{}' method of the view {} has thrown an exception!\",\n                            NAMING_CONVENTION_INITIALIZE_IDENTIFIER, view);\n\n                    Throwable cause = e.getCause();\n                    if (cause instanceof RuntimeException) {\n                        throw (RuntimeException) cause;\n                    } else {\n                        throw new RuntimeException(cause);\n                    }\n                } catch (IllegalAccessException e) {\n                    LOG.warn(\"Can't invoke the '{}' method of the view {} because it is not accessible\",\n                            NAMING_CONVENTION_INITIALIZE_IDENTIFIER, view);\n                }\n                return null;\n            });\n\n        } catch (NoSuchMethodException e) {\n            // This exception means that there is no initialize method declared.\n            // While it's possible that the user has no such method by design,\n            // normally and in most cases you need an initialize method in your\n            // view (either with Initialize interface\n            // or implicit).\n            // So it's likely that the user has misspelled the method name or\n            // uses a wrong naming convention.\n            // For this reason we give the user the log message.\n            LOG.debug(\"There is no '{}' method declared at the view {}\", NAMING_CONVENTION_INITIALIZE_IDENTIFIER, view);\n        }\n    }", "positive": "import java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\npublic class ReflectionHelper {\n    public <TViewModel extends ViewModel> void callInitialize(View<TViewModel> view) throws Throwable {\n        Method initializeMethod = null;\n        boolean ambiguous = false;\n\n        // Try to locate a single method with the given name. If more than one is found, treat as ambiguous.\n        Method[] methods = view.getClass().getMethods();\n        for (Method m : methods) {\n            if (m.getName().equals(NAMING_CONVENTION_INITIALIZE_IDENTIFIER)) {\n                if (initializeMethod != null) {\n                    ambiguous = true;\n                    break;\n                }\n                initializeMethod = m;\n            }\n        }\n\n        if (ambiguous) {\n            // Multiple methods matched; treat as no such method declared for logging purposes\n            LOG.debug(\"There is no '{}' method declared at the view {}\", NAMING_CONVENTION_INITIALIZE_IDENTIFIER, view);\n            return;\n        }\n\n        if (initializeMethod != null) {\n            try {\n                initializeMethod.invoke(view);\n            } catch (InvocationTargetException e) {\n                LOG.warn(\"The '{}' method of the view {} has thrown an exception!\", NAMING_CONVENTION_INITIALIZE_IDENTIFIER, view);\n\n                Throwable cause = e.getCause();\n                if (cause != null) {\n                    throw cause;\n                } else {\n                    throw new Exception(\"An exception occurred while invoking the method.\", e);\n                }\n            } catch (IllegalAccessException e) {\n                LOG.warn(\"Can't invoke the '{}' method of the view {} because it is not accessible\", NAMING_CONVENTION_INITIALIZE_IDENTIFIER, view);\n            }\n        } else {\n            LOG.debug(\"There is no '{}' method declared at the view {}\", NAMING_CONVENTION_INITIALIZE_IDENTIFIER, view);\n        }\n    }\n}", "type": "retranslate"}
{"anchor": "public int appendUnfragmentedMessage(\n        final HeaderWriter header,\n        final DirectBuffer bufferOne,\n        final int offsetOne,\n        final int lengthOne,\n        final DirectBuffer bufferTwo,\n        final int offsetTwo,\n        final int lengthTwo,\n        final ReservedValueSupplier reservedValueSupplier,\n        final int activeTermId)\n    {\n        final int frameLength = lengthOne + lengthTwo + HEADER_LENGTH;\n        final int alignedLength = align(frameLength, FRAME_ALIGNMENT);\n        final UnsafeBuffer termBuffer = this.termBuffer;\n        final int termLength = termBuffer.capacity();\n\n        final long rawTail = getAndAddRawTail(alignedLength);\n        final int termId = termId(rawTail);\n        final long termOffset = rawTail & 0xFFFF_FFFFL;\n\n        checkTerm(activeTermId, termId);\n\n        long resultingOffset = termOffset + alignedLength;\n        if (resultingOffset > termLength)\n        {\n            resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId);\n        }\n        else\n        {\n            final int frameOffset = (int)termOffset;\n            header.write(termBuffer, frameOffset, frameLength, termId);\n            termBuffer.putBytes(frameOffset + HEADER_LENGTH, bufferOne, offsetOne, lengthOne);\n            termBuffer.putBytes(frameOffset + HEADER_LENGTH + lengthOne, bufferTwo, offsetTwo, lengthTwo);\n\n            if (null != reservedValueSupplier)\n            {\n                final long reservedValue = reservedValueSupplier.get(termBuffer, frameOffset, frameLength);\n                termBuffer.putLong(frameOffset + RESERVED_VALUE_OFFSET, reservedValue, LITTLE_ENDIAN);\n            }\n\n            frameLengthOrdered(termBuffer, frameOffset, frameLength);\n        }\n\n        return (int)resultingOffset;\n    }", "positive": "import org.agrona.DirectBuffer;\nimport org.agrona.concurrent.UnsafeBuffer;\nimport java.nio.ByteOrder;\n\npublic class TermAppender\n{\n    private UnsafeBuffer termBuffer;\n\n    public int appendUnfragmentedMessage(\n        HeaderWriter header,\n        DirectBuffer bufferOne,\n        int offsetOne,\n        int lengthOne,\n        DirectBuffer bufferTwo,\n        int offsetTwo,\n        int lengthTwo,\n        ReservedValueSupplier reservedValueSupplier,\n        int activeTermId)\n    {\n        int frameLength = lengthOne + lengthTwo + HEADER_LENGTH;\n        int alignedLength = align(frameLength, FRAME_ALIGNMENT);\n        UnsafeBuffer termBuffer = this.termBuffer;\n        int termLength = termBuffer.capacity();\n\n        long rawTail = getAndAddRawTail(alignedLength);\n        int termId = termId(rawTail);\n        long termOffset = rawTail & 0xFFFF_FFFFL;\n\n        checkTerm(activeTermId, termId);\n\n        long resultingOffset = termOffset + alignedLength;\n        if (resultingOffset > termLength)\n        {\n            resultingOffset = handleEndOfLogCondition(termBuffer, termOffset, header, termLength, termId);\n        }\n        else\n        {\n            int frameOffset = (int)termOffset;\n            header.write(termBuffer, frameOffset, frameLength, termId);\n            termBuffer.putBytes(frameOffset + HEADER_LENGTH, bufferOne, offsetOne, lengthOne);\n            termBuffer.putBytes(frameOffset + HEADER_LENGTH + lengthOne, bufferTwo, offsetTwo, lengthTwo);\n\n            if (reservedValueSupplier != null)\n            {\n                long reservedValue = reservedValueSupplier.get(termBuffer, frameOffset, frameLength);\n                termBuffer.putLong(frameOffset + RESERVED_VALUE_OFFSET, reservedValue, ByteOrder.LITTLE_ENDIAN);\n            }\n\n            frameLengthOrdered(termBuffer, frameOffset, frameLength);\n        }\n\n        return (int)resultingOffset;\n    }\n\n    // Placeholder members/methods assumed to exist elsewhere in the class or project:\n    private static final int HEADER_LENGTH = 0;\n    private static final int FRAME_ALIGNMENT = 0;\n    private static final int RESERVED_VALUE_OFFSET = 0;\n\n    private int align(int value, int alignment) { throw new UnsupportedOperationException(); }\n    private long getAndAddRawTail(int delta) { throw new UnsupportedOperationException(); }\n    private int termId(long rawTail) { throw new UnsupportedOperationException(); }\n    private void checkTerm(int activeTermId, int termId) { throw new UnsupportedOperationException(); }\n    private long handleEndOfLogCondition(UnsafeBuffer termBuffer, long termOffset, HeaderWriter header, int termLength, int termId) { throw new UnsupportedOperationException(); }\n    private void frameLengthOrdered(UnsafeBuffer termBuffer, int frameOffset, int frameLength) { throw new UnsupportedOperationException(); }\n\n    // Placeholder interfaces/classes for compilation context\n    public interface HeaderWriter\n    {\n        void write(UnsafeBuffer buffer, int offset, int frameLength, int termId);\n    }\n\n    public interface ReservedValueSupplier\n    {\n        long get(UnsafeBuffer buffer, int offset, int length);\n    }\n}", "type": "retranslate"}
{"anchor": "public UserQueryListing getAllUserQueries() {\n\t\tUserQuery userQueryToGetInfoFor = new UserQuery();\n\n\t\tif(this.serviceTicket != null) {\n\t\t\tuserQueryToGetInfoFor.setServiceTicket(this.serviceTicket);\n\t\t}\n\n\t\ttry {\n\t\t\treturn new UserQueryListing(this.postJson(\n\t\t\t\t\tuserQueryToGetInfoFor, WS.Path.UserQuery.Version1.getAllUserQueries()));\n\t\t}\n\t\t//\n\t\tcatch (JSONException jsonExcept) {\n\t\t\tthrow new FluidClientException(jsonExcept.getMessage(),\n\t\t\t\t\tFluidClientException.ErrorCode.JSON_PARSING);\n\t\t}\n\t}", "negative": "private static final boolean checkDouble(String s)\n    {\n        try {\n            //Coverity[FB.DLS_DEAD_LOCAL_STORE]\n            double val = Double.parseDouble(s);\n            if(DebugValueChecking) {\n                DAPNode.log.debug(\"Attribute.checkDouble() - string: '\" + s + \"'   value: \" + val);\n            }\n            return true;\n        } catch (NumberFormatException e) {\n            if(s.equalsIgnoreCase(\"nan\") || s.equalsIgnoreCase(\"inf\"))\n                return true;\n\n            return false;\n        }\n    }", "type": "random_negative"}
{"anchor": "protected void registerScopeFactory(ScopeFactory scopeFactory) {\r\n\t\tif (scopeFactory == null) {\r\n\t\t\tlog.debug(\"Register null scope factory to |%s|.\", InstanceScope.LOCAL);\r\n\t\t\tscopeFactories.put(InstanceScope.LOCAL, null);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfinal InstanceScope instanceScope = scopeFactory.getInstanceScope();\r\n\t\tlog.debug(\"Register scope factory |%s| to |%s|.\", scopeFactory.getClass(), instanceScope);\r\n\t\tif (scopeFactories.put(instanceScope, scopeFactory) != null) {\r\n\t\t\tthrow new BugError(\"Attempt to override instance scope |%s|.\", instanceScope);\r\n\t\t}\r\n\t}", "negative": "public Role getRoleById(Long roleIdParam)\n    {\n        Role roleToGetInfoFor = new Role();\n        roleToGetInfoFor.setId(roleIdParam);\n\n        if(this.serviceTicket != null)\n        {\n            roleToGetInfoFor.setServiceTicket(this.serviceTicket);\n        }\n\n        try {\n            return new Role(this.postJson(\n                    roleToGetInfoFor, WS.Path.Role.Version1.getById()));\n        }\n        //\n        catch (JSONException jsonExcept) {\n            throw new FluidClientException(jsonExcept.getMessage(),\n                    FluidClientException.ErrorCode.JSON_PARSING);\n        }\n    }", "type": "random_negative"}
{"anchor": "Index permute(int[] dims) {\r\n    if (dims.length != shape.length)\r\n      throw new IllegalArgumentException();\r\n    for (int dim : dims)\r\n      if ((dim < 0) || (dim >= rank))\r\n        throw new IllegalArgumentException();\r\n\r\n    boolean isPermuted = false;\r\n    Index newIndex = (Index) this.clone();\r\n    for (int i = 0; i < dims.length; i++) {\r\n      newIndex.stride[i] = stride[dims[i]];\r\n      newIndex.shape[i] = shape[dims[i]];\r\n      //if (name != null) newIndex.name[i] = name[dims[i]];\r\n      if (i != dims[i]) isPermuted = true;\r\n    }\r\n\r\n    newIndex.fastIterator = fastIterator && !isPermuted; // useful optimization\r\n    newIndex.precalc(); // any subclass-specific optimizations\r\n    return newIndex;\r\n  }", "positive": "param_63 calcPermute(int[] arg_10) { \n    if (arg_10.length !=  obj_45.length)\r\n throw new processIllegalArgumentException(); \n    for (int item_55 : arg_10)\r\n if ((item_55 < 0) || (item_55 >= param_86)) \n         throw new processIllegalArgumentException();\r\n\r\n     boolean tmp_86 = false;\r\n    param_63 item_33 =  (param_63) this.clone(); \r\n    for (int tmp_42 = 0; tmp_42 < arg_10.length; tmp_42++) {\r\n      item_33.var_74[tmp_42] = var_74[arg_10[tmp_42]];\r\n      item_33.obj_45[tmp_42] =  obj_45[arg_10[tmp_42]]; \r\n      //if (val_23 != null) item_33.val_23[tmp_42] = val_23[arg_10[tmp_42]];\r\n      if (tmp_42 !=  arg_10[tmp_42]) tmp_86 =  true; \r\n    }\r  // Return the result\n\r\n    item_33.obj_27 =  obj_27 && !tmp_86;  / /  obj_78 obj_54\r\n    item_33.precalc();  / /  item_47 obj_52- arg_48 var_52\r\n      return item_33;\r\n  }", "type": "augment"}
{"anchor": "public static void removeScopeAttribute(final String name, final String scope, final PageContext pageContext) {\n\t\tHttpServletRequest request = (HttpServletRequest) pageContext.getRequest();\n\t\tString scopeValue = scope != null ? scope.toLowerCase() : SCOPE_PAGE;\n\t\tif (scopeValue.equals(SCOPE_PAGE)) {\n\t\t\tpageContext.removeAttribute(name);\n\t\t}\n\t\telse if (scopeValue.equals(SCOPE_REQUEST)) {\n\t\t\trequest.removeAttribute(name);\n\t\t}\n\t\telse if (scopeValue.equals(SCOPE_SESSION)) {\n\t\t\trequest.getSession().removeAttribute(name);\n\t\t}\n\t\telse if (scopeValue.equals(SCOPE_APPLICATION)) {\n            request.getServletContext().removeAttribute(name);\n        }\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Invalid scope: \" + scope);\n        }\n\t}", "positive": "public static void removeScopeAttribute(final String name, final String scope, final PageContext pageContext) {\n    final HttpServletRequest request = (HttpServletRequest) pageContext.getRequest();\n    final String scopeValue = scope != null ? scope.toLowerCase() : SCOPE_PAGE;\n    switch (scopeValue) {\n        case SCOPE_PAGE:\n            pageContext.removeAttribute(name);\n            break;\n        case SCOPE_REQUEST:\n            request.removeAttribute(name);\n            break;\n        case SCOPE_SESSION:\n            request.getSession().removeAttribute(name);\n            break;\n        case SCOPE_APPLICATION:\n            request.getServletContext().removeAttribute(name);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid scope: \" + scope);\n    }\n}", "type": "llm_rewrite"}
{"anchor": "private boolean popFile() throws JasperException {\n\n\t// Is stack created ? (will happen if the Jsp file we're looking at is\n\t// missing.\n\tif (current == null || currFileId < 0) {\n\t    return false;\n\t}\n\n\t// Restore parser state:\n\tString fName = getFile(currFileId);\n\tcurrFileId = unregisterSourceFile(fName);\n\tif (currFileId < -1) {\n\t    err.jspError(\"jsp.error.file.not.registered\", fName);\n\t}\n\n\tMark previous = current.popStream();\n\tif (previous != null) {\n\t    master = current.baseDir;\n\t    current = previous;\n\t    return true;\n\t}\n\t// Note that although the current file is undefined here, \"current\"\n\t// is not set to null just for convience, for it maybe used to\n\t// set the current (undefined) position.\n\treturn false;\n    }", "negative": "public static void removeScopeAttribute(final String name, final String scope, final PageContext pageContext) {\n\t\tHttpServletRequest request = (HttpServletRequest) pageContext.getRequest();\n\t\tString scopeValue = scope != null ? scope.toLowerCase() : SCOPE_PAGE;\n\t\tif (scopeValue.equals(SCOPE_PAGE)) {\n\t\t\tpageContext.removeAttribute(name);\n\t\t}\n\t\telse if (scopeValue.equals(SCOPE_REQUEST)) {\n\t\t\trequest.removeAttribute(name);\n\t\t}\n\t\telse if (scopeValue.equals(SCOPE_SESSION)) {\n\t\t\trequest.getSession().removeAttribute(name);\n\t\t}\n\t\telse if (scopeValue.equals(SCOPE_APPLICATION)) {\n            request.getServletContext().removeAttribute(name);\n        }\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Invalid scope: \" + scope);\n        }\n\t}", "type": "random_negative"}
{"anchor": "private void makeTimeCoordinate2D(NetcdfFile ncfile, Group g, CoordinateTime2D time2D,\n      GribCollectionImmutable.Type gctype) {\n    CoordinateRuntime runtime = time2D.getRuntimeCoordinate();\n\n    int ntimes = time2D.getNtimes();\n    String tcName = time2D.getName();\n    String dims = runtime.getName() + \" \" + tcName;\n    int dimLength = ntimes;\n\n    ncfile.addDimension(g, new Dimension(tcName, dimLength));\n    Variable v = ncfile\n        .addVariable(g, new Variable(ncfile, g, null, tcName, DataType.DOUBLE, dims));\n    String units = runtime.getUnit(); // + \" since \" + runtime.getFirstDate();\n    v.addAttribute(new Attribute(CDM.UNITS, units));\n    v.addAttribute(new Attribute(CF.STANDARD_NAME, CF.TIME));\n    v.addAttribute(new Attribute(CDM.LONG_NAME, Grib.GRIB_VALID_TIME));\n    v.addAttribute(new Attribute(CF.CALENDAR, Calendar.proleptic_gregorian.toString()));\n\n    // the data is not generated until asked for to save space\n    if (!time2D.isTimeInterval()) {\n      v.setSPobject(new Time2Dinfo(Time2DinfoType.off, time2D, null));\n    } else {\n      v.setSPobject(new Time2Dinfo(Time2DinfoType.intv, time2D, null));\n      // bounds for intervals\n      String bounds_name = tcName + \"_bounds\";\n      Variable bounds = ncfile\n          .addVariable(g, new Variable(ncfile, g, null, bounds_name, DataType.DOUBLE, dims + \" 2\"));\n      v.addAttribute(new Attribute(CF.BOUNDS, bounds_name));\n      bounds.addAttribute(new Attribute(CDM.UNITS, units));\n      bounds.addAttribute(new Attribute(CDM.LONG_NAME, \"bounds for \" + tcName));\n      bounds.setSPobject(new Time2Dinfo(Time2DinfoType.bounds, time2D, null));\n    }\n\n  }", "positive": "private void makeTimeCoordinate2D(NetcdfFile ncfile, Group g, CoordinateTime2D time2D,\n      GribCollectionImmutable.Type gctype) {\n    CoordinateRuntime runtime = time2D.getRuntimeCoordinate();\n\n    int ntimes = time2D.getNtimes();\n    String tcName = time2D.getName();\n    String dims = runtime.getName() + \" \" + tcName;\n\n    // add dimension and main time variable\n    ncfile.addDimension(g, new Dimension(tcName, ntimes));\n    Variable v = ncfile.addVariable(g, new Variable(ncfile, g, null, tcName, DataType.DOUBLE, dims));\n\n    String units = runtime.getUnit();\n    v.addAttribute(new Attribute(CDM.UNITS, units));\n    v.addAttribute(new Attribute(CF.STANDARD_NAME, CF.TIME));\n    v.addAttribute(new Attribute(CDM.LONG_NAME, Grib.GRIB_VALID_TIME));\n    v.addAttribute(new Attribute(CF.CALENDAR, Calendar.proleptic_gregorian.toString()));\n\n    // set SPobject to defer data generation; add bounds variable if intervals\n    if (!time2D.isTimeInterval()) {\n      v.setSPobject(new Time2Dinfo(Time2DinfoType.off, time2D, null));\n    } else {\n      v.setSPobject(new Time2Dinfo(Time2DinfoType.intv, time2D, null));\n\n      String boundsName = tcName + \"_bounds\";\n      Variable bounds = ncfile.addVariable(g,\n          new Variable(ncfile, g, null, boundsName, DataType.DOUBLE, dims + \" 2\"));\n      v.addAttribute(new Attribute(CF.BOUNDS, boundsName));\n      bounds.addAttribute(new Attribute(CDM.UNITS, units));\n      bounds.addAttribute(new Attribute(CDM.LONG_NAME, \"bounds for \" + tcName));\n      bounds.setSPobject(new Time2Dinfo(Time2DinfoType.bounds, time2D, null));\n    }\n  }", "type": "llm_rewrite"}
{"anchor": "public <RET extends Object> RET newInstance(final String iClassName, final Object iEnclosingClass, Object... iArgs) {\r\n    underlying.checkIfActive();\r\n\r\n    checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_CREATE, iClassName);\r\n\r\n    try {\r\n      Class<?> entityClass = entityManager.getEntityClass(iClassName);\r\n      if (entityClass != null) {\r\n        RET enhanced = (RET) OObjectEntityEnhancer.getInstance()\r\n            .getProxiedInstance(entityManager.getEntityClass(iClassName), iEnclosingClass, underlying.newInstance(iClassName), null,\r\n                iArgs);\r\n        return (RET) enhanced;\r\n      } else {\r\n        throw new OSerializationException(\"Type \" + iClassName\r\n            + \" cannot be serialized because is not part of registered entities. To fix this error register this class\");\r\n      }\r\n    } catch (Exception e) {\r\n      final String message = \"Error on creating object of class \" + iClassName;\r\n      OLogManager.instance().error(this, message, e);\r\n\r\n      throw OException.wrapException(new ODatabaseException(message), e);\r\n    }\r\n  }", "positive": "public <RET> RET newInstance(String iClassName, Object iEnclosingClass, Object... iArgs) {\n    underlying.checkIfActive();\n\n    checkSecurity(ORule.ResourceGeneric.CLASS, ORole.PERMISSION_CREATE, iClassName);\n\n    try {\n        Class<?> entityClass = entityManager.getEntityClass(iClassName);\n        if (entityClass != null) {\n            @SuppressWarnings(\"unchecked\")\n            RET enhanced = (RET) OObjectEntityEnhancer.getInstance()\n                .getProxiedInstance(entityManager.getEntityClass(iClassName), iEnclosingClass, underlying.newInstance(iClassName), null,\n                    iArgs);\n            return enhanced;\n        } else {\n            throw new OSerializationException(\"Type \" + iClassName\n                + \" cannot be serialized because is not part of registered entities. To fix this error register this class\");\n        }\n    } catch (Exception e) {\n        String message = \"Error on creating object of class \" + iClassName;\n        OLogManager.instance().error(this, message, e);\n\n        throw OException.wrapException(new ODatabaseException(message), e);\n    }\n}", "type": "retranslate"}
{"anchor": "public static Map addDefaultContext(Object root, MemberAccess memberAccess, ClassResolver classResolver,\n                                        TypeConverter converter, Map context)\n    {\n        OgnlContext result;\n\n        if (context instanceof OgnlContext) {\n            result = (OgnlContext) context;\n        } else {\n            result = new OgnlContext(memberAccess, classResolver, converter, context);\n        }\n\n        result.setRoot(root);\n        return result;\n    }", "positive": "public static Map addDefaultContext(Object root, MemberAccess memberAccess, ClassResolver classResolver,\n                                        TypeConverter converter, Map context)\n    {\n        OgnlContext result = (context instanceof OgnlContext)\n                ? (OgnlContext) context\n                : new OgnlContext(memberAccess, classResolver, converter, context);\n        result.setRoot(root);\n        return result;\n    }", "type": "llm_rewrite"}
{"anchor": "public void badURL(HttpServletRequest request, HttpServletResponse response)\n            throws Exception\n    {\n        if(Debug.isSet(\"showResponse\")) {\n            log.debug(\"Sending Bad URL Page.\");\n        }\n\n        //log.info(\"DODSServlet.badURL \" + rs.getRequest().getRequestURI());\n\n        response.setContentType(\"text/html\");\n        response.setHeader(\"XDODS-Server\", getServerVersion());\n        response.setHeader(\"Content-Description\", \"dods-error\");\n        // Commented because of a bug in the OPeNDAP C++ stuff...\n        //rs.getResponse().setHeader(\"Content-Encoding\", \"plain\");\n\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(response.getOutputStream(), Util.UTF8));\n\n        printBadURLPage(pw);\n        printHelpPage(pw);\n        pw.flush();\n\n        response.setStatus(HttpServletResponse.SC_OK);\n\n    }", "positive": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.nio.charset.StandardCharsets;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class DODSHandler {\n\n    public void badURL(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        if (Debug.isSet(\"showResponse\")) {\n            log.debug(\"Sending Bad URL Page.\");\n        }\n\n        //log.info(\"DODSServlet.badURL \" + rs.getRequest().getRequestURI());\n\n        response.setContentType(\"text/html\");\n        response.addHeader(\"XDODS-Server\", getServerVersion());\n        response.addHeader(\"Content-Description\", \"dods-error\");\n        // Commented because of a bug in the OPeNDAP C++ stuff...\n        // response.addHeader(\"Content-Encoding\", \"plain\");\n\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(response.getOutputStream(), StandardCharsets.UTF_8), true);\n\n        printBadURLPage(pw);\n        printHelpPage(pw);\n        pw.flush();\n\n        response.setStatus(HttpServletResponse.SC_OK);\n    }\n}", "type": "retranslate"}
{"anchor": "public ImageApiProfile merge(ImageApiProfile other) {\n    ImageApiProfile merged = new ImageApiProfile();\n    streamNotNull(this.features).forEach(merged::addFeature);\n    streamNotNull(other.features).forEach(merged::addFeature);\n    streamNotNull(this.formats).forEach(merged::addFormat);\n    streamNotNull(other.formats).forEach(merged::addFormat);\n    streamNotNull(this.qualities).forEach(merged::addQuality);\n    streamNotNull(other.qualities).forEach(merged::addQuality);\n    if (this.maxWidth != null && other.maxWidth == null) {\n      merged.maxWidth = this.maxWidth;\n    } else if (this.maxWidth == null && other.maxWidth != null) {\n      merged.maxWidth = other.maxWidth;\n    } else if (this.maxWidth != null) {\n      merged.maxWidth = Math.min(this.maxWidth, other.maxWidth);\n    }\n    if (this.maxHeight != null && other.maxHeight == null) {\n      merged.maxHeight = this.maxHeight;\n    } else if (this.maxHeight == null && other.maxHeight != null) {\n      merged.maxHeight = other.maxHeight;\n    } else if (this.maxHeight != null) {\n      merged.maxHeight = Math.min(this.maxHeight, other.maxHeight);\n    }\n    if (this.maxArea != null && other.maxArea == null) {\n      merged.maxArea = this.maxArea;\n    } else if (this.maxArea == null && other.maxArea != null) {\n      merged.maxArea = other.maxArea;\n    } else if (this.maxArea != null) {\n      merged.maxArea = Math.min(this.maxArea, other.maxArea);\n    }\n    return merged;\n  }", "negative": "public static String getFirstText(Element parent) {\n        Assert.isNotNull(parent);\n        Node child = parent.getFirstChild();\n        while (child != null && !isText(child))\n            child = child.getNextSibling();\n        if (child == null)\n            return \"\"; //$NON-NLS-1$\n        return ((Text) child).getData();\n    }", "type": "random_negative"}
{"anchor": "public static String getDefaultWatchServiceId()\n    {\n        String result = \"polling\";\n        String osName = System.getProperty( \"os.name\" );\n        if ( osName != null )\n        {\n            osName = osName.toLowerCase( Locale.ENGLISH );\n            if ( osName.contains( \"windows\" ) || osName.contains( \"linux\" ) )\n            {\n                result = isAtLeastJava7() ? \"jdk7\" : \"jnotify\";\n            }\n            else if ( osName.contains( \"mac\" ) )\n            {\n                result = \"jnotify\";\n            }\n        }\n        return result;\n    }", "positive": "import java.util.Locale;\n\npublic final class WatchServiceUtil {\n\n    private WatchServiceUtil() {\n        // utility class\n    }\n\n    public static String getDefaultWatchServiceId() {\n        String result = \"polling\";\n        String osName = System.getProperty(\"os.name\");\n        if (osName != null) {\n            String osLower = osName.toLowerCase(Locale.ROOT);\n            if (osLower.contains(\"windows\") || osLower.contains(\"linux\")) {\n                result = isAtLeastJava7() ? \"jdk7\" : \"jnotify\";\n            } else if (osLower.contains(\"mac\")) {\n                result = \"jnotify\";\n            }\n        }\n        return result;\n    }\n\n    // Attempts to determine if a Java runtime of at least version 7 is available by inspecting common environment variables.\n    // This mirrors the intent of the original Java helper; in environments without Java-related variables this will return false.\n    public static boolean isAtLeastJava7() {\n        String version = System.getenv(\"java.version\");\n        if (version == null || version.isEmpty()) {\n            version = System.getenv(\"JAVA_VERSION\");\n        }\n\n        if (version == null || version.isEmpty()) {\n            // Try to infer from JAVA_HOME if available\n            String javaHome = System.getenv(\"JAVA_HOME\");\n            if (javaHome != null && !javaHome.isEmpty()) {\n                String javaHomeLower = javaHome.toLowerCase(Locale.ROOT);\n                int idx = javaHomeLower.indexOf(\"jdk\");\n                if (idx >= 0) {\n                    String sub = javaHome.substring(idx + 3);\n                    if (sub != null && !sub.isEmpty()) {\n                        // strip non-digit/non-dot prefix\n                        int start = 0;\n                        while (start < sub.length() && !Character.isDigit(sub.charAt(start))) start++;\n                        if (start < sub.length()) {\n                            int end = start;\n                            while (end < sub.length() && (Character.isDigit(sub.charAt(end)) || sub.charAt(end) == '.')) end++;\n                            version = sub.substring(start, end);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (version == null || version.isEmpty()) {\n            return false;\n        }\n\n        version = version.trim();\n        // Versions like \"1.7.0_80\" or \"11.0.2\"\n        if (version.startsWith(\"1.\")) {\n            String[] parts = version.split(\"\\\\.\");\n            if (parts.length >= 2) {\n                try {\n                    int minor = Integer.parseInt(parts[1]);\n                    return minor >= 7;\n                } catch (NumberFormatException e) {\n                    // fall through\n                }\n            }\n        } else {\n            String[] parts = version.split(\"\\\\.\");\n            if (parts.length >= 1) {\n                try {\n                    int major = Integer.parseInt(parts[0]);\n                    return major >= 7;\n                } catch (NumberFormatException e) {\n                    // fall through\n                }\n            }\n        }\n\n        return false;\n    }\n}", "type": "retranslate"}
{"anchor": "public static boolean isAbsoluteUrl(String url) {\n\t\tif (url == null) {\n\t\t\treturn false;\n\t\t}\n\t\tfinal Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\",\n\t\t\t\tPattern.CASE_INSENSITIVE);\n\n\t\treturn ABSOLUTE_URL.matcher(url).matches();\n\t}", "positive": "import java.util.regex.Pattern;\n\npublic final class UrlUtils {\n    private UrlUtils() {\n        // Prevent instantiation\n    }\n\n    public static boolean isAbsoluteUrl(String url) {\n        if (url == null) {\n            return false;\n        }\n\n        Pattern ABSOLUTE_URL = Pattern.compile(\"\\\\A[a-z0-9.+-]+://.*\\\\z\", Pattern.CASE_INSENSITIVE);\n\n        return ABSOLUTE_URL.matcher(url).matches();\n    }\n}", "type": "retranslate"}
{"anchor": "private String eatTerm() throws ParseException {\r\n    StringBuilder b = new StringBuilder();\r\n    for (; ; ) {\r\n      char val = peek();\r\n      if (!Character.isJavaIdentifierPart(val)) {\r\n        break;\r\n      }\r\n      b.append(getChar());\r\n    }\r\n    return b.toString();\r\n  }", "positive": "package TranslatedCode;\n\npublic abstract class Parser {\n    private String eatTerm() {\n        StringBuilder b = new StringBuilder();\n        for (;;) {\n            char val = peek();\n            if (!IsJavaIdentifierPart(val)) {\n                break;\n            }\n            b.append(getChar());\n        }\n        return b.toString();\n    }\n\n    protected abstract char peek();\n    protected abstract char getChar();\n\n    private static boolean IsJavaIdentifierPart(char ch) {\n        if (Character.isLetterOrDigit(ch)) {\n            return true;\n        }\n\n        int type = Character.getType(ch);\n        switch (type) {\n            case Character.CONNECTOR_PUNCTUATION:\n            case Character.NON_SPACING_MARK:\n            case Character.COMBINING_SPACING_MARK:\n            case Character.ENCLOSING_MARK:\n            case Character.DECIMAL_DIGIT_NUMBER:\n            case Character.LETTER_NUMBER:\n            case Character.CURRENCY_SYMBOL:\n            case Character.FORMAT:\n                return true;\n            default:\n                return false;\n        }\n    }\n}", "type": "retranslate"}
{"anchor": "public final boolean isReciprocalOf(final Dimension that) {\n        final Factor[] theseFactors = _factors;\n        final Factor[] thoseFactors = that._factors;\n        boolean isReciprocalOf;\n        if (theseFactors.length != thoseFactors.length) {\n            isReciprocalOf = false;\n        }\n        else {\n            int i;\n            for (i = theseFactors.length; --i >= 0;) {\n                if (!theseFactors[i].isReciprocalOf(thoseFactors[i])) {\n                    break;\n                }\n            }\n            isReciprocalOf = i < 0;\n        }\n        return isReciprocalOf;\n    }", "positive": "package TranslatedCode;\n\npublic final class Dimension {\n    private final Factor[] _factors;\n\n    public Dimension(Factor[] factors) {\n        _factors = factors;\n    }\n\n    public boolean IsReciprocalOf(Dimension that) {\n        Factor[] theseFactors = _factors;\n        Factor[] thoseFactors = that._factors;\n        boolean isReciprocalOf;\n        if (theseFactors.length != thoseFactors.length) {\n            isReciprocalOf = false;\n        } else {\n            int i;\n            for (i = theseFactors.length; --i >= 0;) {\n                if (!theseFactors[i].IsReciprocalOf(thoseFactors[i])) {\n                    break;\n                }\n            }\n            isReciprocalOf = i < 0;\n        }\n        return isReciprocalOf;\n    }\n}\n\npublic abstract class Factor {\n    public abstract boolean IsReciprocalOf(Factor other);\n}", "type": "retranslate"}
{"anchor": "private void buildCells(final String fullName,\r\n\t\t\tfinal ConfigBuildRef configBuildRef, final int atRow,\r\n\t\t\tfinal Map<String, Object> context,\r\n\t\t\tfinal List<RowsMapping> rowsMappingList) {\r\n\r\n\t\tif ((context == null) || context.isEmpty()) {\r\n\t\t\t// no need to evaluate as there's no data object.\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// keep rowsMappingList as current as no change\r\n\t\t// allRowsMappingList = child + current\r\n\r\n\t\tList<RowsMapping> allRowsMappingList = ConfigurationUtility\r\n\t\t\t\t.findChildRowsMappingFromShiftMap(fullName,\r\n\t\t\t\t\t\tconfigBuildRef.getShiftMap());\r\n\t\tallRowsMappingList.addAll(rowsMappingList);\r\n\r\n\t\tint lastRowPlus = this.getLastRowPlusRef().getRowIndex();\r\n\t\tShiftFormulaRef shiftFormulaRef = new ShiftFormulaRef(\r\n\t\t\t\tconfigBuildRef.getWatchList(), allRowsMappingList);\r\n\t\tfor (int i = atRow; i < lastRowPlus; i++) {\r\n\t\t\tbuildCellsForRow(configBuildRef.getSheet().getRow(i), fullName,\r\n\t\t\t\t\tcontext, configBuildRef, shiftFormulaRef);\r\n\t\t}\r\n\t}", "positive": "import java.util.List;\nimport java.util.Map;\n\nprivate void BuildCells(String fullName, ConfigBuildRef configBuildRef, int atRow, Map<String, Object> context, List<RowsMapping> rowsMappingList) {\n    if ((context == null) || context.isEmpty()) {\n        // no need to evaluate as there's no data object.\n        return;\n    }\n\n    // keep rowsMappingList as current as no change\n    // allRowsMappingList = child + current\n\n    List<RowsMapping> allRowsMappingList = ConfigurationUtility.findChildRowsMappingFromShiftMap(fullName, configBuildRef.getShiftMap());\n    allRowsMappingList.addAll(rowsMappingList);\n\n    int lastRowPlus = this.getLastRowPlusRef().getRowIndex();\n    ShiftFormulaRef shiftFormulaRef = new ShiftFormulaRef(configBuildRef.getWatchList(), allRowsMappingList);\n    for (int i = atRow; i < lastRowPlus; i++) {\n        buildCellsForRow(configBuildRef.getSheet().getRow(i), fullName, context, configBuildRef, shiftFormulaRef);\n    }\n}", "type": "retranslate"}
